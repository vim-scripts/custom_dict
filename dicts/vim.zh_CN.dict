/*-+ v 系统变量 o 选项 c 命令 f 函数 e 自动命令的事件 
+-*/buff _ 缓冲区
+-*/+-*/badd c 增加缓冲区到缓冲区列表
						*:bad* *:badd*
:bad[d]	[+lnum] {fname}
		在缓冲区列表里添加文件名 {fname}，但是不把该文件载入内存。
		如果指定了 "lnum"，那么第一次进入缓冲区时，光标会停留在那一
		行。注意 其它 + 后面的命令将被忽略。

+-*/+-*/ball c 为缓冲区列表里的每个缓冲区打开一个窗口
:[N]ba[ll] [N]					*:ba* *:ball* *:sba* *:sball*
:[N]sba[ll] [N]	重新排列屏幕，给缓冲区列表中的每一个缓冲区打开一个窗口。如果给
		出计数，则计数为打开窗口的最多数目。''winheight' 也限制了打开
		窗口的数目 (当前缀 |:vertical| 时则为 'winwidth')。
		Buf/Win Enter/Leave 不会在新窗口执行，只有真正进入这些窗口时才
		会。
		如果使用 |:tab| 修饰符，新窗口在新标签页上打开，直到用完
		'tabpagemax' 个标签页为止。

+-*/+-*/bdelete c 从缓冲区列表删除缓冲区
:[N]bd[elete][!]			*:bd* *:bdel* *:bdelete* *E516*
:bd[elete][!] [N]
		卸载缓冲区 [N] (默认：当前缓冲区) 并且从缓冲区列表里删除该缓冲
		区。如果缓冲区被改动过，那么该命令将失败，除非使用 [!]，但是这
		样所有的改动都会丢失，文件不受影响。该缓冲区的所有窗口都会关
		闭。如果缓冲区 [N] 是当前的缓冲区，那么 Vim 会显示另一个缓冲区
		来代替。具体来说，Vim 会选择跳转表里最新且已经载入的缓冲区。
		实际上，该缓冲区还没有被完全删除，但是缓冲区列表把它除名
		|unlisted-buffer|，而且该缓冲区中选项的值、变量、映射和缩写被
		清空。

+-*/+-*/bufdo c 为所有列表内缓冲区执行命令
							*:bufdo*
:bufdo[!] {cmd}		在缓冲区列表的每一个缓冲区里执行 {cmd}。
			就像是： >
				:bfirst
				:{cmd}
				:bnext
				:{cmd}
				等等……
<			如果当前文件不能被丢弃 |abandon|，并且没有使用 [!]，命
			令失败。
			当在一个缓冲区里检测到错误，剩下的缓冲区不再访问。
			跳过列表外缓冲区。
			最后一个缓冲区 (或者出错的那个缓冲区) 成为当前缓冲区。
			{cmd} 可以包含 '|' 来连接多个命令。
			{cmd} 不能删除或添加缓冲区到缓冲区列表。
			备注: 此命令执行时，通过把 Syntax 加入 'eventignore'
			来屏蔽此自动命令事件。这样大大加快了每个缓冲区的编辑速
			度。
			{Vi 无此功能} {仅在编译时加入 |+listcmds| 特性才有效}
			也参见 |:tabdo|、|:argdo| 和 |:windo|。

+-*/+-*/bufexists f 检查缓冲区是否存在
bufexists({expr})					*bufexists()*
		返回数值，如果名为 {expr} 的缓冲区存在的话，返回非零。
		如果 {expr} 参数是数值，指定缓冲区号。
		如果 {expr} 参数是字符串，缓冲区的名字必须与其完全匹配。该名字
		可以是:
		- 相对于当前目录。
		- 完整路径。
		- 'buftype' 设为 "nofile" 的缓冲区名。
		- URL 名。
		列表外缓冲区也会被找到。
		注意 帮助文件在 |:buffers| 里列出的是它们的短名字。但
		bufexists() 需要它们的长名字才能找到它们。
		bufexists() 可能报告缓冲区存在，但要使其名字可用于 |:buffer|
		命令，可能需用到 |expand()|。尤其 MS-Windows 8.3 名字可能形
		如 "c:\DOCUME~1"。
		使用 "bufexists(0)" 可以测试是否存在轮换文件名。

							*buffer_exists()*
		已废弃的名字: buffer_exists()。


+-*/+-*/buffers c 列出缓冲区列表里的所有文件
:buffers[!]					*:buffers* *:ls*
:ls[!]		显示所有缓冲区。例如：

+-*/+-*/bufhidden o 缓冲区不再在窗口显示时的行为
						*'bufhidden'* *'bh'*
'bufhidden' 'bh'	字符串 (缺省: "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+quickfix| 特性才有效}
	本选项指定缓冲区不再出现于窗口时的行为:
	  <empty>	跟随全局 'hidden' 选项
	  hide		隐藏缓冲区 (不卸载)，即使没有置位 'hidden' 也如此
	  unload	卸载缓冲区，即使置位 'hidden' 或者使用 |:hide| 时也如
			此
	  delete	从缓冲区列表里删除缓冲区，即使置位 'hidden' 或者使用
			|:hide| 时也如此，类似于 |:bdelete|
	  wipe		从缓冲区列表里真正删除缓冲区，即使置位 'hidden' 或者使
			用 |:hide| 时也如此，类似于 |:bwipeout|

	小心: 使用 "unload"、"delete" 或 "wipe" 后，缓冲区的修改会丢失而且没有
	警告。
	本选项和 'buftype' 和 'swapfile' 一起使用，指定特殊的缓冲区的类型。见
	|special-buffers|。


+-*/+-*/buflisted f 检查缓冲区是否存在并在列表内
buflisted({expr})					*buflisted()*
		返回数值，如果名为 {expr} 的缓冲区在列表内的话 (置位了
		'buflisted' 选项)，返回非零。
		{expr} 参数用法同 |bufexists()|。


+-*/+-*/buflisted o 缓冲区是否显示在缓冲区列表中
			*'buflisted'* *'bl'* *'nobuflisted'* *'nobl'* *E85*
'buflisted' 'bl'	布尔型 (缺省: 打开)
			局部于缓冲区
			{Vi 无此功能}
	如果置位本选项，缓冲区在缓冲区列表里显示。如果复位，缓冲区不能用
	":bnext"、"ls"、Buffers 菜单等访问。
	Vim 为只用来记住文件名或位置标记的缓冲区复位本选项。Vim 在开始编辑缓冲
	区时置位本选项，但用 ":buffer" 移动到缓冲区时不会。


+-*/+-*/bufloaded f 检查缓冲区是否存在并已加载
bufloaded({expr})					*bufloaded()*
		返回数值，如果名为 {expr} 的缓冲区存在且已载入的话 (在窗口显
		示，或者至少被隐藏)，返回非零。
		{expr} 参数用法同 |bufexists()|。


+-*/+-*/bufname f 取得某缓冲区名
bufname({expr})						*bufname()*
		返回缓冲区的名字，如同 ":ls" 命令显示的那样。	
		如果 {expr} 参数是数值，指定缓冲区号。数值零代表当前窗口的轮换
		缓冲区。
		如果 {expr} 参数是字符串，它用作 |file-pattern| 来匹配缓冲区名
		字。这里总假设置位 'magic' 而 'cpoptions' 为空。如果有超过一个
		匹配，返回空字符串。
		"" 或 "%" 可用来指定当前缓冲区，"#" 指定轮换缓冲区。
		完整的匹配优先，如果没有，也接受在缓冲区名的开始，结束和中间的
		匹配。如果你只愿意接受完整的匹配，在模式的开始放上 "^"，在结尾
		放上 "$"。
		先查找列表内缓冲区。如果列出缓冲区有唯一的匹配，返回之。不然，
		再查找列表外的缓冲区。
		如果 {expr} 是字符串，但你想用作缓冲区号，给它加零可以强制转化
		为数值型: >
			:echo bufname("3" + 0)
<		如果缓冲区不存在，或者没有名字，返回空字符串。 >
	bufname("#")		轮换缓冲区名
	bufname(3)		缓冲区 3 的名字
	bufname("%")		当前缓冲区名
	bufname("file2")	匹配 "file2" 的缓冲区名。

							*bufnr()*
+-*/+-*/bufnr f 取得某缓冲区号
bufnr({expr} [, {create}])
		返回缓冲区的编号，如同 ":ls" 命令显示的那样。关于 {expr} 的使
		用，见上 |bufname()|。
		如果不存在符合的缓冲区，返回 -1。或者，如果提供了 {create} 参
		数而且非零，建立一个新的列表外缓冲区，并返回其编号。
		bufnr("$") 是最后一个缓冲区: >
	:let last_buffer = bufnr("$")
<		返回数值，即最大的已有的缓冲区的编号。注意 较小的编号不一定都
		对应存在的缓冲区，因为 ":bwipeout" 可能永久地删除了部分的缓冲
		区。用 bufexists() 可以测试缓冲区是否存在。
							*buffer_number()*
		已废弃的名字: buffer_number()。
							*last_buffer_nr()*
		bufnr("$") 已废弃的名字: last_buffer_nr()。


+-*/+-*/buftype o 缓冲区的特殊类型
						*'buftype'* *'bt'* *E382*
'buftype' 'bt'		字符串 (缺省: "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+quickfix| 特性才有效}
	本选项的值指定缓冲区的类型:
	  <empty>	普通缓冲区
	  nofile	和文件不相关且不会写回的缓冲区
	  nowrite	不会写回的缓冲区
	  acwrite	缓冲区总是用 BufWriteCmd 自动命令写回 {仅当编译时加入
	  		|+autocmd| 特性才有效}
	  quickfix	quickfix 缓冲区，包含错误列表 |:cwindow| 或位置列表
			|:lwindow|
	  help		帮助缓冲区 (你不应该手动设置本值)

	本选项和 'bufhidden' 和 'swapfile' 一起使用，指定特殊的缓冲区类型。见
	|special-buffers|。

	修改本选项要小心。它有很多副作用！

	"quickfix" 缓冲区只用于错误列表和位置列表。用 |:cwindow| 和 |:lwindow|
	命令设置本值，不要直接修改它。

	"nofile" 和 "nowrite" 缓冲区很类似:
	都是:		缓冲区不写回磁盘。":w" 不能工作 (":w filename" 仍然可
			以)。
	都是:		缓冲区永远不会认为是 |'modified'| (修改过的)。
			没有警告说改变会丢失，即使你退出 Vim 时也是如此。
	都是:		交换文件只有在使用超量内存时才会建立 (如果复位
			'swapfile'，无论如何也不会有交换文件)。
	只限 nofile:	缓冲区名是固定的，不被视为文件名来处理。|:cd| 命令也不
			会修改它。
							*E676*
	"acwrite" 隐含意味着缓冲区名和文件不相关，类似于 "nofile"，但它会被写
	回。所以，和 "nofile" 与 "nowrite" 不同，可以 ":w" 而且修改过的缓冲区
	没有保存不能被放弃。写入操作要有匹配的 |BufWriteCmd|、|FileWriteCmd|
	和 |FileAppendCmd| 自动命令。


+-*/+-*/bunload c 卸载指定的缓冲区
:[N]bun[load][!]				*:bun* *:bunload* *E515*
:bun[load][!] [N]
		卸载缓冲区 [N] (默认：当前缓冲区)。原来占用的内存将被释放。该
		缓冲区还保留在缓冲区列表里。
		如果缓冲区被改动过，那么该命令将失败，除非使用 [!]，但是这样所
		有的改动都会丢失。
		该缓冲区的所有窗口都会关闭。如果缓冲区 [N] 是当前的缓冲区，那
		么 Vim 会显示另一个缓冲区来代替。具体来说，Vim 会选择跳转表里
		最新且已经载入的缓冲区。

+-*/+-*/bwipeout c 真正删除一个缓冲区
:[N]bw[ipeout][!]			*:bw* *:bwipe* *:bwipeout* *E517*
:bw[ipeout][!] {bufname}
:N,Mbw[ipeout][!]
:bw[ipeout][!] N1 N2 ...
		类似 ":bdelete"，但真正删除缓冲区。所有和缓冲区相关的信息都丢
		失了。所有位置标记失效，选项丢失，诸如此类。除非你确切地知道自
		己正在做什么，否则不要使用这个命令。

+-*/+-*/checktime c 检查载入缓冲区的时间标签
							*:checkt* *:checktime*
:checkt[ime]		检查是否有缓冲区在 Vim 之外被改变。 该命令检查你是否有
			文件的两个版本并给出警告。
			如果它在自动命令、":global" 命令或者任何非键盘输入中调
			用，实际的检查会延迟，直到副作用 (重新读入文件) 不会有
			任何问题。
			每个已读入的缓冲区会检查相关的文件是否被改变。如果是，
			则 Vim 会采取行动。如果缓冲区没有修改过而且置位了
			'autoread'，缓冲区被重新读入。否则，你会被询问是否重新
			读入文件。如果文件被删除，你会得到一个错误信息。如果文
			件过去不存在但现在已经存在，你会得到一个警告。
			一旦检查过某个文件，他的修改时间被重置。因而，你不会被
			重复警告。

+-*/+-*/enew c 编辑新的无名缓冲区
							*:ene* *:enew*
:ene[w]			编辑一个新的无名缓冲区。如果当前缓冲区已被修改，这会失
			败，除非置位了 'hidden' 或者 'autowriteall' 并且文件能
			够写入。
			如果 'fileformats' 非空，其给出的第一个格式将用于新的
			缓冲区上。如果 'fileformats' 为空，则使用当前缓冲区的
			'fileformat'。
			{Vi 无此功能}

+-*/+-*/files c 列出缓冲区列表的所有文件
:files[!]					*:files*
:buffers[!]					*:buffers* *:ls*
:ls[!]		显示所有缓冲区。例如：

+-*/+-*/getbufline f 得到指定缓冲区的行列表
getbufline({expr}, {lnum} [, {end}])
		返回 {expr} 缓冲区的第 {lnum} 到 {end} (包含) 行的 |List|。如
		果省略 {end}，返回只有一行 {lnum} 的 |List|。

		关于 {expr} 的用法，见上 |bufname()|。

		{lnum} 和 {end} 可以使用 "$" 来表示缓冲区的最后一行。除此以
		外，必须用数值。

		如果 {lnum} 小于 1 或大于缓冲区的行数，返回空 |List|。

		如果 {end} 大于缓冲区的行数，就把它当成缓冲区的行数。如果
		{end} 在 {lnum} 之前，返回空 |List|。

		此函数只能用于已经载入的缓冲区。未载入或不存在的缓冲区总是返回
		空 |List|。

		例如: >
			:let lines = getbufline(bufnr("myfile"), 1, "$")


+-*/+-*/hidden o 当缓冲区被放弃 (|abandon|) 时不卸载之
				     *'hidden'* *'hid'* *'nohidden'* *'nohid'*
'hidden' 'hid'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果关闭，|abandon| 放弃时卸载缓冲区。如果打开，|abandon| 放弃时隐藏缓
	冲区。当然，如果缓冲区仍然在别的窗口里显示，它不会被隐藏。
	在缓冲区列表里移动的命令有时会隐藏缓冲区，即使关闭 'hidden' 选项也是如
	此，条件是: 缓冲区被修改过、'autowrite' 关闭或者不能写入、并且使用 '!'
	标志位。另见 |windows.txt|。
	如果只想隐藏一个缓冲区，使用 'bufhidden' 选项。
	":hide {command}" 为单个命令关闭本选项 |:hide|。
	警 告: 对隐藏缓冲区的修改很容易忘记。":q!" 或 ":qa!" 时三思而后行！


+-*/+-*/hide c 为一个命令隐藏当前缓冲区
							*:hide*
:hid[e]		除非是屏幕上的最后一个窗口，退出当前窗口，缓冲区被隐藏起来
		(除非还有另一个窗口正在编辑它，或者 'bufhidden' 设置为
		"unload" 或 "delete")。
		如果这是当前标签页的最后一个窗口，关闭此标签页。|tab-page|
		此命令不受 'hidden' 的值影响。
		对缓冲区的改动既不写入文件，也不会丢失，所以这是个 "安全" 的命
		令。

+-*/+-*/ls c 列出所有的缓冲区
:buffers[!]					*:buffers* *:ls*
:ls[!]		显示所有缓冲区。例如：

+-*/+-*/modifiable o 可否修改文本
				*'modifiable'* *'ma'* *'nomodifiable'* *'noma'*
'modifiable' 'ma'	布尔型	(缺省打开)
			局部于缓冲区
			{Vi 无此功能}		*E21*
	如果关闭，缓冲区的内容不能修改。'fileformat' 和 'fileencoding' 选项也
	不能修改。
	用 |-M| 命令行参数可以复位。


+-*/+-*/modified o 缓冲区已被修改
				*'modified'* *'mod'* *'nomodified'* *'nomod'*
'modified' 'mod'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
	如果打开，缓冲区被认为已修改。本选项在以下情形下被置位:
	1. 上次写入后，对文本进行修改。使用 |undo| 命令回到原始的文本就会复位
	   本选项。但撤销写回缓冲区之前的修改又会打开本选项，因为文本和写入时
	   已经不同。
	2. 'fileformat' 和 'fileencoding' 不同于原值。缓冲区读入或写回时设回原
	   值。":set nomodified" 命令则把 "原值" 设为当前值，并复位 'modified'
	   选项。
	'buftype' 为 "nowrite" 或 "nofile" 时，本选项也可置位，但会被忽略。


+-*/+-*/readonly o 禁止写入缓冲区
				   *'readonly'* *'ro'* *'noreadonly'* *'noro'*
'readonly' 'ro'		布尔型	(缺省关闭)
			局部于缓冲区
	如果打开，除非使用 '!'，不允许写入。它保护你不小心覆盖文件。如果 Vim
	以只读模式启动 ("vim -R") 或者可执行文件的名字叫 "view"，缺省打开。
	用 ":w!" 以后，复位当前缓冲区的 'readonly' 选项，除非 'cpoptions' 里包
	含 'Z' 标志位。
	{Vi 无此功能:} 如果使用 ":view" 命令，新编辑的缓冲区也置位 'readonly'
	选项。


+-*/+-*/sunhide c 等同于 "":unhide
:[N]unh[ide] [N]			*:unh* *:unhide* *:sun* *:sunhide*
:[N]sun[hide] [N]
		重新排列屏幕，给缓冲区列表中的每一个载入的缓冲区打开一个窗口。
		如果给出计数，则计数为打开窗口的最多数目。

+-*/+-*/tabpagebuflist f 得到标签页里的缓冲区列表
tabpagebuflist([{arg}])					*tabpagebuflist()*
		返回 |List|，每个项目是当前标签页里每个窗口相关联的缓冲区的编
		号。
		{arg} 指定使用的标签页的编号。如果省略，使用当前标签页。
		如果 {arg} 非法，返回数值零。
		要得到所有标签页里的所有缓冲区的列表，这样用: >
			tablist = []
			for i in range(tabpagenr('$'))
			   call extend(tablist, tabpagebuflist(i + 1))
			endfor
<		注意 缓冲区可能出现于多于一个窗口里。



+-*/+-*/tabpagenr f 得到标签页号
tabpagenr([{arg}])					*tabpagenr()*
		返回数值，当前标签页号。第一个标签页的编号为 1。
		如果可选参数为 "$"，返回最后一个标签页的编号 (即标签页总数)。
		该数值可用于 |:tab| 命令。



+-*/+-*/tabpagewinnr f 类似于特定标签页里的 winnr()
tabpagewinnr({tabarg}, [{arg}])				*tabpagewinnr()*
		类似于 |winnr()|，但使用标签页 {tabarg}。
		{tabarg} 指定要使用的标签页号。
		{arg} 的用法类似于 |winnr()|:
		- 如果省略，返回当前窗口号，也就是转到该标签页时会使用的窗口。
		- 如果是 "$"，返回窗口的总数。
		- 如果是 "#"，返回上次的窗口编号。
		用于的例子: >
		    tabpagewinnr(1)	    " 标签页 1 的当前窗口
		    tabpagewinnr(4, '$')    " 标签页 4 的窗口总数
<		如果 {tabarg} 非法，返回零。

							*tagfiles()*
+-*/+-*/undolevels o 最多可以撤销的改变个数
						*'undolevels'* *'ul'*
'undolevels' 'ul'	数值型	(缺省为 100，Unix、VMS、Win32 和 OS/2 为 1000)
			全局
			{Vi 无此功能}
	可以撤销的最大改变次数。因为撤销需要的信息保存在内存里，更大的数值导致
	更多的内存被消耗 (不过，单个改变本来就可能使用不受限制的内存)。
	设为 0 和 Vi 兼容: 一层撤销，而 "u" 可以撤销自身: >
		set ul=0
<	你可以用在 'cpoptions' 里加入 'u' 标志位得到 Vi 的兼容性，同时可以使用
	CTRL-R 来进行多次撤销。
	另见 |undo-two-ways|。
	设为负数完全关闭撤销功能: >
		set ul=-1
<	如果单个改变也能使你内存溢出，这会有帮助。
	另见 |clear-undo|。


+-*/+-*/undoreload o 保存缓冲区重载撤销的最大行数
						*'undoreload'* *'ur'*
'undoreload' 'ur'	数值型	(缺省 10000)
			全局
			{Vi 无此功能}
	重载缓冲区时为了可撤销，保存整个缓冲区。适用于 ":e!" 命令和在 Vim 之外
	改变缓冲区时的情况。|FileChangedShell|
	仅当本选项的值为负或行数小于此选项值时，进行保存。
	设置此选项为零关闭重载的撤销。

	为重载保存撤销时，不读入撤销文件。

	注意 这会导致整个缓冲区被保存到内存。如果发生了内存溢出，设置此选项为较
	小的值。


+-*/+-*/unhide c 为缓冲区列表里每个载入的文件打开窗口
:[N]unh[ide] [N]			*:unh* *:unhide* *:sun* *:sunhide*
:[N]sun[hide] [N]
		重新排列屏幕，给缓冲区列表中的每一个载入的缓冲区打开一个窗口。
		如果给出计数，则计数为打开窗口的最多数目。

+-*/+-*/switchbuf _ 切换缓冲区
+-*/+-*/+-*/bNext c 转到缓冲区列表里的上一个缓冲区
:[N]bN[ext][!] [N]		*:bN* *:bNext* *:bp* *:bprevious* *E88*
:[N]bp[revious][!] [N]
		至缓冲区列表往前第 [N] 个缓冲区。[N] 默认是 1。如果到了缓冲区
		列表的顶端，则从末尾往前循环。
		关于 [!] 参见 |:buffer-!| 和 'switchbuf'。

+-*/+-*/+-*/bfirst c 转到缓冲区列表里的第一个缓冲区
							*:bf* *:bfirst*
:bf[irst]	与 ":brewind" 相同。

+-*/+-*/+-*/blast c 转到缓冲区列表里的最后一个缓冲区
							*:bl* *:blast*
:bl[ast][!]	至缓冲区列表中的最后一个缓冲区。如果列表为空，则转到最后一个列
		表外缓冲区。
		对于 [!] 参见 |:buffer-!|

+-*/+-*/+-*/bmodified c 转到缓冲区列表里的下一个修改过的缓冲区
:[N]bm[odified][!] [N]				*:bm* *:bmodified* *E84*
		至往后第 [N] 个修改过的缓冲区。备注: 这一命令同样也能找到列表
		外缓冲区。如果没有修改的缓冲区，此命令失败。

+-*/+-*/+-*/bnext c 转到缓冲区列表里的下一个缓冲区
:[N]bn[ext][!] [N]					*:bn* *:bnext* *E87*
		至缓冲区列表里往后第 [N] 个缓冲区。[N] 默认是 1。如果到了缓冲
		区列表的末尾，则从头循环。
		关于 [!] 参见 |:buffer-!|。
		如果你在帮助缓冲区里，这条命令让你跳到后面的帮助缓冲区 (如果有
		的话)。同样，你在一个正常 (非帮助) 缓冲区里，就会使你跳到后面
		的正常缓冲区。这样是为了在打开帮助的时候不会影响到浏览正常的代
		码或文本。下面三个命令都是如此。

+-*/+-*/+-*/bprevious c 转到缓冲区列表里的上一个缓冲区
:[N]bN[ext][!] [N]		*:bN* *:bNext* *:bp* *:bprevious* *E88*
:[N]bp[revious][!] [N]
		至缓冲区列表往前第 [N] 个缓冲区。[N] 默认是 1。如果到了缓冲区
		列表的顶端，则从末尾往前循环。
		关于 [!] 参见 |:buffer-!| 和 'switchbuf'。

+-*/+-*/+-*/brewind c 转到缓冲区列表里的第一个缓冲区
							*:br* *:brewind*
:br[ewind][!]
		至缓冲区列表中的第一个缓冲区。如果列表为空，则转到第一个列表外
		缓冲区。
		对于 [!] 参见 |:buffer-!|

+-*/+-*/+-*/buffer c 转到缓冲区列表里的特定缓冲区
:[N]b[uffer][!] [N]			*:b* *:bu* *:buf* *:buffer* *E86*
		编辑缓冲区列表中第 [N] 个缓冲区，如果没指定 [N]，就编辑当前的
		缓冲区。关于 [!] 参见 |:buffer-!|。这个命令同样可以编辑不在列
		表里的缓冲区，'buflisted' 不会因而被置位。

+-*/+-*/+-*/switchbuf o 设置切换到别的缓冲区时的行为
						*'switchbuf'* *'swb'*
'switchbuf' 'swb'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	本选项控制缓冲区切换的行为。可能的值是 (逗号分隔的列表):
	   useopen	如果包含，跳到第一个打开的包含指定缓冲区的窗口 (如果有
			的话)。
			否则: 不检查其它窗口。
			|quickfix| 命令在跳转到错误时 (":cc"、":cn"、"cp"，等
			等) 检查此设置。所有缓冲区相关的分割命令也会，比如
			":sbuffer"、":sbnext" 或 ":sbrewind"。
	   usetab	类似于 "useopen"，但也考虑其它标签页里的窗口。
	   split	如果包含，在载入缓冲区之前分割当前窗口。不然: 不分割，
			使用当前窗口。在 |quickfix| 命令里用于显示错误。
	   newtab	类似于 "split"，但打开新标签页。如果和 "split" 同时存
			在，本值优先。


+-*/cmd _ 命令行
+-*/+-*/cedit o 打开命令行窗口的键
						*'cedit'*
'cedit'			字符串	(Vi 缺省: ""，Vim 缺省: CTRL-F)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+vertsplit| 特性才有效}
	用于命令行模式打开命令行窗口的键。
	'compatible' 关闭时，缺省值为 CTRL-F。
	只允许不可显示的键。
	该键可以用单个字符的形式指定，但不易输入，建议使用 <> 记法。例如: >
		:set cedit=<C-Y>
		:set cedit=<Esc>
<	|Nvi| 也有该选项，但只使用第一个字符。
	见 |cmdwin|。


+-*/+-*/cmdheight o 命令行使用的行数
						*'cmdheight'* *'ch'*
'cmdheight' 'ch'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
	命令行使用的屏幕行数。有助于避免 |hit-enter| 提示。
	此选项值保存在每个标签页里，从而每个标签页可有不同的值。


+-*/+-*/cmdwinheight o 命令行窗口的高度
						*'cmdwinheight'* *'cwh'*
'cmdwinheight' 'cwh'	数值型	(缺省为 7)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+vertsplit| 特性才有效}
	命令行窗口的屏幕行数。|cmdwin|


+-*/+-*/cmenu c 为命令行模式增加菜单
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/cnoremenu c 类似于 "":noremenu""，但用于命令行模式
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/comclear c 清除所有用户自定的命令
:comc[lear]						*:comc* *:comclear*
			删除所有用户定义命令。

+-*/+-*/command c 建立用户自定的命令
:com[mand][!] [{attr}...] {cmd} {rep}
			定义一个用户命令。命令的名字是 {cmd}，而替换的文本是
			{rep}。该命令的属性 (参考下面) 是 {attr}。如果该命令已
			存在，报错，除非已经指定了一个 !，这种情况下命令被重定
			义。

	-nargs=0    不允许有参数 (缺省情况)
	-nargs=1    要求一个参数
	-nargs=*    允许任何数目的参数 (0，1 或更多)
	-nargs=?    允许 0 或 1 个参数
	-nargs=+    必需给出参数，但是数目任意
	-range	    允许使用范围，缺省为当前行
	-range=%    允许使用范围，缺省是整个文件 (1,$)
	-range=N    出现在行号位置的一个数量 (缺省是 N) (类似于 |:split|)
	-count=N    出现在行号位置或者作为首个参数的一个数量 (缺省是 N) (类似
		    于 |:Next|)。
		    指定 -count (不设缺省值) 等价于 -count=0。
	-bang	    这些命令可以使用一个 ! 修饰符 (和 :q 或 :w 类似)
	-bar	    这些命令可以跟随一个 "|" 和其它命令。那么命令参数中就
		    不允许有 "|" 。用一个 " 可以开始一个注释。
	-register   给这些命令的第一个参数可以是一个可选的寄存器名
		    (和 :del，:put，:yank 类似)。
	-buffer	    这些命令仅在当前缓冲区里有效。
	-complete=augroup	自动命令组
	-complete=buffer	缓冲区名
	-complete=command	Ex 命令 (及其参数)
	-complete=dir		目录名
	-complete=environment	环境变量名
	-complete=event		自动命令事件
	-complete=expression	Vim 表达式
	-complete=file		文件和目录名
	-complete=filetype	文件类型名 |'filetype'|
	-complete=function	函数名
	-complete=help		帮助主题
	-complete=highlight	高亮组
	-complete=mapping	映射名
	-complete=menu		菜单
	-complete=option	选项
	-complete=shellcmd	外壳命令
	-complete=syntax	语法文件名 |'syntax'|
	-complete=tag		标签
	-complete=tag_listfiles	标签，但敲入 CTRL-D 时显示文件名
	-complete=var		用户变量
	-complete=custom,{func} 用户定制的自动补全，通过 {func} 来定义
	-complete=customlist,{func} 用户定制的自动补全，通过 {func} 来定义

注意 -range=N 和 -count=N 是互斥的，只应该指定其中的一个。

+-*/+-*/cunmenu c 删除命令行的菜单
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/delcommand c 删除用户自定的命令
:delc[ommand] {cmd}				*:delc* *:delcommand* *E184*
			删除用户定义命令 {cmd}。

+-*/+-*/exusage c Ex 命令总览
							*:exu* *:exusage*
:exu[sage]		显示 Ex 命令的帮助。目的是为了模拟对应的 Nvi 命令。
			{Vi 无此功能}

+-*/+-*/getcmdline f 得到当前命令行
getcmdline()						*getcmdline()*
		返回当前命令行。只有在编辑命令行时有效，所以必须在
		|c_CTRL-\_e| 或 |c_CTRL-R_=| 里使用。
		例如: >
			:cmap <F7> <C-\>eescape(getcmdline(), ' \')<CR>
<		另见 |getcmdtype()|、|getcmdpos()| 和 |setcmdpos()|。


+-*/+-*/getcmdpos f 得到命令行里的光标位置
getcmdpos()					*getcmdpos()*
		返回命令行的字节计算的光标位置。第一列为 1。
		只有在编辑命令行时有效，所以必须在 |c_CTRL-\_e| 或
		|c_CTRL-R_=| 里使用。不然，返回 0。
		另见 |getcmdtype()|、|setcmdpos()| 和 |getcmdline()|。


+-*/+-*/getcmdtype f 得到当前命令行的类型
getcmdtype()						*getcmdtype()*
		返回当前命令行类型。可能的返回值是:
		    :	普通 Ex 命令
		    >	调试模式命令 |debug-mode|
		    /	正向搜索命令
		    ?	反向搜索命令
		    @	|input()| 命令
		    -	|:insert| 或 |:append| 命令
		只能在编辑命令行时调用，因而必须在 |c_CTRL-\_e| 或
		|c_CTRL-R_=| 里使用。否则，返回空字符串。
		另见 |getcmdpos()|、|setcmdpos()| 和 |getcmdline()|。

							*getcwd()*
+-*/+-*/help c 打开帮助窗口
			*help* *<Help>* *:h* *:help* *<F1>* *i_<F1>* *i_<Help>*
<Help>		或	
:h[elp]			打开一个窗口并以只读方式显示帮助文件。如果已经打开了一
			个帮助窗口，就继续使用那个窗口。不然，如果当前窗口占据
			了屏幕的完整宽度或者至少有 80 个字符宽，帮助窗口会出现
			在当前窗口的正上方。再不然，新窗口就开在最上方。
			如果主帮助文件有多个语言版本，'helplang' 选项选择使用
			的语言。
			{Vi 无此功能}

+-*/+-*/helpfind c 打开显示帮助窗口的对话框
			*:helpfind* *:helpf*
:helpf[ind]		和 |:help| 类似，但用一个对话框来提示输入参数。
			这只是为了向后兼容的需要。它现在执行 ToolBar.FindHelp
			菜单项而不是内建的对话框。
			{仅当编译时加入 |+GUI_GTK| 特性才有效}
			{Vi 无此功能}

+-*/+-*/helpgrep c 类似于 "":grep""，但搜索帮助文件
							*:helpg* *:helpgrep*
:helpg[rep] {pattern}[@xx]
			搜索所有的帮助文本并给出一个匹配 {pattern} 行的列表。
			跳转到第一个匹配。
			可选的 [@xx] 指定只寻找 "xx" 语言里的匹配。
			你可以用 |quickfix| 命令来浏览其它的匹配。例如，
			|:cnext| 会跳到下一个。在 quickfix 窗口里，也可以用
			|:cwindow| 得到所有的匹配的列表。
			{pattern} 视为 Vim 的正规表达式 |pattern|。
			不使用 'ignorecase'，你可以加上 "\c" 来忽略大小写。
			大小写敏感的搜索示例: >
				:helpgrep Uganda
<			大小写不敏感的搜索示例: >
				:helpgrep uganda\c
<			寻找中文帮助的搜索: >
				:helpgrep backspace@cn
<			模式不支持换行符，必须在一行内匹配。为此，可用 |:grep|
			代替，但要得到帮助文件的列表就比较复杂了。
			后面不能跟其他的命令。其余部分都被当作模式的一部分。如
			果需要，可以用 |:execute|。
			不会在压缩的帮助文件里搜索 (Fedora 压缩帮助文件)。
			{Vi 无此功能}

+-*/+-*/histadd f 在历史记录中加入一项
histadd({history}, {item})				*histadd()*
		把字符串 {item} 加到历史 {history} 里。后者可以是:
							*hist-names*
			"cmd"	 或 ":"	  命令行历史
			"search" 或 "/"   搜索模式历史
			"expr"   或 "="   输入表达式历史
			"input"  或 "@"	  输入行历史
		如果 {item} 已经在历史里存在，它会被调整位置，从而成为最新的一
		项。
		返回结果为数值: 如果操作成功则为 1，不然返回 0。

		例如: >
			:call histadd("input", strftime("%Y %b %d"))
			:let date=input("Enter date: ")
<		该函数在沙盘里不可用 |sandbox|。


+-*/+-*/histdel f 从历史记录中删除一项
histdel({history} [, {item}])				*histdel()*
		清除 {history}，换而言之，删除它所有的项目。|hist-names| 解释
		{history} 的所有可能值。

		如果 {item} 计算结果为字符串，它被看作正规表达式。从历史里删除
		所有匹配该模式的项目 (如果有的话)。
		必须匹配大小写，除非使用 "\c" |/\c|。
		如果 {item} 的计算结果为数值，它被解释为索引值，见
		|:history-indexing|。如果该索引存在，删除相应的项目。

		返回结果为数值: 如果操作成功则为 1，不然返回 0。

		例如:
		清除表达式寄存器历史: >
			:call histdel("expr")
<
		删除所有 "*" 开始的搜索历史: >
			:call histdel("/", '^\*')
<
		下面三者是等价的: >
			:call histdel("search", histnr("search"))
			:call histdel("search", -1)
			:call histdel("search", '^'.histget("search", -1).'$')
<
		要删除最后的搜索模式，并在 "n" 命令和 'hlsearch' 里使用倒数第
		二个模式: >
			:call histdel("search", -1)
			:let @/ = histget("search", -1)


+-*/+-*/histget f 从历史记录中提取一项
histget({history} [, {index}])				*histget()*
		返回字符串，即 {history} 历史的第 {index} 项。|hist-names| 解
		释 {history} 的所有可能值，而 |:history-indexing| 解释
		{index}。如果没有这个项目，返回空字符串。如果忽略 {index}，返
		回历史里最近使用的项目。

		例如:
		重做历史里的倒数第二个搜索 >
			:execute '/' . histget("search", -2)

<		定义 Ex 命令 ":H {num}"，以重新执行 |:history| 输出的第 {num}
		项。 >
			:command -nargs=1 H execute histget("cmd", 0+<args>)
<

+-*/+-*/histnr f 取得某历史记录的最大索引号
histnr({history})					*histnr()*
		返回当前项目在 {history} 里的编号。|hist-names| 解释 {history}
		的所有可能值。
		如果有错，返回 -1。

		例如: >
			:let inp_index = histnr("expr")
<

+-*/+-*/history c 显示历史列表
							*:his* *:history*
:his[tory]	列出最近执行的命令。
		{Vi 无此功能}
		{仅当编译时加入 |+cmdline_hist| 特性才可用}

+-*/+-*/lhelpgrep c 类似于 "":helpgrep""，但使用位置列表
							*:lh* *:lhelpgrep*
:lh[elpgrep] {pattern}[@xx]
			类似于 ":helpgrep"，除了使用位置列表代替 quickfix 列表
			之外。如果帮助窗口已经打开，使用该窗口的位置列表。不
			然，打开新帮助窗口，并设置该窗口的位置列表。当前窗口的
			位置列表不改变。

+-*/+-*/list c 显示行
							*:l* *:list*
:[range]l[ist] [count] [flags]
			和 :print 相同，但是不可显示字符用 '^' 代替，行尾加上
			$。这可用 'listchars' 选项改变。
			|ex-flags| 说明 [flags]。

+-*/+-*/messages c 显示以前显示的消息
1. 以前的消息			*:messages* *:mes* *message-history*

+-*/+-*/more o 全屏显示时暂停列表
						*'more'* *'nomore'*
'more'			布尔型	(Vim 缺省: 打开，Vi 缺省: 关闭)
			全局
			{Vi 无此功能}
	如果打开，列表在全屏填满时暂停，并得到 |more-prompt|。如果此选项关闭就
	不会有暂停，列表会继续进行直到结束为止。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/print c 显示行
						*:p* *:pr* *:print* *E749*
:[range]p[rint][flags]
			显示 [range] 范围里的行 (缺省是当前行)。
			注意: 如果你要打印你的文本到纸张上，见 |:hardcopy|。
			GUI 上可以使用 File.Print 菜单项。
			|ex-flags| 说明 [flags]。

+-*/+-*/prompt o 提示符号
						*'prompt'* *'noprompt'*
'prompt'		布尔型	(缺省打开)
			全局
	如果打开，Ex 模式使用 ":" 提示。


+-*/+-*/setcmdpos f 设置命令行里的光标位置
setcmdpos({pos})					*setcmdpos()*
		设置命令行的光标位置到字节位置 {pos}。第一个位置为 1。
		用 |getcmdpos()| 得到当前的位置。
		只有在编辑命令行时有效，所以必须在 |c_CTRL-\_e|、|c_CTRL-R_=|
		或带 '=' 的 |c_CTRL-R_CTRL-R| 里使用。对于 |c_CTRL-\_e| 和带
		'=' 的 |c_CTRL-R_CTRL-R|，在命令行设为表达式的内容之后才设置位
		置。对于 |c_CTRL-R_=|，在计算表达式之后但在插入返回的文本之前
		设置位置。
		如果数值太大，光标放在行尾。如果小于 1，结果没有定义。
		如果成功，返回 0，如果不在编辑命令行，返回 1。


+-*/+-*/viusage c 普通模式命令的总览
							*:viu* *:viusage*
:viu[sage]		显示普通命令的帮助。目的是为了模拟对应的 Nvi 命令。
			{Vi 无此功能}

+-*/+-*/wildchar o 用于通配符扩展的命令行字符
						*'wildchar'* *'wc'*
'wildchar' 'wc'		数值型	(Vim 缺省: <Tab>，Vi 缺省: CTRL-E)
			全局
			{Vi 无此功能}
	在命令行上，用于启动通配符扩展的输入字符。其方式由 'wildmode' 指定。
	详情可见: |cmdline-completion|。
	不在宏里识别该字符。为此，见 'wildcharm'。
	尽管 'wc' 是一个数值选项，你可以设置它为一个特殊键: >
		:set wc=<Esc>
<	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/wildcharm o 同 'wildchar'，但对映射情况也适用
						*'wildcharm'* *'wcm'*
'wildcharm' 'wcm'	数值型	(缺省: 无 (0))
			全局
			{Vi 无此功能}
	'wildcharm' 和 'wildchar' 完全类似，除了在宏内识别该字符以外。
	|ex-edit-index| 里可以找到命令行上 "空余" 的键用于此选项。通常你不会直
	接输入 'wildcharm'，而只是在映射里用它来自动启动补全模式，例如: >
		:set wcm=<C-Z>
		:cnoremap ss so $vim/sessions/*.vim<C-Z>
<	这样，输入 :ss 以后，你可以使用 CTRL-P 和 CTRL-N。


+-*/+-*/wildmenu o 命令行自动补全所使用的菜单
				*'wildmenu'* *'wmnu'* *'nowildmenu'* *'nowmnu'*
'wildmenu' 'wmnu'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+wildmenu| 特性才有效}
	'wildmenu' 打开时，命令行补全以增强模式运行。按下 'wildchar' (通常是
	<Tab>) 启动补全。这时，在命令行的上方显示可能的匹配，然后高亮首个匹配
	(如果有状态行，覆盖之)。显示前项/后项匹配的热键，如 <Tab> 或
	CTRL-P/CTRL-N，移动高亮到合适的匹配上。
	使用 'wildmode' 时，指定 "full" 会启用 "wildmenu" 模式。"longest" 和
	"list" 则不会启动 "wildmenu" 模式。
	如果多个匹配超过一行，在右侧显示 ">" 和/或在左侧显示 "<"。需要的话，滚
	动状态行。
	按下不用于选择补全项的键时，放弃 "wildmenu" 模式。
	"wildmenu" 激活时，下面的键有特殊含义:

	<Left> <Right>	- 选择前项/后项匹配 (类似于 CTRL-P/CTRL-N)
	<Down>		- 文件名/菜单名补全中: 移进子目录和子菜单。
	<CR>		- 菜单补全中，如果光标在句号之后: 移进子菜单。
	<Up>		- 文件名/菜单名补全中: 上移到父目录或父菜单。

	这使得控制台上有菜单可用 |console-menus|。

	如果你喜欢 <Left> 和 <Right> 键移动光标而不是选择不同的匹配，用: >
		:cnoremap <Left> <Space><BS><Left>
		:cnoremap <Right> <Space><BS><Right>
<
	"WildMenu" 高亮用于显示当前匹配 |hl-WildMenu|。


+-*/+-*/wildmode o 'wildchar' 命令行扩展所用的模式
						*'wildmode'* *'wim'*
'wildmode' 'wim'	字符串	(Vim 缺省: "full")
			全局
			{Vi 无此功能}
	用 'widechar' 指定的字符所用的补全模式。它是逗号分隔的不超过四部分的列
	表。每个部分指定每次连续使用的 'widechar' 要完成的动作。第一部分指定第
	一次使用时的行为。第二部分指定第二次使用时的，等等。
	每个部分的可能值如下:
	""		只用第一个匹配补全。
	"full"		用下一个完整的匹配补全。在最后一次匹配之后，使用原来的
			字符串，然后又是第一个匹配。
	"longest"	用最长的公共子串补全。如果结果没有变长，使用下一个部
			分。
	"longest:full"	类似于 "longest"，但如果 'wildmenu' 打开的话，使用之。
	"list"		如果有多于一个补全，列出所有的匹配。
	"list:full"	如果有多于一个补全，列出所有的匹配并先用第一个补全。
	"list:longest"	如果有多于一个补全，列出所有的匹配并先用最长的子串补
			全。
	如果只有一个匹配，所有情况下都完整补全。

	例如: >
		:set wildmode=full
<	用第一个完整的匹配补全，然后下一个匹配，依此类推 (缺省) >
		:set wildmode=longest,full
<	用最长的子串补全，然后是每个完整的匹配 >
		:set wildmode=list:full
<	列出所有的匹配并用每个完整的匹配补全 >
		:set wildmode=list,full
<	列出所有的匹配而不补全，然后是每个完整的匹配 >
		:set wildmode=longest,list
<	用最长的子串补全，然后列出所有的可能性。
	详情可见: |cmdline-completion|。


+-*/+-*/wildoptions o 指定如何完成命令行补全
						*'wildoptions'* *'wop'*
'wildoptions' 'wop'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+wildignore| 特性才有效}
	单词列表，改变命令行补全的行为。
	目前只有一个可以使用的单词:
	  tagfile	如果用 CTRL-D 列出匹配的标签，列出标签的类型和文件。每
			行只显示一个匹配。常用的标签类型是:
				d	#define
				f	函数
	另见 |cmdline-completion|。


+-*/+-*/reg _ 寄存器
+-*/+-*/+-*/clipboard o 使用剪贴板作为无名的寄存器
						*'clipboard'* *'cb'*
'clipboard' 'cb'	字符串	(X-windows 的缺省为
					"autoselect,exclude:cons\|linux"，
				其它为 "")
			全局
			{Vi 无此功能}
			{仅有在 GUI 版本或者包含 |+xterm_clipboard| 特性时才有
			效}
	该选项是逗号分隔的名字列表。
	识别以下名字:

	unnamed		如果包含，Vim 使用剪贴板寄存器 '*' 来执行所有的抽出、
			删除、修改和放置操作，而不是通常使用的无名寄存器。除非
			显式指定了寄存器，这时不管 'clipboard' 是不是包含
			"unnamed" 都使用指定的寄存器。剪贴板寄存器总是可以显式
			地用 "* 记法来访问。另见 |gui-clipboard|。

	autoselect	和 'guioptions' 的 'a' 标志位工作方法类似: 如果存在，
			无论什么时候启动可视模式或者可视区域扩展，Vim 都试图成
			为窗口系统全局选择区的拥有者，或者把选择的文本放置到选
			择区寄存器 "* 使用的剪贴板上。详见 |guioptions_a| 和
			|quotestar|。如果激活 GUI，使用 'guioptions' 的 'a' 标
			志位。如果没有激活 GUI，使用本 "autoselect" 标志位。
			也适用于无模式的选择。

	autoselectml	类似于 "autoselect"，但只适用于无模式的选择。可以和
			'guioptions' 的 'A' 标志位相比拟。

	html		当剪贴板包含 HTML 时，粘贴时使用 HTML 格式。放置文本到
			剪贴板时，标识为 HTML。可用于从 Firefox 复制 HTML 内容
			并粘贴原始 HTML 码到 Vim，或从 Vim 选择 HTML 码，然后
			粘贴到 Firefox 的富文本编辑框 (rich edit)。
			你可能只想暂时包含本选项，例如通过 BufEnter 自动命令。
			只支持 GTK 版本 2 或以上。
			只有在编译时带 |+multi_byte| 特性才可用。

	exclude:{pattern}
			定义用来匹配终端名 'term' 的模式。匹配的终端不连接到 X
			服务器。可用于以下这种情形:
			- 在控制台上运行 Vim，
			- $DISPLAY 的设置使得应用程序在另一个显示上打开，
			- 不希望在控制台上连接到 X 服务器，但希望在终端模拟器
			  上如此。
			如果永远不想连接到 X 服务器，使用: >
				exclude:.*
<			这和 |-X| 参数的效果相同。
			注意 如果没有到 X 服务器的连接，窗口标题不会复原，而剪
			贴板也无法访问。
			忽略 'magic' 的值，{pattern} 的解释总是假定 'magic' 打
			开。
			选项值的其余部分用于 {pattern}，本项目必须是最后一个项
			目。


+-*/+-*/+-*/display c 显示寄存器
							*:di* *:display*
:di[splay] [arg]	和 :registers 相同。{Vi 无此功能}

+-*/+-*/+-*/getreg f 取得寄存器内容
getreg([{regname} [, 1]])				*getreg()*
		返回字符串，寄存器 {regname} 的内容。例如: >
			:let cliptext = getreg('*')
<		getreg('=') 返回最近一次表达式寄存器计算的返回值 (用于映射)。
		getreg('=', 1) 返回表达式自身，以便用 |setreg()| 恢复。对于其
		它寄存器，这个额外的参数被忽略，所以给出此参数总是无妨。
		如果没有指定 {regname}，使用 |v:register|。



+-*/+-*/+-*/getregtype f 取得寄存器类型
getregtype([{regname}])					*getregtype()*
		返回字符串，寄存器 {regname} 的类型。
		该值会是以下可能之一:
		    "v"			|characterwise| (面向字符) 的文本
		    "V"			|linewise| (面向行) 的文本
		    "<CTRL-V>{width}"	|blockwise-visual| (面向列块) 的文本
		    0			空或者未知的寄存器
		<CTRL-V> 是一个字符，其值为 0x16。
		如果没有指定 {regname}，使用 |v:register|。


+-*/+-*/+-*/put c 插入寄存器的内容到文本
							*:pu* *:put*
:[line]pu[t] [x]	放置文本 [从寄存器 x] 在行号 [line] (缺省为当前行) 之
			后。它总是 |linewise| 行动作，因而这个命令可以用来把抽
			出的块放置在新行上。
			光标停留在新行末行的第一个非空白处。
			寄存器也可以是 '='，跟随一个可选的表达式。表达式继续到
			该命令结束为止。你需要在 '|' 和 '"' 字符前加上反斜杠不
			让它们终止你的命令行。例如: >
				:put ='path' . \",/test\"
<			如果 '=' 之后没有表达式，Vim 使用前一个表达式。用
			":dis =" 你可以看到它。

+-*/+-*/+-*/registers c 显示寄存器的内容
							*:reg* *:registers*
:reg[isters]		显示所有编号和命名寄存器的内容。但不列出用于 |:redir| 
			目的地的寄存器。
			{Vi 无此功能}

+-*/+-*/+-*/setreg f 设定寄存器内容及类型
setreg({regname}, {value} [,{options}])
		设置寄存器 {regname} 的值为 {value}。
		如果 {options} 包含 "a" 或者 {regname} 为大写，该值被附加于现
		有值之后。
		{options} 还可以指定寄存器新类型的规格:
		    "c" 或 "v"	      |characterwise| (面向字符) 模式
		    "l" 或 "V"	      |linewise| (面向行) 模式
		    "b" 或 "<CTRL-V>" |blockwise-visual| (面向列块) 模式
		如果 "b" 或 "<CTRL-V>" 之后紧跟数值，那么该数值用作选择的宽度
		- 如果没有指定，那么列块的宽度设为最长的行字符数 (把 <Tab>
		看作一个字符)。

		如果 {options} 没有寄存器的设置，那么缺省使用面向字符模式，除
		非 {value} 以 <NL> 结尾。
		不能设置 '=' 寄存器。
		返回零代表成功，非零代表失败。

		示例: >
			:call setreg(v:register, @*)
			:call setreg('*', @%, 'ac')
			:call setreg('a', "1\n2\n3", 'b5')

<		本例说明如何使用函数来保存和恢复寄存器 >
			:let var_a = getreg('a'， 1)
			:let var_amode = getregtype('a')
			    ....
			:call setreg('a', var_a, var_amode)

<		你可以通过附加空串来改变寄存器的类型: >
			:call setreg('a', '', 'al')


+-*/+-*/+-*/yank c 抽出行到寄存器
							*:y* *:yank*
:[range]y[ank] [x]	抽出 [range] 所指定的行 [到寄存器 x]。

+-*/complete _ 补全
+-*/+-*/complete f 设定要寻找的匹配
complete({startcol}, {matches})			*complete()* *E785*
		设置插入模式补全的匹配。
		只能用于插入模式。需要使用 CTRL-R = 的映射 |i_CTRL-R|。不能在
		CTRL-O 之后或者在表达式映射里使用。
		{startcol} 是行内待补全文本开始的字节偏移。直到光标为止的文本
		就是原始的文本，它将要被匹配所替代。用 col('.') 会得到空串。而
		"col('.') - 1" 将用匹配替换单个字符。
		{matches} 必须是 |List|。每个 |List| 项目是一个匹配。
		|complete-items| 说明可能的项目类型。
		注意 调用此函数后，你不应插入任何使补全停止的内容。
		用 CTRL-N 和 CTRL-P 选择匹配，就像普通的插入模式补全那样。如果
		指定，会出现弹出菜单，见 |ins-completion-menu|。
		示例: >
	inoremap <F5> <C-R>=ListMonths()<CR>

	func! ListMonths()
	  call complete(col('.'), ['January', 'February', 'March',
		\ 'April', 'May', 'June', 'July', 'August', 'September',
		\ 'October', 'November', 'December'])
	  return ''
	endfunc
<		此例并不很有用，但可以说明功能。注意这里返回空串，以免插入零。


+-*/+-*/complete o 指定插入模式的自动补全如何工作
						*'complete'* *'cpt'* *E535*
'complete' 'cpt'	字符串	(缺省: ".,w,b,u,t,i")
			局部于缓冲区
			{Vi 无此功能}
	本选项控制关键字补全 |ins-completion| 在使用 CTRL-P 或 CTRL-N 时如何工
	作，也用于整行的补全 |i_CTRL-X_CTRL-L|。它指示补全的类型和需要扫描的位
	置。这是一个逗号分隔的标志位的列表:
	.	扫描当前缓冲区 (忽略 'wrapscan')
	w	扫描其它窗口的缓冲区
	b	扫描其它缓冲区列表里载入的缓冲区
	u	扫描缓冲区列表里卸载的缓冲区
	U	扫描不在缓冲区列表里的缓冲区
	k	扫描 'dictionary' 选项给出的文件
	kspell  使用当前激活的拼写检查 |spell|
	k{dict}	扫描文件 {dict}。可以给出多个 "k" 标志位，也可以使用模式。比
		如: >
			:set cpt=k/usr/dict/*,k~/spanish
<	s	扫描 'thesaurus' 选项给出的文件
	s{tsr}	扫描文件 {tsr}。可以给出多个 "s" 标志位，也可以使用模式。
	i	扫描当前文件和包含的头文件
	d	扫描当前文件和包含的头文件里的定义名或宏 |i_CTRL-X_CTRL-D|
	]	标签补全
	t	等同于 "]"

	卸载的缓冲区不会载入，因而它们的自动命令 |:autocmd| 也不会执行，这使得
	有些文件的补全效果出人意表 (比如 gzipped 压缩的文件)。整行补全也不会扫
	描卸载的缓冲区。

	缺省是 ".,w,b,u,t,i"，它意味着扫描:
	   1. 当前缓冲区
	   2. 其它窗口的缓冲区
	   3. 其它载入的缓冲区
	   4. 卸载的缓冲区
	   5. 标签
	   6. 头文件

	如你所知，CTRL-N 和 CTRL-P 可用于完成任何基于 'iskeyword' 的扩展 (比如
	字典 |i_CTRL-X_CTRL-K|、头文件里的模式 |i_CTRL-X_CTRL-I|、标签
	|i_CTRL-X_CTRL-]| 和普通的扩展)。


+-*/+-*/complete_add f 加入要寻找的匹配
complete_add({expr})				*complete_add()*
		把 {expr} 加到匹配的列表里。只能用于 'completefunc' 选项指定的
		函数里。
		返回 0 代表失败 (空字符串或者内存不足)，1 代表加入了匹配，2 代
		表匹配已经在列表里。
		|complete-functions| 解释 {expr}。它和 'omnifunc' 应该返回的列
		表中单个项目相同。


+-*/+-*/complete_check f 检查补全是否被中止
complete_check()				*complete_check()*
		寻找补全匹配时，检查输入的键。如果寻找匹配需要一定时间时有用。
		如果匹配的搜索被中止，返回非零。否则返回零。
		只能用于 'completefunc' 选项指定的函数里。

						*confirm()*
+-*/+-*/completefunc o 插入模式补全使用的函数
						*'completefunc'* *'cfu'*
'completefunc' 'cfu'	字符串	(缺省: empty)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+eval| 和 |+insert_expand| 特性才有效}
	本选项指定插入模式补全 CTRL-X CTRL-U 使用的函数。|i_CTRL-X_CTRL-U|
	|complete-functions| 解释如何调用该函数以及它应该返回何值。



+-*/+-*/completeopt o 插入模式补全使用的选项
						*'completeopt'* *'cot'*
'completeopt' 'cot'	字符串	(缺省: "menu,preview")
			全局
			{仅当编译时加入 |+insert_expand| 特性才有效}
			{Vi 无此功能}
	逗号分隔的选项列表，用于插入模式的补全 |ins-completion|。支持的值是:

	   menu	    使用弹出菜单来显示可能的补全。只有匹配多于一个且有足够的颜
		    色时才显示该菜单。|ins-completion-menu|

	   menuone  即使只有一个匹配，也使用弹出菜单。可用于匹配有附加信息的情
		    况，例如，它来自的文件。

	   longest  只插入匹配的最长公共文本。如果显示菜单，用 CTRL-L 来插入更
		    多的字符。是否忽略大小写取决于补全的类型。缓冲区文本使用
		    'ignorecase' 选项。

	   preview  在预览窗口里显示当前选择的补全的额外信息。只能和 "menu" 或
		    "menuone" 搭配使用。


+-*/+-*/dictionary o 关键字自动补全所用的文件名
						*'dictionary'* *'dict'*
'dictionary' 'dict'	字符串	(缺省为 "")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	逗号分隔的文件名列表，用于为关键字补全命令查找单词 |i_CTRL-X_CTRL-K|。
	每个文件由单词的列表构成，可以每行一个单词，也可以每行多个，以非关键字
	字符分隔 (建议使用空白)。最大的行长为 510 个字节。
	如果此选项为空或者给出项目 "spell" 并且打开拼写检查，使用当前激活的拼
	写。|spell|
	要在文件名里包含逗号，在它之前加上反斜杠。逗号之后的空格被忽略，其它情
	况下空格视为文件的一部分。|option-backslash| 说明如何使用反斜杠。
	这和 |Dictionary| 变量类型完全无关。
	什么地方可以找到单词列表呢？
	- FreeBSD 上，有文件 "/usr/share/dict/words"。
	- Simtel 归档里，在 "msdos/linguist" 目录里找找。
	- GNU 工具集里的 "miscfiles"。
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减目录。这可以避免未来版本使
	用其它缺省值出现的问题。
	为了安全原因，反引号不能用于此选项里。


+-*/+-*/infercase o 关键字自动补全的匹配调整大小写
			*'infercase'* *'inf'* *'noinfercase'* *'noinf'*
'infercase' 'inf'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
	插入模式里补全关键字时 |ins-completion|，如果同时打开 'ignorecase'，匹
	配的大小写会根据输入进行调整。如果输入的文本包含小写字母而在那里匹配串
	是大写字母，补全部分被换成小写。如果输入文本没有小写字母，而且某个字母
	之后有大写字母而在那里匹配串是小写字母，补全部分被换成大写。
	如用 'noinfercase'，照原样给出匹配。


+-*/+-*/isfname o 文件和路径名可用的字符
						*'isfname'* *'isf'*
'isfname' 'isf'		字符串	(MS-DOS、Win32 和 OS/2 缺省为:
			     "@,48-57,/,\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,="
			    AMIGA: "@,48-57,/,.,-,_,+,,,$,:"
			    VMS: "@,48-57,/,.,-,_,+,,,#,$,%,<,>,[,],:,;,~"
			    OS/390: "@,240-249,/,.,-,_,+,,,#,$,%,~,="
			    否则: "@,48-57,/,.,-,_,+,,,#,$,%,~,=")
			全局
			{Vi 无此功能}
	文件名和路径名由此选项指定的字符组成。使用文件名的命令包括 "gf"，"[i"
	还有在标签文件里的那些。它也用于 |pattern| 里的 "\f"。
	多字节字符，即 256 及更高的字符，总是包含在内，只有 255 以内的字符需要
	在此选项里指定。
	对于 UTF-8 而言，也会包含 0xa0 到 0xff 的字符。
	给此选项加入空白字符时要三思而行。虽然空格可以出现在文件名中，这么做的
	后果使得 Vim 在补全时无法知道文件名何处开始，何处结束。'isfname' 没有
	空白字符也许更好些。

	注意 在使用反斜杠作为路径分隔符的系统上，Vim 竭尽所能使得它如你期望的
	那样工作。但需要点技巧，因为 Vi 原来使用反斜杠来转义特殊字符。在这些系
	统上，Vim 不会删除普通文件名字符之前的反斜杠，但在 Unix 和类似的系统上
	会。缺省不包含 '&' 和 '^'，因为它们对 cmd.exe 有特殊意义。

	该选项的格式为逗号分隔的部分的列表。每个部分是单个字符数值或者一个范
	围。范围包括两个字符数值，中间以 '-' 相连。字符数值可以是一个 0 到 255
	的十进制数，或者是 ASCII 字符自身 (不包括数字字符)。例如:
		"_,-,128-140,#-43"	(包含 '_' 和 '-' 和 128 到 140 和 '#'
					到 43)
	如果一个部分以 '^' 开始，则后面的字符数值或范围从选项里被排除。选项
	的解释从左到右。排除的字符应放在包含该字符的范围之后。要包含 '^' 自
	身，让它成为选项的最后一个字符，或者成为范围的结尾。比如:
		"^a-z,#,^"	(不包括 'a' 到 'z'，包括 '#' 和 '^')
	如果字符是 '@'，所有 isalpha() 为真的字符都包含在内。通常这包括 a 到 z
	和 A 到 Z，加上它们带重音的变形。要包含 '@' 自身，使用 "@-@"。例如:
		"@,^a-z"	所有除了小写 ASCII 字母以外的字母表字符。
		"a-z,A-Z,@-@"	所有字母加上 '@' 字符。
	要包含逗号，在期待使用字符数字的地方使用它。比如:
		"48-57,,,_"	数字、逗号和下划线。
	逗号可以在它之前加 '^' 来排除。比如:
		" -~,^,,9"	从空格到 '~' 的所有字符，排除逗号，加上 <Tab>。
	|option-backslash| 说明如何包含空格和反斜杠。


+-*/+-*/isident o 标识符可用的字符
						*'isident'* *'isi'*
'isident' 'isi'		字符串	(MS-DOS、Win32 和 OS/2 缺省为:
					   "@,48-57,_,128-167,224-235"
				否则: "@,48-57,_,192-255")
			全局
			{Vi 无此功能}
	标识符由此选项给出的字符组成。标识符用于识别环境变量和 'define' 选项匹
	配之后的名字，也用于 |pattern| 里的 "\i"。'isfname' 描述本选项的格式。
	小心: 如果改变此选项，环境变量的扩展可能会失败。例如，如果包含 '/'，
	Vim 会试图扩展 "$HOME/.viminfo"。也许你想改变的是 'iskeyword'。


+-*/+-*/iskeyword o 关键字可用的字符
						*'iskeyword'* *'isk'*
'iskeyword' 'isk'	字符串 (Vim MS-DOS 和 Win32 缺省:
					 "@,48-57,_,128-167,224-235"
				   其它: "@,48-57,_,192-255"
				Vi 缺省: "@,48-57,_")
			局部于缓冲区
			{Vi 无此功能}
	搜索和许多命令识别关键字: "w"、"*"、"[i" 等等。它也用于 |pattern| 里的
	"\k"。'isfname' 描述本选项的格式。对于 C 程序来说，你应该使用
	"a-z,A-Z,48-57,_,.,-,>"。
	对帮助文件，它设置为除了 '*'、'"' 和 '|' 以外所有非空白的可显示字符
	(这样在命令上使用 CTRL-] 可以找到该命令的帮助)。
	如果打开 'lisp' 选项，总是包含 '-' 字符。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/omnifunc o 文件类型特定补全使用的函数
						*'omnifunc'* *'ofu'*
'omnifunc' 'ofu'	字符串	(缺省: 空)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+eval| 和 |+insert_expand| 特性才有效}
	指定插入模式用 CTRL-X CTRL-O 进行全能 (omni) 补全使用的函数
	|i_CTRL-X_CTRL-O|。
	|complete-functions| 解释如何调用该函数以及它应该返回何值。
	该选项通常在文件类型插件里设置: |:filetype-plugin-on|



+-*/+-*/pumheight o 弹出窗口的最大高度
						*'pumheight'* *'ph'*
'pumheight' 'ph'	数值型	(缺省为 0)
			全局
			{仅当编译时加入 |+insert+expand| 特性才有效}
			{Vi 无此功能}
	决定用于插入模式补全的弹出菜单显示项目的最大数目。如果为零，有多少空间
	就用多少。
	|ins-completion-menu|。



+-*/+-*/pumvisible f 检查弹出菜单是否显示
pumvisible()						*pumvisible()*
		如果弹出菜单可见，返回非零，不然返回零。见
		|ins-completion-menu|。
		可以用来避免一些会删除弹出菜单的动作。

							*E726* *E727*

+-*/+-*/showfulltag o 自动补全标签时显示完整的标签匹配模式
			*'showfulltag'* *'sft'* *'noshowfulltag'* *'nosft'*
'showfulltag' 'sft'	布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
	插入模式里，用标签文件补全单词时 (见 |ins-completion|)，同时显示标签名
	和查找模式 (如果有的话) 的整齐格式作为可能的匹配。这样，如果匹配 C 函
	数，你会看到一个样板，从中了解到需要什么样的参数 (允许指定编码风格)。
	注意 如果 'completeopt' 有 "longest"，这不会很好地工作，因为搜索模式的
	补全未必会匹配输入的文本。


+-*/+-*/suffixes o 多个匹配所忽略的后缀
						*'suffixes'* *'su'*
'suffixes' 'su'		字符串	(缺省为 ".bak,~,.o,.h,.info,.swp,.obj")
			全局
			{Vi 无此功能}
	带这些后缀名的文件在通配符能匹配多个文件时使用较低的优先级。见
	|suffixes|。可以用逗号分隔这些后缀，逗号之后的空格被忽略。句号也被看
	作是后缀的开始。要避免句号或逗号被识别为分隔符，在它们之前加上反斜杠
	(|option-backslash| 说明如何包含空格和反斜杠)。
	'wildignore' 说明如何完全忽略某些文件。
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减后缀。这可以避免未来版本使
	用其它缺省值出现的问题。


+-*/+-*/thesaurus o 关键字自动补全所用的同义词字典
						*'thesaurus'* *'tsr'*
'thesaurus' 'tsr'	字符串	(缺省为 "")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	逗号分隔的文件名列表，用于为同义词补全命令查找单词 |i_CTRL-X_CTRL-K|。
	文件里的每行应该包含相近意思的单词，以非关键字字符分隔 (建议使用空
	白)。最大的行长为 510 个字节。
	要得到能用于此处的文件，查阅 http://www.hyphenologist.co.uk 的
	wordlist FAQ。
	要在文件名里包含逗号，在它之前加上反斜杠。逗号之后的空格被忽略，其它情
	况下空格视为文件的一部分。|option-backslash| 说明如何使用反斜杠。
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减目录。这可以避免未来版本使
	用其它缺省值出现的问题。
	为了安全原因，反引号不能用于此选项里。


+-*/+-*/wildignore o 匹配这些模式的文件不会参与自动补全
						*'wildignore'* *'wig'*
'wildignore' 'wig'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+wildignore| 特性才有效}
	文件模式的列表。文件和目录名的补全中忽略符合其中任何模式的文件，它也同
	时影响 |expand()|、|glob()| 和 |globpath()|，除非指定标志位来关闭之。
	这些模式的应用方式类似于 |:autocmd|，见 |autocmd-patterns|。
	另见 'suffixes'。
	例如: >
		:set wildignore=*.o,*.obj
<	建议使用 |:set+=| 和 |:set-=| 来从列表里加减模式。这可以避免未来版本使
	用其它缺省值出现的问题。


+-*/cscope _
+-*/+-*/cscope c 执行 cscope 命令
		*:cscope* *:cs* *:scs* *:scscope* *E259* *E262* *E561* *E560*
所有命令都是通过主命令 ":cscope" 的子项完成的。主命令最短的缩写是 ":cs"。
":scscope" 完成同样的功能的同时还可以分割窗口 (缩写: "scs")。

+-*/+-*/cscope_connection f 检查有无与 cscope 的连接
cscope_connection([{num} , {dbpath} [, {prepend}]])
		检查 |cscope| 连接是否存在。如果没有参数，则函数返回:
			0，如果 cscope 不存在 (编译没有带该特性)，或者不存在
			   cscope 连接；
			1，如果至少有一个 cscope 连接。

		如果指定了参数，那么 {num} 的值指定如何检查 cscope 连接存在与
		否的方式:

		{num}	存在检查的方式描述 ~
		-----	------------------------------
		0	等同于无参数 (例如，"cscope_connection()")。
		1	忽略 {prepend}，使用 {dbpath} 的字符串部分匹配。
		2	忽略 {prepend}，使用 {dbpath} 的字符串完整匹配。
		3	使用 {prepend}，使用 {dbpath} 和 {prepend} 的字符串部
			分匹配。
		4	使用 {prepend}，使用 {dbpath} 和 {prepend} 的字符串完
			整匹配。

		注意: 所有的字符串比较都对大小写敏感！

		示例。假定我们有如下设置 (":cs show" 的输出): >

  # pid    database name			prepend path
  0 27664  cscope.out				/usr/local
<
		启动方式					   返回值 ~
		----------					---------- >
		cscope_connection()					1
		cscope_connection(1, "out")				1
		cscope_connection(2, "out")				0
		cscope_connection(3, "out")				0
		cscope_connection(3, "out", "local")			1
		cscope_connection(4, "out")				0
		cscope_connection(4, "out", "local")			0
		cscope_connection(4, "cscope.out", "/usr/local")	1
<

+-*/+-*/cscopepathcomp o 显示路径多少部分
						*'cscopepathcomp'* *'cspc'*
'cscopepathcomp' 'cspc'	数值型	(缺省为 0)
			全局
			{仅当编译时加入 |+cscope| 特性才有效}
			{Vi 无此功能}
	决定标签列表里显示多少路径部分。
	见 |cscopepathcomp|。


+-*/+-*/cscopeprg o 执行 cscope 的命令
						*'cscopeprg'* *'csprg'*
'cscopeprg' 'csprg'	字符串	(缺省为 "cscope")
			全局
			{仅当编译时加入 |+cscope| 特性才有效}
			{Vi 无此功能}
	指定执行 cscope 的命令。见 |cscopeprg|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/cscopequickfix o 用 quickfix 窗口得到 cscope 的结果
						*'cscopequickfix'* *'csqf'*
'cscopequickfix' 'csqf' 字符串	(缺省为 "")
			全局
			{仅当编译时加入 |+cscope| 和 |+quickfix| 特性才有效}
			{Vi 无此功能}
	设置是否使用 quickfix 窗口来显示 cscope 的结果。
	见 |cscopequickfix|。


+-*/+-*/cscopetag o 用 cscope 处理标签命令
				*'cscopetag'* *'cst'* *'nocscopetag'* *'nocst'*
'cscopetag' 'cst'	布尔型 (缺省关闭)
			全局
			{仅当编译时加入 |+cscope| 特性才有效}
			{Vi 无此功能}
	让标签命令使用 cscope。见 |cscope-options|。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/cscopetagorder o 决定 "":cstag"" 的搜索顺序
						*'cscopetagorder'* *'csto'*
'cscopetagorder' 'csto'	数值型	(缺省为 0)
			全局
			{仅当编译时加入 |+cscope| 特性才有效}
			{Vi 无此功能}
	决定 ":cstag" 执行查找的顺序。见 |cscopetagorder|。
	注意: 如果置位 'compatible'，该选项被设为 0。


+-*/+-*/cscopeverbose o 增加 cscope 数据库时给出消息
					*'cscopeverbose'* *'csverb'*
					*'nocscopeverbose'* *'nocsverb'*
'cscopeverbose' 'csverb' 布尔型 (缺省关闭)
			全局
			{仅当编译时加入 |+cscope| 特性才有效}
			{Vi 无此功能}
	增加 cscope 数据库时，给出消息。见 |cscopeverbose|。
	注意: 如果置位 'compatible'，该选项被复位。



+-*/+-*/cstag c 使用 cscope 来跳转到标签上
							*:cstag* *E257* *E562*
如果你同时使用 cscope 和 ctags，|:cstag| 允许你在跳转前对两者都进行查询。例
如，你可以选择先查询 cscope 数据库，如果无法找到匹配，再查询标签文件。这种做法
的次序可以通过 |csto| 的值来调整。参见 |cscope-options|。

+-*/+-*/lcscope c 类似于 "":cscope""，但使用位置列表
							*:lcscope* *:lcs*
此命令和 ":cscope" 命令相同，除了在置位选项 'cscopequickfix' 的时候，使用当前
窗口的位置列表而不是 quickfix 列表来显示 cscope 的结果。

+-*/+-*/scscope c 分割窗口并执行 cscope 命令
		*:cscope* *:cs* *:scs* *:scscope* *E259* *E262* *E561* *E560*
所有命令都是通过主命令 ":cscope" 的子项完成的。主命令最短的缩写是 ":cs"。
":scscope" 完成同样的功能的同时还可以分割窗口 (缩写: "scs")。

+-*/diff _
+-*/+-*/diff o 当前窗口使用 diff 模式
							*'diff'* *'nodiff'*
'diff'			布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+diff| 特性才有效}
	加入本窗口到显示文件差异的窗口组里。见 |vimdiff|。


+-*/+-*/diffexpr o 得到 diff 文件所用的表达式
						*'dex'* *'diffexpr'*
'diffexpr' 'dex'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+diff| 特性才有效}
	用于计算文件两个不同版本的 ed 风格的差异文件的表达式。见
	|diff-diffexpr|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/diffget c 删除当前缓冲区的所有差异
							*:diffg* *:diffget*
:[range]diffg[et] [bufspec]
		用另一个缓冲区来修改当前的缓冲区，消除不同之处。除非只有另外一
		个比较模式下的缓冲区， [bufspec] 必须存在并指定那个缓冲区。
		如果 [bufspec] 指定的是当前缓冲区，则为空动作。
		[range] 可以参考下面。

+-*/+-*/diffoff c 关闭 diff 模式
							*:diffo* *:diffoff*
:diffoff	为当前窗口关闭比较模式。

+-*/+-*/diffopt o 使用 diff 模式的选项
						*'dip'* *'diffopt'*
'diffopt' 'dip'		字符串	(缺省为 "filler")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+diff| 特性才有效}
	diff 模式的设置选项。由以下几个项目组成。全都是可选的。项目之间由逗号
	分隔。

		filler		显示填充行，使得文本和在相同位置多出文本的其它
				窗口同步。多用于并排并且置位 'scrollbind' 的窗
				口。

		context:{n}	在更改和包含未更改行的折叠之间保留的上下文行数
				{n} (译者注: 即差异文周围不被折叠的行数)。如果
				忽略，使用六行上下文。见 |fold-diff|。

		icase		忽略文本大小写的更改。"a" 和 "A" 视为等同。如
				果 'diffexpr' 为空，在 "diff" 命令里加入 "-i"
				标志位。

		iwhite		忽略空白字符数目的更改。如果 'diffexpr' 为空，
				在 "diff" 命令里加入 "-b" 标志位。查阅 "diff"
				文档了解该标志位具体的行为。比如，它应该忽略行
				尾的空白，但不忽略行首的。

		horizontal	以水平分割启动 diff 模式 (除非显式指定不要如
				此)。

		vertical	以垂直分割启动 diff 模式 (除非显式指定不要如
				此)。

		foldcolumn:{n}	启动 diff 模式时设置 'foldcolumn' 选项为 {n}。
				如果不存在，用 2。
	示例: >

		:set diffopt=filler,context:4
		:set diffopt=
		:set diffopt=filler,foldcolumn:3
<

+-*/+-*/diffpatch c 应用补丁然后显示差异
:diffpatch {patchfile}				 *E816* *:diffp* *:diffpatch*
		使用当前的缓冲区，用 {patchfile} 给它打上补丁并打开一个缓冲区
		显示结果。两个缓冲区都将设定为和 "vimdiff" 同样的参数。
		{patchfile} 可以是任何一种 "patch" 程序认识的或 'patchexpr' 可
		以处理的格式。
		注意: {patchfile} 只能包含一个文件的比较结果: 当前文件。如果
		{patchfile} 也包含了其他文件的比较，结果将不可预知。Vim 改变当
		前目录到 /tmp， 以避免当前目录下的文件被意外的打补丁。但它仍不
		能避免若干 ".rej" 文件产生。当绝对路径名出现时，这些文件也不能
		避免被打补丁。

+-*/+-*/diffput c 删除另外一个缓冲区的差异
						*:diffpu* *:diffput* *E793*
:[range]diffpu[t] [bufspec]
		用当前缓冲区来修改另一个缓冲区，消除不同之处。不同于
		":diffget" 之处仅在于被更改的是另一个缓冲区。
		如果忽略 [bufspec]，而多于一个缓冲区处于比较模式并置位
		'modifiable' 的话，此命令失败。
		[range] 可以参考下面。

+-*/+-*/diffsplit c 显示和另外一个文件的差异
:diffsplit {filename}					*:diffs* *:diffsplit*
		对 {filename} 开一个新窗口。当前的和新开的窗口将设定和
		"vimdiff" 一样的参数。另见 'diffexpr'。

+-*/+-*/diffthis c 使得当前窗口成为 diff 窗口
							*:difft* *:diffthis*
:diffthis	使当前窗口参与比较。本命令设定和 "vimdiff" 同样的选项。

+-*/+-*/diffupdate c 更新 'diff' 缓冲区
							*:diffu* *:diffupdate*
:diffu[pdate]			刷新比较结果的高亮和折叠。

+-*/+-*/patchexpr o 用于给文件打补丁的表达式
						*'pex'* *'patchexpr'*
'patchexpr' 'pex'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+diff| 特性才有效}
	用来给文件打补丁并生成文件新版本的表达式。见 |diff-patchexpr|。


+-*/display _ 显示
+-*/+-*/ascii c 显示光标所在的字符的 ascii 值
:as[cii]	或					*ga* *:as* *:ascii*
ga			显示光标下字符的 ascii 值，分别以十进制、十六进制和八
			进制显示。例如，如果光标下是 'R':

+-*/+-*/binary o 二进制方式读/写/编辑文件
				     *'binary'* *'bin'* *'nobinary'* *'nobin'*
'binary' 'bin'		布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
	本选项应该在编辑二进制文件之前设置。你也可以用 Vim 的 |-b| 参数。如果
	打开本选项，一些选项的值会发生改变 (即使它们原本是打开的):
		'textwidth'  会设为 0
		'wrapmargin' 会设为 0
		'modeline'   会被关闭
		'expandtab'  会被关闭
	此外，也不会使用 'fileformat' 和 'fileformats' 选项。文件的读写如同
	'fileformat' 设为 "unix" 那样 (单个 <NL> 分隔行)。
	不会使用 'fileencoding' 和 'fileencodings' 选项。文件读取不经过转换。
	注意: 如果 'bin' 选项已经打开而你开始编辑 (另) 一个文件，自动命令的设
	置可能会再次改变这些相关的设置 (比如，'textwidth')，使得编辑出现麻烦。
	因而，载入文件时，你可以再次置位 'bin'。
	这些选项以前的值被记住，'bin' 从开到关时会复原它们。每个缓冲区都有一组
	保存的选项值。
	要使用 'binary' 编辑文件，你可以使用 |++bin| 参数。这样你不用输入
	":set bin"，而后者会影响所有你编辑的文件。
	写回文件时，只有原来文件本就包含时才写入末行的 <EOL>  (通常，如果末行
	没有 <EOL>，Vim 会附加一个；这样文件会变长)。见 'endofline' 选项。


+-*/+-*/breakat o 可以在此断行的字符
						*'breakat'* *'brk'*
'breakat' 'brk'		字符串	(缺省为 " ^I!@*-+;:,./?")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+linebreak| 特性才有效}
	如果打开 'linebreak'，本选项让你选择可以在什么字符上换行。只能用 ASCII
	字符，但如果 'encoding' 是 8 位编码，也可以用 8 位的字符。



+-*/+-*/display o 如何显示文本的标志位列表
					*'display'* *'dy'*
'display' 'dy'		字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	改变文件显示的方式。这是逗号分隔的标志位的列表:
	lastline	如果包含，显示窗口末行尽量多的内容。如果不包含，不能在
			窗口完全放入的末行会以 "@" 行代替。
	uhex		显示不可显示字符的十六进制值，形如 <xx>，而不是用 ^C
			和 ~C 这样的形式。


+-*/+-*/fillchars o 显示特殊项目所使用的字符
						*'fillchars'* *'fcs'*
'fillchars' 'fcs'	字符串	(缺省为 "vert:|,fold:-")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 和 |+folding| 特性才有效}
	填充状态行和垂直分割线的字符。
	它是逗号分隔的项目列表:

	  项目		缺省		用于 ~
	  stl:c		' ' 或 '^'	当前窗口的状态行
	  stlnc:c	' ' 或 '-'	非当前窗口的状态行
	  vert:c	'|'		垂直分割线 |:vsplit|
	  fold:c	'-'		填充 'foldtext'
	  diff:c	'-'		'diff' 选项里的被删除行

	任何不提供的项目使用其缺省值。"stl" 和 "stlnc" 在有高亮的地方使用空
	格，否则使用 '^' 或 '-'。

	例如: >
	    :set fillchars=stl:^,stlnc:-,vert:\|,fold:-,diff:-
<	除了在高亮时也使用那些字符以外，这类似于缺省值。

	"stl" 和 "stlnc" 只支持单字节的值。

	这些项目使用的高亮:
	  项目		高亮组 ~
	  stl:c		StatusLine		|hl-StatusLine|
	  stlnc:c	StatusLineNC		|hl-StatusLineNC|
	  vert:c	VertSplit		|hl-VertSplit|
	  fold:c	Folded			|hl-Folded|
	  diff:c	DiffDelete		|hl-DiffDelete|


+-*/+-*/isprint o 可显示的字符
						*'isprint'* *'isp'*
'isprint' 'isp'	字符串	(MS-DOS、Win32、OS/2 和 Macintosh 缺省为: "@,~-255"；
				否则: "@,161-255")
			全局
			{Vi 无此功能}
	此选项给出的字符在屏幕上能直接显示。|pattern| 里的 "\p" 也使用此选项。
	从空格 (ASCII 32) 到 '~' (ASCII 126) 的字符总是可以直接显示的，即使它
	们没有包含在 'isprint' 里，甚至被排除也是如此。此选项的格式可见
	'isfname' 处的描述。

	不可显示字符使用两个字符显示:
		  0 -  31	"^@" - "^_"
		 32 - 126	总是单个字符
		   127		"^?"
		128 - 159	"~@" - "~_"
		160 - 254	"| " - "|~"
		   255		"~?"
	如果 'encoding' 是某个 Unicode 编码，128 到 255 的非法字符显示为
	<xx>，其中给出该字节的十六进制值。
	如果 'display' 包含 "uhex"，所有的不可显示字符都显示为 <xx>。
	不可显示字符使用 SpecialKey 高亮。|hl-SpecialKey|

	多字节字符，即 256 及更高的字符，总是包含在内，只有 255 以内的字符才需
	要在此选项里指定。如果字符可显示但当前字体没有包含该字符，显示一个替代
	字符。
	不可显示并且零宽度的 Unicode 字符都显示为 <xxxx>。没有指定这些字符的选
	项。


+-*/+-*/laststatus o 当最近的窗口有状态行时提示
					*'laststatus'* *'ls'*
'laststatus' 'ls'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
	本选项的值影响最后一个窗口何时有状态行:
		0: 永不
		1: 只有在有至少两个窗口时
		2: 总是
	如果你有多个窗口，有状态行会使屏幕看起来好一些，但它会占据一个屏幕行。
	|status-line|


+-*/+-*/linebreak o 在空白处回绕长行
			*'linebreak'* *'lbr'* *'nolinebreak'* *'nolbr'*
'linebreak' 'lbr'	布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+linebreak| 特性才有效}
	如果打开，Vim 会在 'breakat' 里的字符上，而不是在屏幕上可以显示的最后
	一个字符上回绕长行。和 'wrapmargin' 和 'textwidth' 不同，此处不会插入
	<EOL>，它只影响文件的显示方式，而不是其内容。'showbreak' 的值会出现在
	回绕行的前面。
	如果 'wrap' 选项关闭或 'list' 打开，不使用本选项。
	注意 <EOL> (屏幕上的) 之后的 <Tab> 字符在多数情况下，不会显示正确数量
	的空格。


+-*/+-*/list o 显示 <Tab> 和 <EOL>
						*'list'* *'nolist'*
'list'			布尔型	(缺省关闭)
			局部于窗口
	列出方式: 像显示 CTRL-I 那样显示制表，行尾之后显示 $。用于看到制表和空
	格的区别以及拖尾的空白。'listchars' 选项可以进一步指定改变。

	光标显示在制表占据的空白的开始位置，而不是像通常在普通模式那样显示在最
	后位置。要用空格来显示制表并同时把光标放在空白开始位置，可用: >
		:set list lcs=tab\ \ 
<
	(译者注: 原文如此，似应为: >
		:set list lcs=tab:\ \ 
<	)
	注意 如果 'cpoptions' 里包含 'L'，本选项也影响排版 (用 'textwidth' 或
	'wrapmargin' 方法设置的)。'listchars' 说明如何改变制表显示的方式。


+-*/+-*/listchars o list 模式下显示用的字符
						*'listchars'* *'lcs'*
'listchars' 'lcs'	字符串	(缺省为 "eol:$")
			全局
			{Vi 无此功能}
	'list' 模式和 |:list| 命令使用的字符串。这是逗号分隔的字符串设置的列
	表。
	  eol:c		行尾显示的字符。如果忽略，行尾没有额外的字符。
	  tab:xy	用于显示制表的两个字符。使用第一个字符一次。然后重复第
			二个字符来填充制表通常填充的位置。
			"tab:>-" 会显示占据四个空格的制表 ">---"。
			如果忽略，制表显示为 ^I。
	  trail:c	拖尾空白显示的字符。如果忽略，拖尾空白显示为空格。
	  extends:c	如果 'wrap' 关闭，而行在屏幕右边界之后还要继续时，最后
			一列显示的字符。
	  precedes:c	如果 'wrap' 关闭，而行在可视范围第一列之前还有内容时，
			第一列显示的字符。
	  conceal:c	用于替代隐藏文本的字符，用于 'conceallevel' 为 1 时。
	  nbsp:c	显示不可间断空格的字符 (字符 0xA0，160)。如果忽略，留
			出一个空格。

	不应该使用字符 ':' 和 ','。如果 'encoding' 为 "utf-8"，可以使用 UTF-8
	字符，不然只能使用可显示的字符。所有字符必须使用单倍宽度。

	示例: >
	    :set lcs=tab:>-,trail:-
	    :set lcs=tab:>-,eol:<,nbsp:%
	    :set lcs=extends:>,precedes:<
<	"NonText" 高亮会用于 "eol"、"extends" 和 "precedes"。"SpecialKey" 用于
	"nbsp"、"tab" 和 "trail"。
	|hl-NonText| |hl-SpecialKey|


+-*/+-*/matchtime o 显示匹配括号的时间 (以十分之一秒计)
						*'matchtime'* *'mat'*
'matchtime' 'mat'	数值型	(缺省为 5)
			全局
			{Vi 无此功能}{Nvi 有}
	如果置位 'showmatch'，显示配对括号的十分之一秒数。注意 这不是毫秒数，
	和其它设置时间的选项不同。这是为了和 Nvi 兼容。


+-*/+-*/nrformats o CTRL-A 命令识别的数字格式
							*'nrformats'* *'nf'*
'nrformats' 'nf'	字符串	(缺省为 "octal,hex")
			局部于缓冲区
			{Vi 无此功能}
	本选项定义 Vim 使用 CTRL-A 和 CTRL-X 命令分别加减数值时使用的数值的基
	底；关于这些命令的更多的信息，见 |CTRL-A|。
	alpha	如果包含，单个字母会被递增和递减。这可以用于使用字母索引的列表
		a)、b)，等等。					*octal-number*
	octal	如果包含，零开始的数值认为是八进制。例如: 在 "007" 上用 CTRL-A
		得到 "010"。
	hex	如果包含，"0x" 或 "0X" 开始的数值认为是十六进制。例如: "0x100"
		上用 CTRL-X 得到 "0x0ff"。
	简单的以 1-9 的数字开始的数值总被认为是十进制的。这也包括不能识别为八
	进制或十六进制的数值。


+-*/+-*/number o 行前显示行号
				*'number'* *'nu'* *'nonumber'* *'nonu'*
'number' 'nu'		布尔型	(缺省关闭)
			局部于窗口
	在每行前面显示行号。如果 'cpoptions' 里没有 'n' 选项，回绕的行不使用行
	号所在的列 (如果没有置位 'compatible'，这是缺省)。
	'numberwidth' 选项可以用来设置行号使用的空间。
	如果长的回绕的行不从第一个字符开始，'-' 字符出现在行号前面。
	|hl-LineNr| 说明行号使用的高亮。
	置位此选项时，关闭 'relativenumber' 选项。


+-*/+-*/number c 显示文本行时给出行号
							*:nu* *:number*
:[range]nu[mber] [count] [flags]
			和 :print 相同，但每行之前显示行号 (也参见 'highlight'
			和 'numberwidth' 选项)。
			|ex-flags| 说明 [flags]。

+-*/+-*/numberwidth o 行号使用的列数
						*'numberwidth'* *'nuw'*
'numberwidth' 'nuw'	数值型	(Vim 缺省: 4  Vi 缺省: 8)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+linebreak| 特性才有效}
	行号使用的最小列数。只有置位 'number' 或 'relativenumber' 选项或者带行
	号打印时才有意义。因为行号和文本之间总有一个空格，实际的字符数比该数值
	小一。
	该值是最小的宽度。取决于使用 'number' 还是 'relativenumber'，如果为适
	应缓冲区最大的行号或窗口的行数而有必要的话，会使用更大的宽度。这样，
	Vim 缺省值 4 可以容纳最大行号为 999。若缓冲区有 1000 行，会使用五列。
	最小值为 1，最大值为 10。
	注意: 如果置位 'compatible'，该选项被复位为 0。


+-*/+-*/relativenumber o 每行前显示相对行号
		*'relativenumber'* *'rnu'* *'norelativenumber'* *'nornu'*
'relativenumber' 'rnu'	布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
	在每行前显示相对于光标所在的行的行号。相对行号帮助你给出某些垂直移动命
	令 (如 j k + -) 时需要的计数值 |count|，省得你自己去计算。和其它若干命
	令组合使用时会更有用 (如 y d c < > gq gw =)。
	如果 'cpoptions' 排除 'n' 选项，回绕行不使用行号所占的列 (如果没有置位
	'compatible'，这是缺省情况)。
	可用 'numberwidth' 选项设置行号所需的空间。
	经回绕的长行如果不是从首个字符开始，行号之前会加上 '-' 字符。
	行号使用的高亮见 |hl-LineNr|。
	如果置位此选项，关闭 'number' 选项。


+-*/+-*/report o 报告行改变的行数下限
						*'report'*
'report'		数值型	(缺省为 2)
			全局
	报告改变行数的阈值。如果多于 'report' 的行发生改变，多数 ":" 命令会给
	出消息。如果你总是想得到这个消息，设定 'report' 为零。
	对于 ":substitute" 命令而言，使用替代的数目，而不是行数。


+-*/+-*/ruler o 标尺，在状态行里显示光标的行号和列号
					 *'ruler'* *'ru'* *'noruler'* *'noru'*
'ruler' 'ru'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+cmdline_info| 特性才有效}
	标尺。显示光标位置的行号和列号，逗号分隔。如果还有空间，在最右端显示文
	本在文件中的相对位置:
		Top	首行可见
		Bot	末行可见
		All	首末两行都可见
		45%	文件中的相对位置
	如果设置 'rulerformat'，它决定标尺的内容。
	每个窗口都有自己的标尺。如果窗口有状态行，标尺在那里显示。否则，它显示
	在屏幕的最后一行上。如果通过 'statusline' 给出状态行 (亦即，非空)，该
	选项优先于 'ruler' 和 'rulerformat'。
	如果显示的字符数不同于文本的字节数 (比如，TAB 或者多字节字符)，同时显
	示文本列号 (字节数) 和屏幕列号，以连字符分隔。
	空行显示 "0-1"。
	空缓冲区的行号也为零: "0,0-1"。
	如果置位 'paste' 选项，本选项被复位。
	如果你不想一直看到标尺但想知道现在在哪里，使用 "g CTRL-G" |g_CTRL-G|。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/rulerformat o 定制标尺格式
						*'rulerformat'* *'ruf'*
'rulerformat' 'ruf'	字符串	(缺省为空)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+statusline| 特性才有效}
	如果本选项非空，它决定 'ruler' 选项要显示的标尺字符串的内容。
	本选项的格式和 'statusline' 类同。
	缺省的标尺宽度是 17 个字符。要使标尺 15 个字符宽，在开始加上 "%15("，
	在最后加入 "%)"。
	例如: >
		:set rulerformat=%15(%c%V\ %p%%%)
<

+-*/+-*/shortmess o 缩短消息长度的标志位列表
						*'shortmess'* *'shm'*
'shortmess' 'shm'	字符串	(Vim 缺省 "filnxtToO"，Vi 缺省: ""，
							POSIX 缺省: "A")
			全局
			{Vi 无此功能}
	本选项有助于避免文件信息的所有 |hit-enter| 提示，比如用 CTRL-G 的时
	候。它还用于避免或减少一些其它消息。以下是标志位的列表:
	 标志位	存在时的意义	~
	  f	用 "(3 of 5)" 代替 "(file 3 of 5)"
	  i	用 "[noeol]" 代替 "[Incomplete last line]"
	  l	用 "999L, 888C" 代替 "999 lines, 888 characters"
	  m	用 "[+]" 代替 "[Modified]"
	  n	用 "[New]" 代替 "[New File]"
	  r	用 "[RO]" 代替 "[readonly]"
	  w	用 "[w]" 代替文件写入消息的 "written"，
		还有用 "[a]" 代替 ':w >> file' 命令的 "appended"
	  x	用 "[dos]" 代替 "[dos format]"、
		用 "[unix]" 代替 "[unix format]"、
		还有用 "[mac]" 代替 "[mac format]"。
	  a	所有以上的缩写。

	  o	后续文件的读入信息覆盖文件的写回消息 (":wn" 或打开 'autowrite'
		时有用)。
	  O	文件的读入信息覆盖任何前面消息，包括 quickfix 消息 (比如，
		":cn")。
	  s	不给出 "search hit BOTTOM, continuing at TOP" 或 "search hit
		TOP, continuing at BOTTOM" 消息。
	  t	如果文件消息不能完整放在命令行上，从开头截短该消息。最左列给出
		"<"。Ex 模式忽略此标志位。
	  T	如果其它的消息不能完整放在命令行上，从中间截短该消息。中间给出
		"<"。Ex 模式忽略此标志位。
	  W	写入文件时，不给出 "written" 或 "[w]"。
	  A	如果发现交换文件已存在，不给出 "ATTENTION" 消息。
	  I	启动 Vim 时不给出介绍消息 |:intro|。

	这给你一个机会，避免在缓冲区之间切换要按 <Enter>，但仍然能够在可用的空
	间里得到有用的消息。要得到 'shm' 为空时的完整消息，使用 ":file!"。
	有用的值:
	    shm=	没有消息缩写。
	    shm=a	有缩写，但不丢失消息。
	    shm=at	有缩写，必要时截短消息。

	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/showbreak o 用于提示回绕行开始的字符串
						*'showbreak'* *'sbr'* *E595*
'showbreak' 'sbr'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+linebreak| 特性才有效}
	回绕行放置在开头的字符串。有用的值如 "> " 或 "+++ ": >
		:set showbreak=>\ 
<	注意 要用反斜杠来转义拖尾的空格。下面的就容易些: >
		:let &showbreak = '+++ '
<	只允许可显示且只占用一个单元位置的字符，不包括 <Tab> 和逗号 (将来的版
	本里，逗号可能用来分隔行首和行尾显示的不同部分)。
	这些字符的高亮由 'highlight' 的 '@' 标志位决定。
	注意 showbreak 之后的制表使用不同的显示方式。
	如果要 'showbreak' 出现在行号之间，在 'cpoptions' 里加上 "n" 标志位。


+-*/+-*/showcmd o 在状态行里显示 (部分) 命令
				     *'showcmd'* *'sc'* *'noshowcmd'* *'nosc'*
'showcmd' 'sc'		布尔型	(Vim 缺省: 打开，Unix 关闭，Vi 缺省: 关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+cmdline_info| 特性才有效}
	在屏幕最后一行显示 (部分的) 命令。如果你的终端很慢，关闭此选项。
	可视模式里，显示选择区域的大小，即:
	- 在行内选择若干字符时，字符数。如果字节数不同，同时显示字节数: "2-6"
	  代表 2 个字符和 6 个字节。
	- 选择多于一行时，行数。
	- 选择可视列块时，屏幕字符的数目: {lines} 乘以 {columns}。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复
	位 'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/showmatch o 插入括号时短暂跳转到匹配的括号
				 *'showmatch'* *'sm'* *'noshowmatch'* *'nosm'*
'showmatch' 'sm'	布尔型	(缺省关闭)
			全局
	插入括号时，短暂地跳转到匹配的对应括号。只有在屏幕上能看到匹配时才会进
	行跳转。显示匹配的时间用 'matchtime' 设置。
	如果没有匹配会响铃 (和匹配能否看到无关)。置位 'paste' 时，复位本选项。
	如果 'cpoptions' 里没有 'm' 标志位，接着输入字符会立即把光标移动到它应
	该在的位置。
	'guicursor' 的 "sm" 域说明显示匹配时，如何设置光标形状和闪烁。
	'matchpairs' 选项可指定显示匹配所用的字符。用 'rightleft' 和 'revins'
	查找反方向的匹配。
	移动时要高亮匹配，另见 matchparen 插件 |pi_paren.txt|。
	备注: 要使用短形式，建议加强家长指导 (译者注: :-))。


+-*/+-*/showmode o 在状态行上显示当前模式的消息
				 *'showmode'* *'smd'* *'noshowmode'* *'nosmd'*
'showmode' 'smd'	布尔型	(Vim 缺省: 打开，Vi 缺省: 关闭)
			全局
	在插入、替换和可视模式里，在最后一行提供消息。
	'highlight' 的 'M' 标志位设置此消息的高亮类型。
	如果可能使用 |XIM|，消息里会包含 "XIM"。但这不意味着实际激活了 XIM，尤
	其是可能还没有设置 'imactivatekey'。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/sign c 操作标号
2. 命令						*sign-commands* *:sig* *:sign*

+-*/+-*/statusline o 状态行的定制格式
			   *'statusline'* *'stl'* *E540* *E541* *E542*
'statusline' 'stl'	字符串	(缺省为空)
			全局或局部于窗口 |global-local|
			{Vi 无此功能}
			{仅当编译时加入 |+statusline| 特性才有效}
	如果非空，本选项决定状态行的内容。另见 |status-line|。

	此选项包含 printf 风格的 '%' 项目，中间可以间杂普通文本。每个状态行项
	目有如下形式:
	  %-0{minwid}.{maxwid}{item}
	除了 {item} 以外，每个字段都是可选的。单个百分号可以用 "%%" 给出。最多
	可给出 80 个项目。

	如果此选项以 "%!" 开始，它用作表达式。计算此表达式的结果用作选项值。例
	如: >
		:set statusline=%!MyStatusLine()
<	返回值可以包含 %{} 项目，它还会被继续计算下去。

	如果计算选项时有错误，会把它清空以防将来继续出错。否则屏幕更新会陷入循
	环。

	注意 如果设置本选项 (并且 'laststatus' 为 2 的话)，'ruler' 的唯一效果
	是控制 |CTRL-G| 的输出。

	域	    含义 ~
	-	    左对齐项目。如果 minwid 大于项目的长度，缺省是右对齐。
	0	    数值项目前面用零填补。'-' 更优先。
	minwid	    项目的最小宽度，以 '-' 和 '0' 补空。该值不能超过 50。
	maxwid	    项目的最大宽度。如果超过，在文本项目的左侧截短，以 '<' 代
		    替。数值项目则往下移到 maxwid-2 个数位，然后跟 '>'number，
		    其中的 number 是丢失的数位，这非常类似于指数记法。
	item	    单个字符的代码，下面给出描述。

	下面是可能状态行项目的描述。其中，"项目" 的第二个字符代表类型:
		N 代表数值型
		S 代表字符串型
		F 代表下面描述的标志位
		- 不适用

	项目  含义 ~
	f S   缓冲区的文件路径，保持输入的形式或相对于当前目录。
	F S   缓冲区的文件完整路径。
	t S   缓冲区的文件的文件名 (尾部)。
	m F   修改标志位，文本是 "[+]"；若 'modifiable' 关闭则是 "[-]"。
	M F   修改标志位，文本是 ",+" 或 ",-"。
	r F   只读标志位，文本是 "[RO]"。
	R F   只读标志位，文本是 ",RO"。
	h F   帮助缓冲区标志位，文本是 "[help]"。
	H F   帮助缓冲区标志位，文本是 ",HLP"。
	w F   预览窗口标志位，文本是 "[Preview]"。
	W F   预览窗口标志位，文本是 ",PRV"。
	y F   缓冲区的文件类型，如 "[vim]"。见 'filetype'。
	Y F   缓冲区的文件类型，如 ",VIM"。见 'filetype'。
	      {仅当编译时加入 |+autocmd| 特性才有效}
	q S   "[Quickfix List]"、"[Location List]" 或空。
	k S   "b:keymap_name" 的值或使用 |:lmap| 映射时的 'keymap':
	      "<keymap>"。
	n N   缓冲区号。
	b N   光标所在字节的值。
	B N   同上，以十六进制表示。
	o N   光标所在字节在文件中的字节偏移，第一个字节为 1。
	      助记: 从文件开始的偏移 (Offset) (加上 1)
	      {仅当编译时加入 |+byte_offset| 特性才有效}
	O N   同上，以十六进制表示。
	N N   打印机页号。(只用于 'printheader' 选项。)
	l N   行号。
	L N   缓冲区里的行数。
	c N   列号。
	v N   虚拟列号。
	V N   虚拟列号，表示为 -{num}。如果等于 'c' 的值，不显示。
	p N   行数计算在文件位置的百分比，如同 |CTRL-G| 给出的那样。
	P S   显示窗口在文件位置的百分比，类似于 'ruler' 描述的百分比。长度总
	      是为 3。
	a S   参数列表状态，就像缺省标题里的那样。({current} of {max})
	      如果参数列表里的文件数为零或一，空字符串。
	{ NF  计算 '%{' 和 '}' 之间的表达式，并返回其结果替代。注意 结束的 '}'
	      之前没有 '%'。
	( -   项目组的开始。可以用来为某组项目设置宽度和对齐。后面某处必须有
	      %)。
	) -   项目组的结束。不能指定宽度域。
	T N   用于 'tabline': 标签页 N 标签的开始。最后一个标签之后用 %T。鼠标
	      点击时用此信息。
	X N   用于 'tabline': 关闭标签页 N 标签的开始。最后一个标签之后用 %T。
	      例如: %3Xclose%X，用 %999X 来代表 "关闭当前标签页" 那个符号。鼠
	      标点击时用此信息。
	< -   如果行过长，在什么地方截短。缺省是在开头。不能指定宽度域。
	= -   左对齐和右对齐项目之间的分割点。不能指定宽度域。
	# -   设置高亮组。必须后面跟名字，然后又是 #。这样，%#HLname# 代表高亮
	      组 HLname。包括非当前窗口的状态行都使用相同的高亮组。
	* -   设置高亮组为 User{N}，其中的 {N} 取自 minwid 域，比如 %1*。用 %*
	      或者 %*0 可以恢复 normal 高亮。User{N} 和 StatusLine 的区别也会
	      应用到非当前窗口的状态行使用的 StatusLineNC 上。
	      数字 N 必须从 1 到 9。见 |hl-User1..9|

	显示标志位时，如果它紧跟在普通文本之后，Vim 删除之前的前导逗号。这使得
	下面例子里使用的标志位显示看起来很舒服。

	如果组内的所有项目都是空字符串 (比如，标志位没有设置) 而该组没有设置
	minwid，整个组成为空字符串。这使得下面这样的组完全从状态行上消失，如果
	没有标志位被置位的话。 >
		:set statusline=...%(\ [%M%R%H]%)...
<
	要小心，每次显示状态行时都要计算此表达式。当前缓冲区和当前窗口会临时设
	为目前要显示的状态行所属的窗口 (缓冲区)，而表达式会使用此上下文计算。
	变量 "actual_curbuf" 被设为实际的当前缓冲区的 'bufnr()' 号。
	
	可能在沙盘 |sandbox| 里计算 'statusline' 选项。见 |sandbox-option|。

	计算 'statusline' 时不允许修改文本或者跳到其它窗口 |textlock|。

	如果状态行在你希望时没有更新 (如在设置完表达式里使用的某变量之后)，设
	置选项可以强制进行更新而无须更改其值。例如: >
		:let &ro = &ro

<	如果结果全是数字，用作显示时把它作为数值处理。否则结果作为文本，并应用
	上面描述的规则。

	小心表达式里的错误。它们可能使 Vim 不可用！
	如果你被困住，按住 ':' 或 'Q' 来得到提示，然后退出并用 "vim -u NONE"
	来编辑 .vimrc 或者别的什么地方，以修正问题。

	示例:
	模拟 'ruler' 设置的标准状态行 >
	  :set statusline=%<%f\ %h%m%r%=%-14.(%l,%c%V%)\ %P
<	类似，但加上光标所在字符的 ASCII 值 (类似于 "ga") >
	  :set statusline=%<%f%h%m%r%=%b\ 0x%B\ \ %l,%c%V\ %P
<	显示字节偏移和字节值，用红色标记已修改标志位。 >
	  :set statusline=%<%f%=\ [%1*%M%*%n%R%H]\ %-19(%3l,%02c%03V%)%O'%02b'
	  :hi User1 term=inverse,bold cterm=inverse,bold ctermfg=red
<	如果载入的是压缩文件，显示 ,GZ 标志 >
	  :set statusline=...%r%{VarExists('b:gzflag','\ [GZ]')}%h...
<	并在 |:autocmd| 里: >
	  :let b:gzflag = 1
<	或: >
	  :unlet b:gzflag
<	还要定义此函数: >
	  :function VarExists(var, val)
	  :    if exists(a:var) | return a:val | else | return '' | endif
	  :endfunction
<

+-*/+-*/terse o 简化部分消息
						*'terse'* *'noterse'*
'terse'			布尔型	(缺省关闭)
			全局
	如果置位: 在 'shortmess' 选项里加入 's' 标志位 (这使得遭遇文件首部和尾
	部的搜索不会给出消息)。如果复位: 从 'shortmess' 选项里删除 's' 标志
	位。{Vi 缩短很多消息}


+-*/+-*/wrap o 长行回绕并在下一行继续
						*'wrap'* *'nowrap'*
'wrap'			布尔型	(缺省打开)
			局部于窗口
			{Vi 无此功能}
	该选项改变文本显示的方式。它不改变缓冲区里的文本，'textwidth' 会。
	如果打开，超过窗口宽度的行会回绕，并在下一行继续显示。如果关闭，行不会
	回绕。长行只有一部分会显示。如果光标移动到不显示的部分，屏幕会水平滚
	动。
	如果需要的话，行会在单词的中间断开。'linebreak' 说明如何在单词边界上断
	行。
	要使得水平滚动稍微更有用些，试设: >
		:set sidescroll=5
		:set listchars+=precedes:<,extends:>
<	见 'sidescroll'、'listchars' 和 |wrap-off|。
	如果 'diff' 选项置位，不能从 |modeline| 中设置。


+-*/+-*/wrapmargin o 使 (硬) 回绕开始的从右侧起算的字符数
						*'wrapmargin'* *'wm'*
'wrapmargin' 'wm'	数值型	(缺省为 0)
			局部于缓冲区
	使 (硬) 回绕开始的从右窗口边界起算的字符数。如果输入的文本超过此限制，
	<EOL> 会被插入，而插入从下一行继续。
	增加边距的选项，比如 'number' 和 'foldcolumn'，会使得文本宽度被进一步
	限缩。这是 Vi 兼容行为。
	如果 'textwidth' 非零，不使用本选项。
	另见 'formatoptions' 和 |ins-textwidth|。{Vi: 行为不同，可用性也差}


+-*/+-*/wrapscan o 搜索在文件尾折回文件头
				   *'wrapscan'* *'ws'* *'nowrapscan'* *'nows'*
'wrapscan' 'ws'		布尔型	(缺省打开)			*E384* *E385*
			全局
	搜索在文件末回绕回文件首。也用于 |]s| 和 |[s|，搜索拼写错误。


+-*/+-*/z c 显示一些行
							*:z* *E144*
:{range}z[+-^.=]{count}	显示包围 {range} 指定行的若干行文本，如果没有 {range},
			这显示当前行上下的文本。如果有 {count}，它指定你能看到
			的行数。否则，如果只有一个窗口，使用 'window' 选项。不
			然，使用当前的窗口大小。

+-*/edit _ 编辑
+-*/+-*/append f 附加行或行的列表到缓冲区
append({lnum}, {expr})					*append()*
		当 {expr} 为 |List|: 把每个 |List| 项目作为文本行，附加到当前
		缓冲区第 {lnum} 行之下。
		否则，把 {expr} 作为单个文本行，附加于当前缓冲区第 {lnum} 行之
		下。
		{lnum} 可以为零，用于在第一行前插入一行。如果失败 ({lnum} 越
		界)，返回 1，成功则返回 0。例如: >
			:let failed = append(line('$'), "# THE END")
			:let failed = append(0, ["Chapter 1", "the beginning"])
<
							*argc()*
+-*/+-*/append c 附加文本
							*:a* *:append*
:{range}a[ppend][!]	在指定行下方添加若干行。如果没有给出 {range}，文本会在
			当前行之后插入。
			加入 [!] 切换此命令执行时的 'autoindent'。

+-*/+-*/backspace o 在一行开头按退格键如何处理
							*'backspace'* *'bs'*
'backspace' 'bs'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	影响 <BS>、<Del>、CTRL-W 和 CTRL-U 在插入模式下的工作方式。它是逗号分
	隔的项目列表。每个项目允许一种退格删除的内容:
	值	效果	~
	indent	允许在自动缩进上退格
	eol	允许在换行符上退格 (连接行)
	start	允许在插入开始的位置上退格；CTRL-W 和 CTRL-U 到达插入开始的位
		置时停留一次。

	如果该值为空，使用 Vi 兼容的退格方式。

	为了和 5.4 及更早的版本后向兼容:
	值	效果	~
	  0	等同于 ":set backspace=" (Vi 兼容)
	  1	等同于 ":set backspace=indent,eol"
	  2	等同于 ":set backspace=indent,eol,start"

	如果你的 <BS> 或 <Del> 键不合你的期望，见 |:fixdel|。
	注意: 如果置位 'compatible'，该选项被设为 ""。


+-*/+-*/center c 排版行，使其居中对齐
:[range]ce[nter] [width]				*:ce* *:center*
			在 [range] 指定范围的行和 [width] 限定的列 (缺省为
			'textwidth'，如其为 0，则取 80) 范围内的文本居中对齐。
			{Vi 无此功能}
			只有在编译时加入 |+ex_extra| 特性时才有此功能。

+-*/+-*/change c 替换一行或若干行
							*:c* *:ch* *:change*
:{range}c[hange][!]	用另外的文本替换若干文本行。输入只包含 "." 的行结束替
			换。如果没有 {range}，该命令只置换当前行。
			加上 [!] 后，在本命令的执行期间切换 'autoindent'。

+-*/+-*/copy c 复制行
:[range]co[py] {address}				*:co* *:copy*
			把 [range] 指定的行复制到 {address} 给出的行之下。

+-*/+-*/delete c 删除行
						*:d* *:de* *:del* *:delete*
:[range]d[elete] [x]	删除 [range] 范围的行 (缺省: 当前行) [到寄存器 x 里]。

+-*/+-*/earlier c 回到旧的改变，撤销
							*:ea* *:earlier*
:earlier {count}	转到 {count} 次较早的文本状态。
:earlier {N}s		转到大约 {N} 秒钟之前的较早的文本状态。
:earlier {N}m		转到大约 {N} 分钟之前的较早的文本状态。
:earlier {N}h		转到大约 {N} 小时之前的较早的文本状态。
:earlier {N}d		转到大约 {N} 天之前的较早的文本状态。

+-*/+-*/esckeys o 插入模式下识别功能键
				     *'esckeys'* *'ek'* *'noesckeys'* *'noek'*
'esckeys' 'ek'		布尔型	(Vim 缺省: 打开，Vi 缺省: 关闭)
			全局
			{Vi 无此功能}
	插入模式识别 <Esc> 开始的功能键。如果关闭此选项，光标和功能键，如果它
	们以 <Esc> 开头的话，不能用于插入模式。它的优点是，单个 <Esc> 可以被马
	上识别，而不用等待一秒。除了复位此选项以外，你也可以改变 'timeoutlen'
	和 'ttimeoutlen' 的值。注意如果 'esckeys' 关闭，你仍然可以建立相关的映
	射，但缺省情况下无法使用光标键。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/expandtab o 键入 <Tab> 时使用空格
				 *'expandtab'* *'et'* *'noexpandtab'* *'noet'*
'expandtab' 'et'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
	插入模式里: 插入 <Tab> 时使用合适数量的空格。如果 'autoindent' 打开，
	'>' 和 '<' 命令使用空格进行缩进。'expandtab' 打开时，要插入实际的制
	表，可用 CTRL-V<Tab>。另见 |:retab| 和 |ins-expandtab|。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/fixdel c 设置 <Del> 的键码
							*:fix* *:fixdel*
:fix[del]		设置 't_kD' 的值，如果:

+-*/+-*/getline f 从缓冲区中取一行
getline({lnum} [, {end}])
		如果没有 {end}，返回字符串，即当前缓冲区第 {lnum} 行文本。
		例如: >
			getline(1)
<		如果 {lnum} 是不以数字开始的字符串，调用 line() 来把该字符串转
		化成数值。要得到光标所在的行: >
			getline(".")
<		如果 {lnum} 小于 1 或者大于缓冲区的总行数，返回空字符串。

		如果给出 {end}，返回 |List|，其中每个项目是当前缓冲区从 {lnum}
		到 {end} (包含) 范围的一行。
		{end} 的用法同 {lnum}。
		安静地忽略不存在的行。
		如果 {end} 在 {lnum} 之前，返回空 |List|。
		例如: >
			:let start = line('.')
			:let end = search("^$") - 1
			:let lines = getline(start, end)

<		要获取其它缓冲区的文本行，见 |getbufline()|。


+-*/+-*/global c 对匹配的行执行命令
						*:g* *:global* *E147* *E148*
:[range]g[lobal]/{pattern}/[cmd]
			在 [range] 界定的匹配模式 {pattern} 的文本行上执行
			Ex 命令 |cmd| (缺省是 ":p")。

+-*/+-*/insert c 插入文本
							*:i* *:in* *:insert*
:{range}i[nsert][!]	在指定行上方添加若干行。如果没有给出 {range}，文本会在
			当前行之前插入。
			加入 [!] 切换此命令执行时的 'autoindent'。

+-*/+-*/join c 连接行
							*:j* *:join*
[range]j[oin][!] [flags]
			连接 [range] 范围的行。和 "J" 相同，但如有 [!] 时，连
			接不插入或删除任何空格。如果 [range] 包括相同的开始和
			结束行，该命令不做任何事。缺省行为是连接当前行与下一
			行。{Vi: 没有 !}
			[flags] 部分可参见 |ex-flags|。

+-*/+-*/joinspaces o 连接命令在句号之后加两个空格
			*'joinspaces'* *'js'* *'nojoinspaces'* *'nojs'*
'joinspaces' 'js'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	使用连接命令时，在 '.'、'?' 和 '!' 之后插入两个空格。如果 'cpoptions'
	包含 'j' 标志位，只在 '.' 之后插入空格。
	如果不置位，只插入一个空格。
	注意: 置位 'compatible' 时，也置位此选项。


+-*/+-*/keepalt c 跟随的命令保持轮换文件不变
							*:keepalt* *:keepa*
:keepalt {cmd}		执行 {cmd}，在此期间保持当前轮换文件名不变。注意 间接
			调用的命令 (比如通过函数) 仍然可以设置轮换文件名。
			{Vi 无此功能}

+-*/+-*/later c 转到新的改变，重做
							*:lat* *:later*
:later {count}	转到 {count} 次较新的文本状态。
:later {N}s		转到大约 {N} 秒钟之后的较新的文本状态。
:later {N}m		转到大约 {N} 分钟之后的较新的文本状态。
:later {N}h		转到大约 {N} 小时之后的较新的文本状态。
:later {N}d		转到大约 {N} 天之后的较新的文本状态。

+-*/+-*/left c 左对齐行
							*:le* *:left*
:[range]le[ft] [indent]
			在 [range] 指定范围的行的文本靠左对齐。其缩进的距离可
			由 [indent] 设置 (缺省为 0)。
			{Vi 无此功能}

+-*/+-*/mode f 取得当前编辑状态
mode([expr])	返回指示当前模式的字符串。
		如果指定 [expr] 并且其值为非零的数值或非空的字符串
		(|non-zero-arg|)，返回完整模式，不然，返回第一个字母。注意 " "
		和 "0" 都是非空字符串。

			n	普通模式
			no	操作符等待模式
			v	面向字符的可视模式
			V	面向行的可视模式
			CTRL-V	面向列块的可视模式
			s	面向字符的选择模式
			S	面向行的选择模式
			CTRL-S	面向列块的选择模式
			i	插入模式
			R	替换模式 |R|
			Rv	虚拟替换模式 |gR|
			c	命令行模式
			cv	Vim Ex 模式 |gQ|
			ce	普通 Ex 模式 |Q|
			r	输入回车的提示
			rm	-- more -- 提示
			r?	|:confirm| 等等的询问
			!	执行外壳或外部命令时
		可用于 'statusline' 选项或 |remote_expr()|。在其它的多数地方，
		它总是返回 "c" 或 "n"。
		另见 |visualmode()|。


+-*/+-*/move c 移动行
:[range]m[ove] {address}			*:m* *:mo* *:move* *E134*
			把 [range] 指定的行移动到 {address} 给出的行之下。

+-*/+-*/quoteescape o 字符串里使用的转义字符
						*'quoteescape'* *'qe'*
'quoteescape' 'qe'	字符串	(缺省为 "\")
			局部于缓冲区
			{Vi 无此功能}
	字符串里用以转义引号的字符。用于 a'、a" 和 a` |a'| 这样的文本对象。
	如果字符串里找到本选项里任何一个字符，跳过下一个字符。缺省值使得文本
	"foo\"bar\\" 被认为是单个字符串。


+-*/+-*/read c 读入文件到文本
							*:r* *:re* *:read*
:r[ead] [++opt] [name]
			在光标下方插入文件 [name] (缺省: 当前文件)。
			|++opt| 说明 [++opt] 可能的取值。

+-*/+-*/redo c 重做一次撤销的改变
							*:red* *:redo* *redo*
:red[o]			重做一个被撤销的更改。		{Vi: 没有 redo}

+-*/+-*/retab c 改变制表大小
							*:ret* *:retab*
:[range]ret[ab][!] [new_tabstop]
			把所有包含 <Tab> 的空白序列替代成由新的制表位
			[new_tabstop] 确定的空白序列。如果你不指定新的制表位，
			或者它为 0，Vim 使用原来的制表位 'tabstop'。
			已有的 Tab 的宽度总是用 'tabstop' 的当前值来计算。
			如果有 !，Vim 也在合适的时候，把只包含正常空格的字符串
			换成 Tab。
			如果置位了 'expandtab'，Vim 把所有的 Tab 换成相当的空
			格。
			该命令把 'tabstop' 设为新值。如果按照缺省的情况，在全
			文件上进行处理，视觉上应该不会有任何改变。
			小心: 该命令修改 C 程序中的字符串里的任何 <Tab> 字符。
			要避免这一点，用 "\t" (无论如何，应该养成这个好的习
			惯)。
			":retab!" 也把空格序列换成 <Tab>，这可能会使 printf()
			引起混淆。
			{Vi 无此功能，仅在编译时加入 |+ex_extra| 特性才有效}

+-*/+-*/right c 右对齐文本
:[range]ri[ght] [width]					*:ri* *:right*
			在 [range] 指定范围的行和 [width] 限定的列 (缺省为
			'textwidth'，如其为 0，则取 80) 范围内的文本靠右对齐。
			{Vi 无此功能}
			只有在编译时加入 |+ex_extra| 特性时才有此功能。

+-*/+-*/rundo c 从文件里读入撤销信息
							*:wundo* *:rundo*
:wundo[!] {file}
		把撤销历史写入 {file}。
		如果 {file} 已存在而看起来不像撤销文件 (文件头部的魔术数字不
		符)，此命令失败。除非加上 !。
		如果文件存在且看起来像撤销文件，覆盖之。
		{Vi 无此功能}

+-*/+-*/setline f 替换缓冲区中的一行
setline({lnum}, {text})					*setline()*
		设置当前缓冲区第 {lnum} 行的内容为 {text}。
		{lnum} 的用法同 |getline()|。
		如果 {lnum} 刚刚在末行之下，{text} 用来增加新行。
		如果成功，返回 0。如果失败 (多数是因为 {lnum} 不合法) 返回 1。
		例如: >
			:call setline(5, strftime("%c"))
<		如果 {text} 为 |List|，那么第 {lnum} 行和其后的行被设为列表里
		的项目。例如: >
			:call setline(5, ['aaa', 'bbb', 'ccc'])
<		等价于: >
			:for [n, l] in [[5, 6, 7], ['aaa', 'bbb', 'ccc']]
			:  call setline(n, l)
			:endfor
<		注意: 这里不会设置 '[ 和 '] 位置标记。


+-*/+-*/shiftround o 缩进列数对齐到 shiftwidth 的整数倍
			*'shiftround'* *'sr'* *'noshiftround'* *'nosr'*
'shiftround' 'sr'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	缩进取整到 'shiftwidth' 的倍数。应用于 > 和 < 命令。插入模式里的
	CTRL-T 和 CTRL-D 总是把缩进取整到 'shiftwidth' 的倍数 (和 Vi 兼容)。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/shiftwidth o (自动) 缩进使用的步进单位，以空白数目计
						*'shiftwidth'* *'sw'*
'shiftwidth' 'sw'	数值型	(缺省为 8)
			局部于缓冲区
	(自动) 缩进每一步使用的空白数目。用于 |'cindent'|、|>>|、|<<| 等。


+-*/+-*/smarttab o 插入 <Tab> 时使用 'shiftwidth'
				 *'smarttab'* *'sta'* *'nosmarttab'* *'nosta'*
'smarttab' 'sta'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果打开，行首的 <Tab> 根据 'shiftwidth' 插入空白。'tabstop' 或
	'softtabstop' 用在别的地方。<BS> 删除行首 'shiftwidth' 那么多的空白。
	如果关闭，<Tab> 总是根据 'tabstop' 或 'softtabstop' 决定插入空白的数
	目。'shiftwidth' 只用于文本左移或右移 |shift-left-right|。
	插入空白的具体方式 (制表还是空格) 取决于 'expandtab' 选项。另见
	|ins-expandtab|。如果没有置位 'expandtab'，通过使用 <Tab>，使空格数目
	减到最小。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/softtabstop o 编辑时 <Tab> 使用的空格数
					*'softtabstop'* *'sts'*
'softtabstop' 'sts'	数值型	(缺省为 0)
			局部于缓冲区
			{Vi 无此功能}
	执行编辑操作，如插入 <Tab> 或者使用 <BS> 时，把 <Tab> 算作空格的数目。
	"感觉上" 你就像使用单个 <Tab> 一样，而实际上使用的是空格和 <Tab> 的混
	合。这可以用来维持 'ts' 的设置为标准值 8 不变，但编辑时感觉就像它被设
	为 'sts' 那样。不过，"x" 这样的命令仍然会在实际的字符上操作。
	如果 'sts' 为零，关闭此特性。
	如果置位 'paste' 选项，'softtabstop' 被设为 0。
	另见 |ins-expandtab|。如果没有置位 'expandtab'，通过使用 <Tab>，使空格
	数目减到最小。
	'cpoptions' 里的 'L' 标志位改变制表在 'list' 置位时的使用方式。
	注意: 如果置位 'compatible'，该选项被设为 0。


+-*/+-*/sort c 给行排序
							*:sor* *:sort*
:[range]sor[t][!] [i][u][r][n][x][o] [/{pattern}/]
			给 [range] 里的行排序。如果没有给出行范围，给所有行排
			序。

+-*/+-*/startgreplace c 开始虚拟替换模式
							*:startgreplace*
:startg[replace][!]	和 |:startreplace| 完全类似，用虚拟替换模式，和使用
			|gR| 类似。
			{Vi 无此功能}
			{仅当编译时带 |+ex_extra| 特性时才可用}

+-*/+-*/startinsert c 开始插入模式
							*:start* *:startinsert*
:star[tinsert][!]	在执行完本命令后，启动插入模式。和普通模式下输入 "i"
			类似。如果包含 !，和 "A" 类似，附加到行后。否则，就从
			光标当前位置开始插入。
			注意 在函数或者脚本里使用本命令时，插入只会在函数和脚
			本结束的时候才会开始。
			此命令不能在 |:normal| 里使用。
			{Vi 无此功能}
			{仅当编译时带 |+ex_extra| 特性时才可用}

+-*/+-*/startreplace c 开始替换模式
					*replacing-ex* *:startreplace*
:startr[eplace][!]	在执行完本命令后，启动替换模式。和普通模式下输入 "R"
			类似。如果包含 !，和 "$R" 类似 (也就是，从行尾开始替换
			模式)。否则，从光标当前位置开始替换。
			注意 在函数或者脚本里使用本命令时，替换只会在函数和脚
			本结束的时候才会开始。
			{Vi 无此功能}
			{仅当编译时带 |+ex_extra| 特性时才可用}

+-*/+-*/stopinsert c 退出插入模式
							*:stopi* *:stopinsert*
:stopi[nsert]		尽快停止插入模式。和在插入模式时输入 <Esc> 类似。可以
			用在自动命令里。示例: >
				:au BufEnter scratch stopinsert
<
					*replacing-ex* *:startreplace*
:startr[eplace][!]	在执行完本命令后，启动替换模式。和普通模式下输入 "R"
			类似。如果包含 !，和 "$R" 类似 (也就是，从行尾开始替换
			模式)。否则，从光标当前位置开始替换。
			注意 在函数或者脚本里使用本命令时，替换只会在函数和脚
			本结束的时候才会开始。
			{Vi 无此功能}
			{仅当编译时带 |+ex_extra| 特性时才可用}

+-*/+-*/t c 等同于 "":copy
							*:t*
:t			和 :copy 等价。

+-*/+-*/tabstop o <Tab> 在文件里使用的空格数
					*'tabstop'* *'ts'*
'tabstop' 'ts'		数值型	(缺省为 8)
			局部于缓冲区
	文件里的 <Tab> 代表的空格数。另见 |:retab| 命令和 'softtabstop' 选项。

	注意: 设置 'tabstop' 为不同于 8 的值可能使你的文件在很多地方看起来不正
	确 (比如，打印时)。

	Vim 里有四个主要的使用制表的方法:
	1. 总是保持 'tabstop' 为 8，设置 'softtabstop' 和 'shiftwidth' 为 4
	   (或 3 或任何你想要的) 然后用 'noexpandtab'。这时，Vim 使用制表和空
	   格的混合，但输入 <Tab> 或 <BS> 键就像每个制表占用 4 (或 3) 个字符一
	   样。
	2. 设置 'tabstop' 和 'shiftwidth' 为想要的任何值，然后用 'expandtab'。
	   这样，你总是插入空格。改变 'tabstop' 时绝不会影响排版。
	3. 设置 'tabstop' 和 'shiftwidth' 为想要的任何值，然后用 |modeline|，
	   再次编辑时就会重新设置这些值。这只适用于总是使用 Vim 进行文件编辑的
	   情况。
	4. 永远把 'tabstop' 和 'shiftwidth' 设为相同的值，并用 'noexpandtab'。
	   这样，就可以 (只适用于行首的缩进) 使用任何别人的制表位设置。不过，
	   如果你这么做，最好在第一个非空白字符之后想插入制表时以空格代替。否
	   则，改变 'tabstop' 时，注释等的对齐会不正确。


+-*/+-*/textwidth o 插入文本的最大宽度
						*'textwidth'* *'tw'*
'textwidth' 'tw'	数值型	(缺省为 0)
			局部于缓冲区
			{Vi 无此功能}
	插入文本的最大宽度。更长的行会在空白之后截断，以达到此宽度。设为零关闭
	此项功能。置位 'paste' 选项把 'textwidth' 设为 0。如果 'textwidth' 为
	零，可以使用 'wrapmargin'。另见 'formatoptions' 和 |ins-textwidth|。
	如果置位 'formatexpr'，用它来断开行。
	注意: 如果置位 'compatible'，该选项被设为 0。


+-*/+-*/undo c 撤销最近的改变
							*:u* *:un* *:undo*
:u[ndo]			撤销一次更改。  		{Vi: 仅有一级}

+-*/+-*/undojoin c 将下一个改变和上一个撤销块合并
						*:undoj* *:undojoin* *E790*
:undoj[oin]		把其后的改变和以前的撤销块进行合并。
			警告: 小心使用。它会阻止用户合理地撤销改变。不要在撤销
			或重做后使用。
			{Vi 无此功能}

+-*/+-*/undolist c 列出撤销树的叶结点
							*:undol* *:undolist*
:undol[ist]		列出改变树的所有叶结点。例如:

+-*/+-*/vglobal c 对不匹配的行，执行命令
							*:v* *:vglobal*
:[range]v[global]/{pattern}/[cmd]
			等同于 :g!。

+-*/+-*/virtualedit o 何时使用虚拟编辑
					    *'virtualedit'* *'ve'*
'virtualedit' 've'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+virtualedit| 特性才有效}
	逗号分隔的下面单词的列表:
	    block	允许可视列块模式的虚拟编辑。
	    insert	允许插入模式的虚拟编辑。
	    all		允许所有模式的虚拟编辑。
	    onemore	允许光标移动到刚刚超过行尾的位置

	虚拟编辑意味着光标可以定位在没有实际字符的地方。这可以是制表的中间，也
	可以是行尾之后的位置。可用于在可视模式下选择一个方块，还有表格的编辑。
	"onemore" 不同，它只允许光标移动到刚刚超过行尾字符之后的位置。这使得有
	些命令更加一致。以前，在空行上光标总是刚刚超过行尾。但这和 Vi 远远不兼
	容，而且也有可能使一些插件或 Vim 脚本不能工作，比如因为 |l| 可以移动光
	标到行尾字符之后。小心使用！
	|$| 命令总是移动到行尾字符上，而不是超过它。这使光标可能实际向左移动！
	组合使用 "all" 和 "onemore" 没有意义，但你不会因此得到警告。


+-*/+-*/visualmode f 最近一次使用过的可视模式
visualmode([expr])						*visualmode()*
		返回字符串，它描述当前缓冲区最近使用的可视模式。一开始，它返回
		空字符串，一旦使用了可视模式，返回 "v"、"V" 或 "<CTRL-V>" (单
		个 CTRL-V 字符)，分别代表面向字符、面向行、和面向列块的可视模
		式。
		例如: >
			:exe "normal " . visualmode()
<		进入和上次相同的可视模式。也可以用于在脚本里根据最近的可视模式
		采取不同的行动。
		如果当前正处于可视模式中，|mode()| 可得到具体的可视模式 (例如
		在 |:vmap| 中可用)。
							*non-zero-arg*
		如果提供 [expr] 并且计算结果是非零数值或者是非空字符串，那么将
		清除可视模式，并返回旧的值。注意 " " 和 "0" 也是非空字符串，所
		以也会清除该模式。列表、字典或浮点数不是数值或字符串，所以不会
		清除该模式。

							*winbufnr()*
+-*/+-*/wundo c 把撤销信息写入文件
							*:wundo* *:rundo*
:wundo[!] {file}
		把撤销历史写入 {file}。
		如果 {file} 已存在而看起来不像撤销文件 (文件头部的魔术数字不
		符)，此命令失败。除非加上 !。
		如果文件存在且看起来像撤销文件，覆盖之。
		{Vi 无此功能}

+-*/file _ 文件
+-*/+-*/X c 请求加密密钥
							*:X*
:X	提示加密密钥。输入时不会反显输入的内容。别人即使看到屏幕，也不能看见你
	的密钥。输入的字符保存在 'key' 选项里，它的值用来在写入文件时加密该文
	件。在写入之前，该文件保持不变。另见 |-x|。

+-*/+-*/all c 为参数列表的每个文件打开一个窗口
:[N]al[l][!] [N]				*:al* *:all* *:sal* *:sall*
:[N]sal[l][!] [N]
		重新整理屏幕，为每一个参数打开一个窗口。其它窗口统统关闭。如果
		使用了计数，则其数值为窗口数目的最大值。
		如果带 |:tab| 修饰符，为每个参数打开一个标签页。如果参数数目多
		于 'tabpagemax'，多余参数成为最后一个标签页的分割窗口。
		如果设置了 'hidden'，所有要关闭的窗口变为隐藏。
		如果没有设置 'hidden'，但是设置了 'autowrite'，那么所有改动
		的缓冲区被写入文件。否则，包含更改过的缓冲区的窗口不会被删除，
		除非你用 [!] 使它们隐藏。更改过的缓冲区永远不会被丢弃，所以改
		动不会丢失。
		[N] 是最大可以打开的窗口数。'winheight' 也限制打开的窗口数。
		(如果前加了 |:vertical| 的话 'winwidth')。
		Buf/Win Enter/Leave 自动命令不会被这里的新窗口执行，只有在它
		们真正进入时才会执行。

+-*/+-*/argument c 转到参数列表一个指定的文件
							*:argu* *:argument*
:[count]argu[ment] [count] [++opt] [+cmd]
			编辑参数列表里的第 [count] 个文件。在忽略 [count] 的时
			候，编辑当前入口项。如果已经作了修改而 vim 不能放弃
			|abandon| 当前的缓冲区，该命令失败。
			另见 |++opt| 和 |+cmd|。
			{Vi 无此功能} {仅当编译时加入 |+listcmds| 特性才有效}

+-*/+-*/autoread o 有 Vim 之外的改动时自动重读文件
				 *'autoread'* *'ar'* *'noautoread'* *'noar'*
'autoread' 'ar'		布尔型	(缺省关闭)
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	如果发现文件在 Vim 之外修改过而在 Vim 里面没有的话，自动重新读入。
	如果文件在外部被删除，不会这么做。|timestamp|
	如果该选项有局部值，使用下面的命令切换回直接使用全局值: >
		:set autoread<
<

+-*/+-*/autowrite o 有改动时自动写回文件
				 *'autowrite'* *'aw'* *'noautowrite'* *'noaw'*
'autowrite' 'aw'	布尔型	(缺省关闭)
			全局
	自动把内容写回文件: 如果文件被修改过，在每个 :next、:rewind、:last、
	:first、:previous、:stop、:suspend、:tag、:!、:make、CTRL-] 和 CTRL-^
	命令时进行；用 :buffer、CTRL-O、CTRL-I、'{A-Z0-9} 或 `{A-Z0-9} 命令转
	到别的文件时亦然。
	注意 有些命令不使用 'autowrite' 选项。为此目的，可用 'autowriteall'。


+-*/+-*/autowriteall o 类似于 'autowrite'，但适用于更多命令
			 *'autowriteall'* *'awa'* *'noautowriteall'* *'noawa'*
'autowriteall' 'awa'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	和 'autowrite' 类似，但也适用于 ":edit"、":enew"、":quit"、":qall"、
	":exit"、":xit"、":recover" 和关闭 Vim 窗口。
	置位本选项也意味着 Vim 的行为就像打开 'autowrite' 一样。


+-*/+-*/backup o 覆盖文件时保留备份文件
				*'backup'* *'bk'* *'nobackup'* *'nobk'*
'backup' 'bk'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	覆盖文件前创建一个备份。文件成功写入后保留该备份。如果你不想保留备份文
	件，但希望写入期间能有备份，复位该选项并置位 'writebackup' 选项
	(这是缺省行为)。如果你完全不想要备份文件，同时复位两个选项 (如果你的文
	件系统差不多满了，这会有用)。更多的解释可见 |backup-table|。
	如果匹配 'backupskip' 模式，无论如何都不会建立备份。
	如果设置 'patchmode'，备份文件会换名成为文件的旧版本。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/backupcopy o 文件备份使用复制而不是换名
						*'backupcopy'* *'bkc'*
'backupcopy' 'bkc'	字符串	(Vi 在 Unix 上的缺省: "yes"，否则: "auto")
			全局
			{Vi 无此功能}
	写回文件并建立备份时，本选项指定它应如何完成。这是逗号分隔的单词列表。

	主要的值是:
	"yes"	复制文件，然后覆盖原来的文件
	"no"	给文件换名，然后写入一个新文件
	"auto"	两者哪个更好就用哪个

	可以和上面的一起使用的附加设置包括:
	"breaksymlink"	写入时总是断开符号链接
	"breakhardlink"	写入时总是断开硬链接

	复制文件并覆盖原来的文件:
	- 需要额外的时间复制文件。
	+ 如果文件有特殊属性，是 (硬 / 符号) 链接或者有资源分叉 (resource
	  fork)，都能保存下来。
	- 如果文件是一个链接，备份文件名使用链接的名字，而不是实际文件的。

	给文件换名并写入新文件:
	+ 很快。
	- 有时不是所有的文件属性都能被复制到新文件里。
	- 如果文件是链接，新文件将不再是链接。

	"auto" 值是一个折衷: 如果 Vim 看到文件换名可以没有副作用 (属性可以被传
	递而文件也不是链接)，就使用换名方式。如果遇到问题，就使用复制方式。

	"breaksymlink" 和 "breakhardlink" 值可以和 "yes"、"no" 以及 "auto" 中
	的任何一个混合使用。如果包含，它们迫使 Vim 总是使用 "no" 选项完全相同
	的步骤断开符号链接或者硬链接: 给原来的文件换名并成为备份文件，在原来文
	件的位置写入新的文件内容。这可以用于，比如说，所有的文件或者是符号链接
	或者是硬链接的源代码树。这样，任何的改变都应该会保留在本地源代码树中，
	而不影响原来的代码。
							*crontab*
	一种情形下 "no" 和 "auto" 可能会有问题: 一个程序打开文件、启用 Vim 编
	辑该文件、然后测试已打开的文件是否发生改变 (通过文件描述符)。该测试总
	是会检查备份文件而不是新建立的文件。"crontab -e" 就是这样一个例子。

	用复制方式时，原来的文件会被清空，然后填入新的文本。这意味着保护位、拥
	有者和原来文件的符号链接都保持不变。但备份文件是一个新的文件，拥有者是
	编辑文件的人，所在的组是原来文件所在的组。如果这不行，组的保护位设得和
	其它人 (非用户和组成员) 的保护位相同。

	如果文件被换名，事情就刚好相反: 备份文件有着和原来文件相同的属性，而新
	写的文件由当前用户拥有。如果文件曾是 (硬/符号) 链接，新文件不再是了！
	这就是为什么 "auto" 值不为链接文件换名的原因。新写入文件的拥有者和所属
	组会设得和原来的文件相同。但系统可能拒绝这么做，这种情形下，"auto" 值
	仍然会选择不用换名方式。


+-*/+-*/backupdir o 备份文件使用的目录列表
						*'backupdir'* *'bdir'*
'backupdir' 'bdir'	字符串	(Amiga 的缺省: ".,t:"，
				 MS-DOS 和 Win32: ".,c:/tmp,c:/temp"
				 Unix: ".,~/tmp,~/")
			全局
			{Vi 无此功能}
	逗号分隔的备份文件的目录名列表。
	- 备份文件会在第一个可能的目录里建立。该目录必须已经存在，Vim 不会帮你
	  建立该目录。
	- 空意味着不会建立备份文件 ('patchmode' 是不会工作的！)。写入也可能
	  因此而失败。
	- 目录 "." 意味着把备份文件放在被编辑文件的相同目录里。
	- "./" (或 MS-DOS 等环境的 ".\") 开始的目录意味着把备份文件放在被编辑
	  文件所在的相对位置。开头的 "." 由被编辑文件的路径名替换。
	  (目录中间的 "." 没有特殊含义)。
	- 逗号之后的空格被忽略，其它的空格视为目录名的一部分。要在目录命令开头
	  包含空格，在它之前加入反斜杠。
	- 要在目录名包含逗号，在它之前加入反斜杠。
	- 目录名可以用 '/' 结尾。
	- 环境变量被扩展 |:set_env|。
	- 小心使用 '\' 字符，在空格前输入一个，真正的反斜杠前要输入两个 (见
	  |option-backslash|)。例如: >
	    :set bdir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
<	- 为了和 Vim 3.0 版本后向兼容，本选项开头的 '>' 被删除。
	另见 'backup' 和 'writebackup' 选项。
	如果你需要在 Unix 上隐藏备份文件，考虑这样的值: >
		:set backupdir=./.backup,~/.backup,.,/tmp
<	要使之正确工作，你需要在每个目录和你的主目录里建立 ".backup" 目录。
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减目录。这可以避免未来版本使
	用其它缺省值出现的问题。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/backupext o 备份文件使用的扩展名
						*'backupext'* *'bex'* *E589*
'backupext' 'bex'	字符串	(缺省为 "~"，VMS 上: "_")
			全局
			{Vi 无此功能}
	附加到文件名后面的字符串，以构造备份文件的名字。缺省值很特别，因为它可
	以避免不小心覆盖已有的且带有备份的文件。你可能喜欢使用 ".bak"，但要确
	保不存在已经带有 ".bak" 而且你想保留的文件。
	只能使用普通的文件名字符。"/\*?[|<>" 都不合法。

	如果你喜欢保留很多备份，可以用 BufWritePre 自动命令，使之在写入文件前
	改变 'backupext'，以包含写入的时间。 >
		:au BufWritePre * let &bex = '-' . strftime("%Y%b%d%X") . '~'
<	'backupdir' 可用来把备份放在不同的目录里。


+-*/+-*/backupskip o 匹配这些模式的文件不予备份
						*'backupskip'* *'bsk'*
'backupskip' 'bsk'	字符串	(缺省: "/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+wildignore| 特性才有效}
	文件名模式列表。如果其中某个模式匹配要写入的文件名，不建立它的备份文
	件。同时测试指定的文件名和它的完整路径名。模式的使用方式和 |:autocmd|
	类同，见 |autocmd-patterns|。
	小心特殊字符，见 |option-backslash|。
	如果没有定义 $TMPDIR、$TMP 或 $TEMP，缺省值就不包含它们。"/tmp/*" 只用
	于 Unix。

	注意 这里不扩展环境变量。如果你想要用 $HOME，必须显式地对其扩展，例
	如: >
		:let backupskip = escape(expand('$HOME'), '\') . '/tmp/*'

<	注意 缺省值也确保 "crontab -e" 能工作 (如果给原来文件换名来建立备份，
	crontab 不会看到新建立的文件)。另见 'backupcopy' 和 |crontab|。


+-*/+-*/confirm o 询问如何处理未保存/只读的文件
				*'confirm'* *'cf'* *'noconfirm'* *'nocf'*
'confirm' 'cf'		布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
	如果 'confirm' 打开，一些通常因为缓冲区有未保存的改变而失败的操作，比
	如 ":q" 和 ":e"，会弹出对话框 |dialog|，询问你是否想保存当前 (一个或多
	个) 文件。你仍然可以使用 ! 来无条件放弃 |abandon| 缓冲区。
	如果 'confirm' 关闭，你仍然可以通过 |:confirm| 命令为单个命令启动确认
	机制 (常用于映射)。
	另见 |confirm()| 函数和 'guioptions' 的 'v' 标志位。


+-*/+-*/cryptmethod o 文件写入时所用的加密方法
						*'cryptmethod'* *'cm'*
'cryptmethod'		字符串	(缺省为 "zip")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	把缓冲区写入到文件时所用的加密方法:
							*pkzip*
	zip		PkZip 兼容方法。加密较弱。和 Vim 7.2 和之前版本兼容。
							*blowfish*
	blowfish	Blowfish 方法。加密较强。需要 Vim 7.3 或之后版本，文件
			_不_能用 Vim 7.2 或之前版本读出。文件中包含一个加密用
			的 "种子"，所以每次写入文件时加密后的字节都会不相同。

	读入加密文件时，'cryptmethod' 会自动设为检测到的读入文件所用之方法。这
	样在写入文件时，如果不手动改变 'cryptmethod'，会采用之前的方法。
	改变 'cryptmethod' 并不会自动使文件标为已改动，你需要显式写入文件才会
	生效。除非有其它修改，你不会得到警告。另见 |:X|.

	如果设置全局值为空字符串，等同 "zip"。如果设置局部值为空字符串，使用全
	局值。

	如果新版本 Vim 加入其它加密方法而当前版本不支持的话，会得到 *E821* 。
	需要使用更新的 Vim 版本来编辑该文件。



+-*/+-*/did_filetype f 检查某文件类型自动命令是否已经使用
did_filetype()	如果执行自动命令时，激活 FileType 事件至少一次，则返回非零。可
		以用于防止在检测文件类型的脚本里再次激活 FileType 事件。
		|FileType|
		如果编辑另外一个文件，该计数被复位，因而这只能检查 FileType 事
		件是否在当前缓冲区里激活过。它允许开始编辑另一个缓冲区的自动命
		令设置 'filetype' 并载入语法文件。


+-*/+-*/edit c 编辑文件
							*:e* *:edit*
:e[dit] [++opt] [+cmd]	编辑当前文件。可用于在它被 Vim 之外的程序所改变的时候
			重新编辑当前文件。 如果当前缓冲区已经被修改而且没有置
			位 'autowriteall'，或者文件不能被写入，本命令失败。
			另见 |++opt| 和 |+cmd|。
			{Vi: 无 ++opt}

+-*/+-*/endofline o 文件最后一行写入换行符 <EOL>
			*'endofline'* *'eol'* *'noendofline'* *'noeol'*
'endofline' 'eol'	布尔型	(缺省打开)
			局部于缓冲区
			{Vi 无此功能}
	写入文件时如果关闭本选项并且打开 'binary' 选项，文件的末行不写入
	<EOL>。编辑新文件时自动打开本选项，除非该文件的末行本没有 <EOL>，那时
	本选项被复位。通常你不需要自己置位或者复位本选项。如果 'binary' 关闭，
	写入文件时不使用本值。如果 'binary' 打开，本值被用于记住文件末行是否存
	在 <EOL>，这样在写回文件时，就不会改变原来文件的使用方式。不过如果你愿
	意改变之，可自便。


+-*/+-*/ex c 等同于 "":edit
							*:ex*
:ex [++opt] [+cmd] [file]
			和 |:edit| 相同。

+-*/+-*/file c 显示或者设置当前文件名
CTRL-G		或				*CTRL-G* *:f* *:fi* *:file*
:f[ile]			显示当前文件名 (如同输入的那样，除非使用过 ":cd")、光
			标位置 (除非置位了 'ruler' 选项) 和文件状态 (只读、已
			修改、读入错误、新文件)。参见 'shortmess' 选项，了解如
			何可以简化该消息。 {Vi 不包括列号}

+-*/+-*/fileformat o 文件输入输出使用的格式
					*'fileformat'* *'ff'*
'fileformat' 'ff'	字符串 (MS-DOS、MS-Windows、OS/2 的缺省: "dos"，
				Unix 缺省: "unix"，
				Macintosh 缺省: "mac")
			局部于缓冲区
			{Vi 无此功能}
	给出当前缓冲区的 <EOL> 格式，用于从文件读入缓冲区和把缓冲区写回文件:
	    dos	    <CR> <NL>
	    unix    <NL>
	    mac	    <CR>
	如果使用 "dos"，文件尾的 CTRL-Z 被忽略。
	见 |file-formats| 和 |file-read|。
	文件使用的字符编码见 'fileencoding'。
	如果设置 'binary'，忽略 'fileformat' 的值。文件输入/输出如同它被设为
	"unix' 那样。
	文件开始编辑时，如果 'fileformats' 非空而 'binary' 关闭，本选项被自动
	设置。
	开始编辑文件后，如果设置该选项，'modified' 选项被置位，因为文件被认为
	和当初写入时已经不同。
	本选项在 'modifiable' 关闭时不能改变。
	为了后向兼容: 如果本选项设为 "dos"，置位 'textmode'，否则，复位之。


+-*/+-*/fileformats o 参与自动检测的 'fileformat' 的格式
					*'fileformats'* *'ffs'*
'fileformats' 'ffs'	字符串 (缺省:
				Vim+Vi	MS-DOS、MS-Windows OS/2: "dos,unix"，
				Vim	Unix: "unix,dos"，
				Vim	Mac: "mac,unix,dos"，
				Vi	Cygwin: "unix,dos"，
				Vi	其它: "")
			全局
			{Vi 无此功能}
	给出换行符 (<EOL>) 的格式，开始编辑新缓冲区或者读入文件到已有的缓冲区
	时，尝试这些格式:
	- 如果为空，总是使用 'fileformat' 定义的格式。不自动设置该选项。
	- 如果设为一个名字，总是为打开的新缓冲区使用该格式，也为该缓冲区相应地
	  设置 'fileformat'。文件读入已有的缓冲区时，使用 'fileformats' 给出的
	  名字，不管该缓冲区设定的 'fileformat' 是什么。
	- 如果给出多于一个以逗号分隔的名字，读入文件时会进行自动 <EOL> 检测。
	  开始编辑文件时，这样检查 <EOL>:
	  1. 如果所有行都以 <CR><NL> 结尾，而 'fileformats' 包含 "dos" 的话，
	     'fileformat' 设为 "dos"。
	  2. 如果找到一个 <NL> 而 'fileformats' 包含 "unix" 的话，'fileformat'
	     设为 "unix"。注意 如果找到的 <NL> 没有前导 <CR>，"unix" 比 "dos"
	     优先。
	  3. 如果 'fileformats' 包含 "mac"，'fileformat' 设为 "mac"。这意味着
	     "mac" 只有在没有给出 "unix" 或者在文件里没有找到 <NL>，并且没有给
	     出 "dos" 或者没有在文件里找到 <CR><NL> 时才会使用。
	     如果先选择 "unix"，但第一个 <CR> 出现在第一个 <NL> 之前，而文件里
	     的 <CR> 比 <NL> 多的话，'fileformat' 也设为 "mac"。
	  4. 如果还是不能设置 'fileformat'，使用 'fileformats' 的第一个名字。
	  读入文件到已有的缓冲区时，完成相同的步骤，但如同 'fileformat' 已经为
	  该文件合适地设置过，不改变该选项。
	如果置位 'binary'，不使用 'fileformats' 的值。

	对于使用 DOS 类型的 <EOL> (<CR><NL>) 的系统来说，读入待执行的脚本
	(":source") 或者 vimrc 文件时，可能进行自动 <EOL> 的检测:
	- 如果 'fileformats' 为空，没有自动检测。使用 DOS 格式。
	- 如果 'fileformats' 设为一到多个名字，进行自动检测。它基于文件中的第
	  一个 <NL>: 如果在它之前有一个 <CR>，使用 DOS 格式，不然，使用 Unix
	  格式。
	另见 |file-formats|。
	为了后向兼容: 如果设置此选项为空字符串或者单一格式 (没有包含逗号)，复
	位 'textauto'，否则置位 'textauto'。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/filetype o 自动命令使用的文件类型
					*'filetype'* *'ft'*
'filetype' 'ft'		字符串 (缺省: "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+autocmd| 特性才有效}
	如果设置此选项，激活 FileType 自动命令事件。执行所有匹配本选项值的自动
	命令。这时，使用 'filetype' 的值匹配而不是文件名。
	否则，本选项不总是反映当前的文件类型。
	通常，在检测到文件类型时设置此选项。要打开这一功能，使用 ":filetype
	on" 命令。|:filetype|
	对于不能自动识别文件类型的文件而言，在模式行里设置此选项是最有用的。比
	如对于 IDL 文件:
		/* vim: set filetype=idl : */ ~
	|FileType| |filetypes|
	如果选项值里有句号，它分隔两个名字。例如:
		/* vim: set filetype=c.doxygen : */ ~
	先使用 "c" 文件类型，再使用 "doxygen" 文件类型。这既适用于文件类型插
	件，也适用于语法文件。句号可以多于一个。
	不要把本选项和 'osfiletype' 混淆。后者设定实际和文件一起存贮的文件类
	型。
	不管 'cpoptions' 里是否包含 's' 或 'S' 标志位，本选项不会复制到别的缓
	冲区。
	只能使用普通的文件名字符。"/\*?[|<>" 都不合法。


+-*/+-*/filetype c 切换文件类型检测的打开/关闭
							*:filetype* *:filet*
要打开文件类型的检测，在你的 vimrc 里加入以下命令: >
	:filetype on
每次一个新的或者已经存在的文件被编辑时，Vim 会试图识别文件的类型，并设置
'filetype' 选项。同时，也触发 FileType 事件。该事件可以设置语法高亮，特定选
项，等等。

+-*/+-*/find c 在 'path' 里找寻文件并编辑之
							*:fin* *:find*
:fin[d][!] [++opt] [+cmd] {file}
			在 'path' 里找到 {file}，然后编辑 |:edit| 它。
			{Vi 无此功能} {仅当编译时加入 |+file_in_path| 特性才有
			效}

+-*/+-*/fnamemodify f 改变文件名
fnamemodify({fname}, {mods})				*fnamemodify()*
	根据 {mods} 修改文件名 {fname}。{mods} 是一个字符序列组成的字符串，
	就像命令行上使用的文件名那样。
	例如: >
			:echo fnamemodify("main.c", ":p:h")
<	返回: >
			/home/mool/vim/vim/src
<	注意: 环境变量不能用于 {fname}，需要先用 |expand()| 扩展。

	:p	给出文件名的全路径。
	:8	将路径转换为 8.3 短格式 (目前仅适用于 win32)。
	:~	如果可能，路径名缩减为基于主目录的相对路径。
	:.	如果可能，路径名缩减为基于当前目录的相对路径。
		要想尽可能缩减，可使用 ":~:." 。
	:h	文件名的头部 (除去文件名的最后一部分以及路径分隔符)。
		不能与 :e，:r 或 :t 一起使用。
		可以被重复使用来删除后面的多个部分。
		如果文件名以一个路径分隔符结尾，仅删除该分隔符。这样一个目录
		名的 ":p:h" 结果是目录名本身 (没有后面的斜杠)。
	:t	文件名的尾部 (文件名的最后一部分)。必须在 :r 或 :e 之前。
	:r	文件名的根部 (除去最后的扩展名)。如果只有扩展名 (文件名以 '.' 
		开始，例如，".vimrc")，则不会被删除。可以重复使用，以删除多个
		扩展名 (最后一个先被删除)。
	:e	扩展名。只有单独使用时才有意义。
	:s?pat?sub?
		用 "sub" 代替第一次出现的 "pat"。这类似于 |:s| 命令。"pat" 是
		一个正则表达式。
		可以用其它字符代替 '?'，只要该字符不出现在 "pat" 或 "sub" 里。
		在此之后，上述的修饰符可以再次使用。例如 ":p"，是替换之后的完
		整路径。
	:gs?pat?sub?
		用 "sub" 替换所有的 "pat"。其余和 ":s" 一样。


+-*/+-*/haslocaldir f 检查当前窗口是否使用过 |:lcd|
haslocaldir()						*haslocaldir()*
		返回数值，如果当前窗口用 |:lcd| 设置过本地路径则为 1，不然为
		零。


+-*/+-*/key o 加密密钥
							*'key'*
'key'			字符串	(缺省为 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+cryptv| 特性才有效}
	用于加密和解密当前缓冲区的密钥。见 |encryption| 和 'cryptmethod'。
	小心: 不要手动设置 key 的值，别人也许看到你输入的密钥。用 |:X| 命令。
	不过你可以手动设 'key' 为空: >
		:set key=
<	不能用 ":set key" 或 "echo &key" 得到本选项的值。以防本来不应该知道的
	人能够看到。这也意味着一旦设置以后，你自己也无法看到，小心不要输错！


+-*/+-*/modeline o 在文件开头或结尾识别模式行
				   *'modeline'* *'ml'* *'nomodeline'* *'noml'*
'modeline' 'ml'		布尔型	(Vim 缺省: 打开 (root 用户则为关闭)
				 Vi 缺省: 关闭)
			局部于缓冲区

+-*/+-*/modelines o 模式行的检查行数
						*'modelines'* *'mls'*
'modelines' 'mls'	数值型	(缺省为 5)
			全局
			{Vi 无此功能}
	如果 'modeline' 打开，'modelines' 给出检查 set 等命令的行数目。如果
	'modeline' 关闭或者 'modelines' 为零，不检查任何行。见 |modeline|。
	注意: 如果置位 'compatible'，'modeline' 被设为 Vi 的缺省值。相反，如果
	复位 'compatible'，它被设为 Vim 的缺省值。


+-*/+-*/patchmode o 保留文件最老的版本
						*'patchmode'* *'pm'* *E206*
'patchmode' 'pm'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	如果非空，文件的旧版本被保存。在源代码发布中可以用来修改文件并保持文件
	的旧版本。只有第一次写入文件时，才保存原始文件的备份。备份的名字是原始
	文件的名字加上 'patchmode' 选项的值。该选项必须是以句号开始的字符串，
	形如 ".org"。需要 'backupdir' 不为空 (细节: 新文件成功写入后，备份文件
	被换名为 patchmode 文件。这就是为什么必须可以写备份文件的原因)。如果没
	有文件需要备份 (原来文件不存在)，建立空文件。
	如果匹配 'backupskip' 模式，不建立 patchmode 文件。
	在压缩文件上使用 'patchmode' 会把后缀附加在压缩文件名的后面 (比如，
	"file.gz.orig")，产生的文件名不一定能被识别为压缩文件。
	只能使用普通的文件名字符。"/\*?[|<>" 都不合法。


+-*/+-*/pathshorten f 缩短路径里的目录名
pathshorten({expr})					*pathshorten()*
		缩短路径 {expr} 里的目录名，返回其结果。路径的尾部，即文件名，
		保持不变。路径的其余部分被缩短为单个字符。保持每个部分引导的
		'~' 和 '.' 字符不变。例如: >
			:echo pathshorten('~/.vim/autoload/myfile.vim')
<			~/.v/a/myfile.vim ~
		该路径实际存在与否并不相干。


+-*/+-*/preserve c 写入所有文本到交换文件
					*:pre* *:preserve* *E313* *E314*
:pre[serve]		把缓冲区中的所有文本写入交换文件中。这样在文件恢复时就
			不再需要原文件了。
			本命令设置了当前缓冲区的一个标志位。如果 'cpoptions'
			里有 '&' 标志位而且 Vim 退出时如果此缓冲区还处于载入状
			态，不删除此缓冲区的交换文件 |cpo-&|。
			{Vi: 也可能退出}

+-*/+-*/readfile f 读入文件到一个行列表
readfile({fname} [, {binary} [, {max}]])
		读入文件 {fname} 并返回 |List|。，文件每行一项。在 NL 字符处断
		开行。以 CR 分隔的 Macintosh 文件会返回单个长行 (除非某处出现
		了 NL)。
		所有的 NUL 字符被 NL 字符替代。
		如果 {binary} 等于 "b"，使用二进制模式:
		- 如果末行以 NL 结尾，附加额外的一个空列表项。
		- 不删除 CR 字符。
		否则:
		- NL 之前的 CR 字符被删除。
		- 末行是否以 NL 结尾没有影响。
		- 'encoding' 如是 Unicode 编码，删除文本可能有的 UTF-8 字节顺
		  序标识。
		如果给出 {max}，指定读入的最大行数。可用于只想检查文件开始十行
		这样的场合: >
			:for line in readfile(fname, '', 10)
			:  if line =~ 'Date' | echo line | endif
			:endfor
<		如果 {max} 为负，返回从文件尾部起算 -{max} 行，有多少算多少。
		如果 {max} 为零，返回空列表。
		注意 如果没有 {max}，把整个文件读到内存。
		也要 注意 这里不识别编码。如果需要，把文件读到缓冲区里。
		如果文件不能打开，给出错误信息，并返回空列表。
		另见 |writefile()|。


+-*/+-*/recover c 从交换文件里恢复文件
					*:rec* *:recover* *E305* *E306* *E307*
:rec[over] [file]	试图从交换文件中恢复 [file]。如果没有指定 [file]，使用
			当前缓冲区的文件名。当前缓冲区中的内容会丢失。如果缓冲
			区已经被修改，此命令失效。

+-*/+-*/saveas c 用别的名字保存文件。
							*:sav* *:saveas*
:sav[eas][!] [++opt] {file}
			用文件名 {file} 保存当前缓冲区，并设置当前缓冲区的文件
			名为 {file}。前一个名字用作轮换文件名。[!] 用以覆盖已
			存在的文件。
			如果 'filetype' 为空，在写入文件前用新名字进行文件类型
			检测。
			如果写操作成功，复位 'readonly'。
			{Vi 无此功能}

+-*/+-*/setfiletype c 设置 'filetype'，除非已经设置过
:setf[iletype] {filetype}			*:setf* *:setfiletype*
			把 'filetype' 选项设为 {filetype}。但如果已经在 (嵌套)
			自动命令序列中设置过，就不再进行。
			等价于下面代码的缩写: >
				:if !did_filetype()
				:  setlocal filetype={filetype}
				:endif
<			在一个 filetype.vim 里使用该命令可避免设置 'filetype' 
			选项两次，导致不同的设置和语法文件被载入。
			{Vi 无此功能}

+-*/+-*/simplify f 简化路径，不改变其含义
simplify({filename})					*simplify()*
		在不改变含义的前提下，尽可能简化文件名。快捷方式 (MS-Windows
		上) 或者符号链接 (Unix 上) 不会被解析。如果 {filename} 第一个
		路径部分指定了当前目录，结果也会是如此。而结尾的路径分隔符也不
		会被删除。
		示例: >
			simplify("./dir/.././/file/") == "./file/"
<		注意: 组合 "dir/.." 只有在 "dir" 是可以遍历的或者不存在的目录
		才会被删掉。Unix 上，如果 "dir" 是同一目录下的符号链接，也会删
		除该组合。为了在简化路径名之前解析所有牵涉到的符号链接，使用
		|resolve()|。



+-*/+-*/swapfile o 缓冲区是否使用交换文件
				*'swapfile'* *'swf'* *'noswapfile'* *'noswf'*
'swapfile' 'swf'	布尔型 (缺省打开)
			局部于缓冲区
			{Vi 无此功能}
	缓冲区使用交换文件。如果不想为特定缓冲区使用交换文件，可以复位本选项。
	例如，包含即使 root 也不应得到的机密信息。要小心: 所有的文本都在内存:
		- 不要在大文件里使用。
		- 无法恢复！
	交换文件只有在 |'updatecount'| 不为零并且置位 'swapfile' 时才会存在。
	复位 'swapfile' 时，立即删除当前缓冲区的交换文件。如果置位 'swapfile'
	并且 'updatecount' 非零，立即建立交换文件。
	另见 |swap-file| 和 |'swapsync'|。

	此选项可以和 'bufhidden' 和 'buftype' 一起使用，指定特殊类型的缓冲区。
	见 |special-buffers|。


+-*/+-*/swapname c 显示当前交换文件的名字
	:sw[apname]					*:sw* *:swapname*

+-*/+-*/swapsync o 和交换文件同步的方式
						*'swapsync'* *'sws'*
'swapsync' 'sws'	字符串	(缺省为 "fsync")
			全局
			{Vi 无此功能}
	如果此选项非空，写入交换文件后同步到磁盘上。这需要一点时间，尤其在繁忙
	的 unix 系统上。
	如果此选项为空，交换文件的部分内容可能在内存里，还没写回磁盘上。如果系
	统崩溃，你可能会丢失更多的工作。
	Unix 上，系统时不时进行同步，无须 Vim 请求。所以关闭此选项的缺点很少。
	有的系统上，交换文件完全不会被写入。在 Unix 系统上，设置它为 "sync" 会
	使用 sync() 调用而不是缺省的 fsync()，在有的系统上这样做可能效果更好。
	'fsync' 选项用于实际文件上。


+-*/+-*/undofile f 取得相关的撤销文件名
undofile({name})					*undofile()*
		返回用于名为 {name} 的文件的撤销文件名。使用 'undodir' 选项并
		寻找实际存在的目录。并不检查该撤销文件是否存在。
		{name} 总是扩展为完整路径，因为内部是这么使用的。
		可用于 |:wundo| 和 |:rundo|。
		如果编译时没有 +persistent_undo 选项，总是返回空字符串。


+-*/+-*/undotree f 撤销文件树
undotree()						*undotree()*
		返回撤销树的当前状态。返回值是包含以下项目的字典:
		  "seq_last"	最大使用的撤销序列号。
		  "seq_cur"	撤销树中当前位置的序列号。如果有撤销过的改变，
				和 "seq_last" 会有不同。
		  "time_cur"	最近用于 |:earlier| 和相关命令的时间。
				可用 |strftime()| 转换成可读的格式。
		  "save_last"	最后的文件写入编号。如果没有写入，返回零。
		  "save_cur"	撤销树当前位置的编号。
		  "synced"	如果最后的撤销块已经同步，返回非零值。等待用户
				输入时会发生。见 |undo-blocks|。
		  "entries"	关于撤销块的信息的字典的列表。

		"entries" 列表的第一个值是最老的撤销项目。每个列表项目是一个包
		含以下项目的字典:
		  "seq"		撤销序列号。和 |:undolist| 显示的相同。
		  "time"	改变发生的时间。可用 |strftime()| 转换成可读的
				格式。
		  "newhead"	只出现在最后加入的项目。标识最后的改变，并指示
		  		将来的改变加入所在的位置。
		  "curhead"	只出现在最后撤销的项目。表示撤销树当前的位置，
		  		该块可用于 redo 命令。如果最后改变之后没有撤销
				动作，此项目不出现。
		  "save"	只出现在文件写入前最后的块。该值为写入计数。首
		  		次写入的编号为 1，最后一次是上面提及的
				"save_last"。
		  "alt"		替代项。这又是一个撤销块的列表。每个项目又可以
		  		有 "alt" 项目。


+-*/+-*/update c 如果有修改，写回缓冲区
							*:up* *:update*
:[range]up[date][!] [++opt] [>>] [file]
			和 ":write" 类似，但只有在缓冲区已修改的时候才写入。
			{Vi 无此功能}

+-*/+-*/view c 以只读方式编辑文件
							*:vie* *:view*
:vie[w][!] [++opt] [+cmd] file
			用于 Ex 模式时: 退出 |Ex-mode|，回到普通模式。否则和
			|:edit| 相同，但为本缓冲区置位 'readonly' 选项。{Vi 无
			此功能}

+-*/+-*/visual c 等同于 "":edit""，但关掉 ""Ex"" 模式
							*:vi* *:visual*
:vi[sual][!] [++opt] [+cmd] [file]
			用于 Ex 模式时: 退出 |Ex-mode|，回到普通模式。否则和
			|:edit| 相同。

+-*/+-*/wall c 写回所有 (改变的) 缓冲区
							*:wa* *:wall*
:wa[ll]			保存所有已修改的缓冲区。没有文件名或者只读的缓冲区不在
			此列。{Vi 无此功能}

+-*/+-*/wq c 写回文件，然后退出窗口或者 Vim
							*:wq*
:wq [++opt]		写回当前的文件并且退出。如果文件只读或者该缓冲区无名，
			写回操作将失败。如果参数列表的最后一个文件还没有编辑，
			那么退出操作将会失败。

+-*/+-*/wqall c 写回所有 (改变的) 缓冲区然后退出 Vim
:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		保存所有修改过的缓冲区并退出 Vim。如果其中有无名的、只读的、
		或者其他原因写入失败的缓冲区，Vim 不会退出。{Vi 无此功能}

+-*/+-*/write c 写回文件
							*:w* *:write*
						*E502* *E503* *E504* *E505*
						*E512* *E514* *E667* *E796*
:w[rite] [++opt]	将整个缓冲区写入当前文件。这是保存文件更动最普通的方
			式。如果置位了 'readonly' 选项或者其他原因不能写入文
			件，它会失败。
			关于 ++opt 可见 |++opt|，但只有 ++bin、++nobin、++ff
			和 ++enc 有效。

+-*/+-*/writeany o 写入文件不需 ""!"" 强制
				   *'writeany'* *'wa'* *'nowriteany'* *'nowa'*
'writeany' 'wa'		布尔型	(缺省关闭)
			全局
	允许写入文件，而无需 "!" 覆盖缺省行为。


+-*/+-*/writebackup o 覆盖文件时建立备份
			     *'writebackup'* *'wb'* *'nowritebackup'* *'nowb'*
'writebackup' 'wb'	布尔型	(有 |+writebackup| 特性时缺省打开，否则缺省关
				闭)
			全局
			{Vi 无此功能}
	覆盖文件前建立备份。文件成功写入后，除非 'backup' 选项也被打开，删除
	该备份。如果你的文件系统几乎已满，复位此选项。|backup-table| 还有相关
	的解释。
	如果 'backupskip' 模式匹配，无论如何都不会建立备份。
	注意: 如果置位 'compatible'，该选项被设为缺省值。


+-*/+-*/writefile f 把一个行列表写到文件里
writefile({list}, {fname} [, {binary}])
		把 |List| {list} 写到文件 {fname} 里。列表的项目间以 NL 分隔。
		每个列表项必须是字符串或数值。
		如果 {binary} 等于 "b"，使用二进制模式: 最后一个列表项目之后没
		有 NL，最后的空项目使得文件的末行以 NL 结尾。
		所有的 NL 字符被 NUL 字符代替。
		CR 字符的插入需要在把 {list} 传递给 writefile() 之前先做好。
		如果可能，覆盖已有的文件。
		如果写入失败，返回 -1，否则返回 0。如果文件不能建立或者写入失
		败，会有错误信息。
		另见 |readfile()|。
		要按字节复制文件: >
			:let fl = readfile("foo", "b")
			:call writefile(fl, "foocopy", "b")
<


+-*/+-*/xit c 如果缓冲区被改动，写入之。然后退出窗口或者 Vim
							*:x* *:xit*
:[range]x[it][!] [++opt] [file]
			和 ":wq" 类似， 但只有文件已修改时写入才会实际进行。
			如果 'hidden' 被设置并且还有其他窗口，当前缓冲区会在
			写入后被隐藏。

+-*/+-*/arg _ 参数
+-*/+-*/+-*/argadd c 增加项目到参数列表中
:[count]arga[dd] {name} ..			*:arga* *:argadd* *E479*
			将若干文件名 {name} 等加到参数列表里。
			如果忽略 [count]， {name} 等加入到参数列表的当前项之
			后。不然，加到第 [count] 个文件之后。如果参数列表是
			"a b c"，而 "b" 是当前参数，那么以下命令会导致:

+-*/+-*/+-*/argc f 参数列表项数
argc()		返回当前窗口参数列表的文件数目。见 |arglist|。

							*argidx()*
+-*/+-*/+-*/argdelete c 从参数列表中删除项目
:argd[elete] {pattern} ..			*:argd* *:argdelete* *E480*
			从参数列表里删除匹配 {pattern} (可有多个) 的文件。
			{pattern} 为文件模式，见 |file-pattern|。"%" 可以用来
			删除当前入口项。
			即使该命令从参数列表里删除了当前编辑文件，该文件保持被
			编辑。
			例如: >
				:argdel *.obj
<			{Vi 无此功能} {仅当编译时加入 |+listcmds| 特性才有效}

+-*/+-*/+-*/argdo c 在参数列表上的所有项目上执行一个命令
						*:argdo*
:argdo[!] {cmd}		对参数列表里的每个文件执行 {cmd}。
			它的工作方式大致如下: >
				:rewind
				:{cmd}
				:next
				:{cmd}
				等等
<			如果当前文件不能被放弃 |abandon| 而且不存在 [!]，该命
			令失败。
			如果一个文件检测到错误，参数列表里的其余文件将不再被操
			作。
			参数列表里的最后一个文件 (或发生错误的那个) 成为当前文
			件。
			{cmd} 可以包含 '|'，从而连接多个命令。
			{cmd} 不可修改参数列表。
			注意: 当命令执行时，Syntax 自动命令事件被加到
			'eventignore' 里，从而被屏蔽。这样显著提高了编辑每个文
			件的速度。
			{Vi 无此功能} {仅当编译时加入 |+listcmds| 特性才有效}
			另见 |:windo|、|:tabdo| 和 |:bufdo|。

+-*/+-*/+-*/argedit c 增加项目到参数列表中并编辑之
:[count]arge[dit][!] [++opt] [+cmd] {name}		*:arge* *:argedit*
			将 {name} 加到参数列表里，并编辑之。
			如果 {name} 已经在参数列表里存在，只编辑之。
			这和用 |:argadd| 然后 |:edit| 类似。
			注意 这里只允许单个文件名，文件名里的空格是允许的，就
			像 |:edit| 一样。
			[count] 的用法和 |:argadd| 一样。
			如果当前文件不能被放弃 |abandon|，[!] 是必需的。
			另见 |++opt| 和 |+cmd|。
			{Vi: 无 ++opt}

+-*/+-*/+-*/argglobal c 定义全局参数列表
							*:argglobal*
:argg[lobal]		当前窗口使用全局参数列表。并不开始编辑另外一个文件。

+-*/+-*/+-*/argidx f 参数列表中的当前位置
argidx()	返回参数列表的当前索引。0 是第一个文件。argc() - 1 是最后一
		个。见 |arglist|。

							*argv()*
+-*/+-*/+-*/arglocal c 定义本地参数列表
							*:arglocal*
:argl[ocal]		复制一个全局参数列表的局部备份。并不开始编辑另外一个文
			件。

+-*/+-*/+-*/args c 显示参数列表
							*:ar* *:args*
:ar[gs]			显示参数列表，当前文件以方括号表示。

+-*/+-*/+-*/argv f 从参数列表中取得一项
argv([{nr}])	返回当前窗口参数列表第 {nr} 个参数。见 |arglist|。"argv(0)" 是
		第一个参数。
		例如: >
	:let i = 0
	:while i < argc()
	:  let f = escape(fnameescape(argv(i)), '. ')
	:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'
	:  let i = i + 1
	:endwhile
<		如果没有 {nr} 参数，返回完整的 {arglist} 的 |List|。


+-*/+-*/+-*/first c 转到参数列表的第一个文件
							*:fir* *:first*
:fir[st][!] [++opt] [+cmd]
			":rewind" 的别名。{Vi 无此功能}

+-*/+-*/+-*/last c 转到参数列表的最后一个文件
							*:la* *:last*
:la[st] [++opt] [+cmd]
			开始编辑参数列表的最后一个文件。如果已经作了修改而 vim
			不能放弃 |abandon| 当前的缓冲区，该命令失败。另见
			|++opt| 和 |+cmd|。{Vi 无此功能}

+-*/+-*/+-*/next c 跳转到参数列表的下一个文件
:[count]n[ext] [++opt] [+cmd]			*:n* *:ne* *:next* *E165* *E163*
			编辑向后第 [count] 个文件。如果已经作了修改而 vim 不能
			放弃 |abandon| 当前的缓冲区，该命令失败。另见 |++opt|
			和 |+cmd|。{Vi 没有 count 和 ++opt}

+-*/+-*/+-*/previous c 跳转到参数列表里的上一个文件
:[count]prev[ious] [count] [++opt] [+cmd]		*:prev* *:previous*
			和 :Next 相同。另见 |++opt| 和 |+cmd|。{Vi: 只有在某些
			版本存在}

+-*/+-*/+-*/rewind c 转到参数列表的第一个文件
							*:rew* *:rewind*
:rew[ind] [++opt] [+cmd]
			开始编辑参数列表的第一个文件。如果已经作了修改而 vim
			不能放弃 |abandon| 当前的缓冲区，该命令失败。另见
			|++opt| 和 |+cmd|。{Vi 没有 ++opt}

+-*/+-*/+-*/sNext c 分割窗口并转到参数列表的前一个文件
:[N]sN[ext][!] [++opt] [+cmd] [N]			*:sN* *:sNext*
		这是 ":split | [N]Next" 命令的简写。分割窗口并切换到向前第 N
		个参数。但是如果该参数不存在，窗口不会分割。参见 |++opt| 和
		|+cmd|。

+-*/+-*/+-*/sall c 为参数列表的每个文件打开窗口
:[N]al[l][!] [N]				*:al* *:all* *:sal* *:sall*
:[N]sal[l][!] [N]
		重新整理屏幕，为每一个参数打开一个窗口。其它窗口统统关闭。如果
		使用了计数，则其数值为窗口数目的最大值。
		如果带 |:tab| 修饰符，为每个参数打开一个标签页。如果参数数目多
		于 'tabpagemax'，多余参数成为最后一个标签页的分割窗口。
		如果设置了 'hidden'，所有要关闭的窗口变为隐藏。
		如果没有设置 'hidden'，但是设置了 'autowrite'，那么所有改动
		的缓冲区被写入文件。否则，包含更改过的缓冲区的窗口不会被删除，
		除非你用 [!] 使它们隐藏。更改过的缓冲区永远不会被丢弃，所以改
		动不会丢失。
		[N] 是最大可以打开的窗口数。'winheight' 也限制打开的窗口数。
		(如果前加了 |:vertical| 的话 'winwidth')。
		Buf/Win Enter/Leave 自动命令不会被这里的新窗口执行，只有在它
		们真正进入时才会执行。

+-*/+-*/+-*/sargument c 分割窗口并转到参数列表的某一个文件
:[N]sa[rgument][!] [++opt] [+cmd] [N]			*:sa* *:sargument*
		这是 ":split | argument [N]" 命令的简写。分割窗口并切换至第 N
		号参数。但是如果该参数不存在，窗口不会分割。参见 |++opt| 和
		|+cmd|。

+-*/+-*/+-*/sfirst c 分割窗口并转到参数列表的第一个文件
						*:sfir* *:sfirst*
:sfir[st] [++opt] [+cmd]
		与 ":srewind" 相同。

+-*/+-*/+-*/slast c 分割窗口并转到参数列表的最后一个文件
						*:sla* *:slast*
:sla[st][!] [++opt] [+cmd]
		这是 ":split | last" 命令的简写。分割窗口并切换到最后一个参
		数。但是如果没有参数列表，窗口不会分割。参见 |++opt| 和
		|+cmd|。
						*:dr* *:drop*
:dr[op] [++opt] [+cmd] {file} ..
		在一个窗口内编辑第一个 {file}。
		－ 如果该文件已经被打开，切换至该文件所在窗口。
		－ 如果该文件尚未被打开，在当前窗口内打开该文件。如果当前窗口
		   无法被放弃 |abandon|，窗口会先被分割。
		参数列表 |argument-list| 会被象使用 |:next| 命令一样被设定。
		此命令的目的在于：允许 debugger 之类的程序里让 Vim 编辑另一个
		文件。
		如果使用 |:tab| 修饰符，为每个参数打开一个标签页。如果为空，使
		用最后一个窗口。
		另见 |++opt| 和 |+cmd|。
		{仅当编译时有 GUI 才可用}

+-*/+-*/+-*/snext c 分割窗口并转到参数列表的下一个文件
:[N]sn[ext][!] [++opt] [+cmd] [file ..]			*:sn* *:snext*
		这是 ":split | [N]next" 命令的简写。分割窗口并切换到向后第 N
		个参数。但是如果该参数不存在，窗口不会分割。参见 |++opt| 和
		|+cmd|。

+-*/+-*/+-*/sprevious c 分割窗口并转到参数列表的前一个文件
:[N]spr[evious][!] [++opt] [+cmd] [N]			*:spr* *:sprevious*
:[N]sN[ext][!] [++opt] [+cmd] [N]			*:sN* *:sNext*
		这是 ":split | [N]Next" 命令的简写。分割窗口并切换到向前第 N
		个参数。但是如果该参数不存在，窗口不会分割。参见 |++opt| 和
		|+cmd|。

+-*/+-*/+-*/srewind c 分割窗口并转到参数列表的第一个文件
						*:sre* *:srewind*
:sre[wind][!] [++opt] [+cmd]
		这是 ":split | rewind" 命令的简写。分割窗口并切换到第一个参
		数。但是如果没有参数列表，窗口不会分割。参见 |++opt| 和
		|+cmd|。

+-*/+-*/+-*/wNext c 写回文件，然后跳转到参数列表的前一个文件
:[count]wN[ext][!] [++opt] [file]		*:wN* *:wNext*
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			和 :wnext 相同，向前编辑而不是向后。{Vi 无此功能}

+-*/+-*/+-*/wnext c 写回文件，然后跳转到参数列表的下一个文件
							*:wn* *:wnext*
:[count]wn[ext] [++opt]
			写回当前文件并开始编辑向后第 [count] 个文件。另见
			|++opt| 和 |+cmd|。{Vi 无此功能}

+-*/+-*/+-*/wprevious c 写回文件，然后跳转到参数列表的前一个文件
:[count]wp[revious][!] [++opt] [file]		*:wp* *:wprevious*
			和 :wnext 相同，向前编辑而不是向后。{Vi 无此功能}

+-*/+-*/os _ 系统
+-*/+-*/+-*/cd c 改变目录
							*:cd* *E747* *E472*
:cd[!]			在非 Unix 系统上: 显示当前目录名。在 Unix 系统上: 改变
			当前目录到主 (home) 目录。在所有的系统上，用 |:pwd| 可
			以显示当前目录。

+-*/+-*/+-*/cdpath o "":cd"" 搜索的目录列表
						*'cdpath'* *'cd'* *E344* *E346*
'cdpath' 'cd'		字符串	(缺省: 等价于 $CDPATH 或 ",,")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+file_in_path| 特性才有效}
	这是一个目录列表。使用 |:cd| 和 |:lcd| 命令时，如果查找的是相对路径，
	而不是以 "/"、"./" 或 "../" 开始的绝对路径，在这里搜索目录。绝对路径不
	使用 'cdpath' 选项。
	'cdpath' 选项的值和 |'path'| 有相同的形式和语义。另见
	|file-searching|。
	缺省值取自 $CDPATH，并在前面附加 ","，以便先搜索当前目录。
	如果取自 $CDPATH 的缺省值不是你想要的，在 vimrc 文件里加入下面命令的修
	改版本以覆盖之: >
	  :let &cdpath = ',' . substitute(substitute($CDPATH, '[, ]', '\\\0', 'g'), ':', ',', 'g')
<	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。
	('cdpath' 的内容可传递给外壳以便扩展文件名)。


+-*/+-*/+-*/chdir c 改变当前目录
							*:chd* *:chdir*
:chd[ir][!] [path]	和 |:cd| 相同。

+-*/+-*/+-*/delete f 删除文件
delete({fname})							*delete()*
		删除名为 {fname} 的文件。返回类型为数值。如果成功删除文件，返
		回 0，如果删除失败，返回非零。
		从 |List| 里删除项目请用 |remove()|。

							*did_filetype()*
+-*/+-*/+-*/executable f 检查一个可执行程序是否存在
executable({expr})					*executable()*
		本函数检查名字由 {expr} 指定的可执行文件存在与否。{expr} 必须
		是程序不带任何参数的名字。
		executable() 使用 $PATH 的值和/或程序的普通的搜索路径。
							*PATHEXT*
		MS-DOS 和 MS-Windows 上，可以可选地包含 ".exe"、".bat" 等。为
		此，$PATHEXT 里的扩展名会被尝试。这样，如果 "foo.exe" 不存在，
		可能会找到 "foo.exe.bat"。如果没有设置 $PATHEXT，使用的是
		".exe;.com;.bat;.cmd"。$PATHEXT 里可以使用单独的句号，以尝试没
		有扩展名的名字。如果 'shell' 看起来像 Unix 外壳，那么也尝试没
		有扩展名的名字。
		MS-DOS 和 MS-Windows 上，只检查是否文件存在且不是目录，并不检
		查它是否真的可以执行。
		MS-Windows 上，和 Vim 在同一目录的可执行文件总能找到。因为这个
		目录加到了 $PATH 里，执行应该也没有问题 |win32-PATH|。
		返回数值:
			1	存在
			0	不存在
			-1	此系统中没有实现

							*exists()*
+-*/+-*/+-*/filereadable f 检查一个文件可读与否
filereadable({file})					*filereadable()*
		返回数值，如果名为 {file} 的文件存在且可读，则为真。如果
		{file} 不存在，或者是一个目录，返回假。{file} 可以是任何返回字
		符串的表达式。
		如果你不关心文件是否可读，可用 |glob()|。
							*file_readable()*
		已废弃的名字: file_readable()。



+-*/+-*/+-*/filewritable f 检查一个文件可写与否
filewritable({file})					*filewritable()*
		返回数值，如果名为 {file} 的文件存在且可写，则为 1。如果
		{file} 不存在，或者不可写，返回 0。如果 {file} 是一个目录但是
		可写，返回 2。



+-*/+-*/+-*/finddir f 在目录列表里查找目录
finddir({name}[, {path}[, {count}]])				*finddir()*
		在 {path} 里查找目录 {name}。支持向下和向上的递归目录搜索。
		{path} 的语法参见 |file-searching|。
		返回第一个找到的路径。如果找到的
		路径在当前目录之下，返回相对路径。否则，返回完整路径。
		如果省略 {path}，使用 'path'。
		如果给出可选的 {count}，寻找 {path} 里 {name} 第 {count} 次出
		现，而不是第一次。
		如果 {count} 为负，返回所有的匹配的列表。
		这和 ex 命令 |:find| 非常类似。
		{仅当编译时加入 |+file_in_path| 特性才有效}


+-*/+-*/+-*/findfile f 在目录列表里查找文件
findfile({name}[, {path}[, {count}]])				*findfile()*
		类似于 |finddir()|，不过寻找文件而不是目录。
		使用 'suffixesadd'。
		例如: >
			:echo findfile("tags.vim", ".;")
<		从当前文件所在的目录开始往上搜索，直到找到文件 "tags.vim" 为
		止。


+-*/+-*/+-*/fsync o 文件写回后是否激活 fsync()
						*'fsync'* *'fs'*
'fsync' 'fs'		布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	如果打开，写入文件后调用库函数 fsync()。它会把文件刷新到磁盘上，确保文
	件即使在只做元数据 (metadata) 日志 (journaling) 的文件系统上也会被安全
	写入。Linux 系统的笔记本模式下，它会强迫硬盘转上一会儿，有时候你不想这
	样。但要警告你，关闭此选项增加崩溃时数据丢失的机率。没有 fsync() 实现
	的系统上，此选项总是关闭的。
	另见 'swapsync'，说明如何控制交换文件的 fsync()。


+-*/+-*/+-*/getcwd f 取得当前工作路径
getcwd()	返回字符串，当前工作目录的名字。


+-*/+-*/+-*/getfperm f 得到文件权限
getfperm({fname})					*getfperm()*
		返回字符串，给定文件 {fname} 的读、写、执行权限。
		如果 {fname} 不存在或者它所在的目录无法读取，返回空字符串。
		返回值的形式是 "rwxrwxrwx"，其中每组 "rwx" 标志位分别代表文件
		所有者、文件所属组和其它用户的权限。如果用户没有某权限，相应的
		标志位被字符串 "-" 代替。例如: >
			:echo getfperm("/etc/passwd")
<		希望它会 (从安全角度而言) 显示字符串 "rw-r--r--" 或者甚至
		"rw-------"。


+-*/+-*/+-*/getfsize f 取得文件大小
getfsize({fname})					*getfsize()*
		返回数值，文件 {fname} 以字节数计算的大小。
		如果 {fname} 是目录，返回 0。
		如果找不到文件 {fname}，返回 -1。
		如果 {fname} 文件过大，超出了 Vim 的数值的范围，返回 -2。


+-*/+-*/+-*/getftime f 得到文件的最近修改时间
getftime({fname})					*getftime()*
		返回数值，给定文件 {fname} 的最新修改时间。该时间为 1970 年 1
		月 1 日开始计算的秒数，可以传给 strftime()。
		另见 |localtime()| 和 |strftime()|。
		如果找不到文件 {fname}，返回 -1。


+-*/+-*/+-*/getftype f 得到文件类型
getftype({fname})					*getftype()*
		返回字符串，给定文件 {fname} 的文件类型的描述。
		如果 {fname} 不存在，返回空字符串。
		下表列出各种不同文件类型的返回值:
			普通文件		"file"
			目录			"dir"
			符号链接		"link"
			块设备			"bdev"
			字符设备		"cdev"
			套接字			"socket"
			FIFO			"fifo"
			其它			"other"
		例如: >
			getftype("/home")
<		注意 只有在能支持的系统上才会返回 "link" 这样的类型。有的系统
		只支持 "dir" 和 "file"。

							*getline()*
+-*/+-*/+-*/glob f 展开通配符
glob({expr} [, {flag}])					*glob()*
		扩展 {expr} 里的文件通配符。|wildcards| 说明其中特殊字符的使用
		方法。
		结果是字符串。
		如果返回多个匹配，以 <NL> 字符分隔。
		除非给出可选的 {flag} 参数且非零，应用 'suffixes' 和
		'wildignore' 选项: 跳过匹配任何 'wildignore' 模式的名字，而
		'suffixes' 影响匹配结果的排序。
		如果扩展失败，返回空字符串。
		扩展结果不包含不存在文件的名字。

		多数系统上，可以用反引号从外部命令得到文件名。例如: >
			:let tagfiles = glob("`find . -name tags -print`")
			:let &tags = substitute(tagfiles, "\n", ",", "g")
<		反引号包围的程序的输出结果必须每个项目一行。项目内部可以使用空
		格。

		特殊 Vim 变量的扩展见 |expand()|。|system()| 说明如何得到外部
		命令的原始输出。


+-*/+-*/+-*/globpath f 在几个路径中展开通配符
globpath({path}, {expr} [, {flag}])			*globpath()*
		在 {path} 的所有目录下执行 glob() 并连接所有的返回结果。例
		如: >
			:echo globpath(&rtp, "syntax/c.vim")
<		{path} 是逗号分隔的目录名的列表。每个目录名都附加在 {expr} 之
		前，然后如同 |glob()| 那样被扩展。必要的话，插入路径分隔符。
		要在目录名字里加上逗号，可以使用反斜杠转义。注意 在 MS-Windows
		上目录的最后可能有一个反斜杠。如果你要在后面加上逗号进行分隔，
		先把反斜杠去掉。
		如果某个目录下的扩展失败，不会有错误信息。
		除非给出可选的 {flag} 参数且非零，应用 'suffixes' 和
		'wildignore' 选项: 跳过匹配任何 'wildignore' 模式的名字，而
		'suffixes' 影响匹配结果的排序。

		可以用 "**" 项目来搜索目录树。例如，寻找在 'runtimepath' 和它
		之下所有目录里的 "README.txt" 文件: >
			:echo globpath(&rtp, "**/README.txt")
<		不支持向上搜索和 "**" 的深度限制，所以 'path' 的使用不一定总能
		正确工作。

							*has()*
+-*/+-*/+-*/hostname f 系统的名称
hostname()						*hostname()*
		返回字符串，即 Vim 运行的机器名字。超过 256 字符串长度的机器名
		被截短。


+-*/+-*/+-*/isdirectory f 检查一个目录是否存在
isdirectory({directory})				*isdirectory()*
		返回数值，如果名为 {directory} 的目录存在，返回非零。如果
		{directory} 不存在或者不是目录，返回假值。{directory} 可以是任
		何表达式，最终用作字符串。


+-*/+-*/+-*/lcd c 改变本地的目录
							*:lc* *:lcd*
:lc[d][!] {path}	和 |:cd| 类似，但只设置当前窗口的当前目录。别的窗口的
			当前目录保持不变。{Vi 无此功能}

+-*/+-*/+-*/lchdir c 改变本地的目录
							*:lch* *:lchdir*
:lch[dir][!]		和 |:lcd| 相同。{Vi 无此功能}

+-*/+-*/+-*/mkdir f 建立新目录
mkdir({name} [, {path} [, {prot}]])
		建立目录 {name}。
		如果 {path} 为 "p"，必要时建立中间的目录。否则它必须是 ""。
		如果给出 {prot}，它用于设置新目录的权限。缺省为 0755
		(rwxr-xr-x: 用户自己可读写，其它人可读)。用 0700 使其它人不可
		读。这只用于 {name} 的最后部分。所以，如果建立 /tmp/foo/bar，
		/tmp/foo 创建时的权限是 0755。
		示例: >
			:call mkdir($HOME . "/tmp/foo/bar", "p", 0700)
<		该函数在沙盘里不可用 |sandbox|。
		不一定在所有系统上都可用。要检查这一点，使用: >
			:if exists("*mkdir")
<
							*mode()*
+-*/+-*/+-*/osfiletype o 操作系统特定的文件格式信息
					*'osfiletype'* *'oft'* *E366*
'osfiletype' 'oft'	字符串 (RISC-OS 缺省: "Text"，
				其它的缺省: "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+osfiletype| 特性才有效}
	有的操作系统保存除了名字、时间标记和权限之外的附加文件信息。本选项包含
	这些附加的信息。很自然的，这些信息因系统而异。本选项的值通常在文件读入
	时设置，而在写入时可以使用本值设置操作系统文件类型。
	它可以影响自动命令的模式匹配。|autocmd-osfiletypes|


+-*/+-*/+-*/pwd c 显示当前目录
							*:pw* *:pwd* *E187*
:pw[d]			显示当前目录名。{Vi: 没有 pwd}
			另见 |getcwd()|。

+-*/+-*/+-*/rename f 重命名文件
rename({from}, {to})					*rename()*
		把文件名 {from} 换成 {to}。这也可用来在文件系统间移动文件。返
		回数值，如果文件成功换名，返回零，如果换名失败，返回非零。
		注意 如果 {to} 已存在，它被覆盖且没有提示。
		该函数在沙盘里不可用 |sandbox|。


+-*/+-*/+-*/resolve f 找到一个快捷方式所指
resolve({filename})					*resolve()* *E655*
		在 MS-Windows 上，如果 {filename} 是一个快捷方式 (.lnk 文件)，
		返回简化的快捷方式指向的路径。
		在 Unix 上，反复分析 {filename} 的所有路径部分的符号链接的真正
		路径，直到返回最简化的结果为止。为了处理循环链接的问题，符号链
		接的分析在 100 次叠代之后停止。
		在其它系统上，返回简化了的 {filename}。
		简化的工作通过 |simplify()| 完成。
		resolve() 保留指向当前目录的首个路径部分 (保证结果仍然是相对路
		径名)，也保留出现在尾部的路径分隔符。

							*reverse()*
+-*/+-*/+-*/shortname o 非 MS-DOS: 文件名假定为 8.3 字符
				 *'shortname'* *'sn'* *'noshortname'* *'nosn'*
'shortname' 'sn'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能，MS-DOS 版本也没有}
	假定文件名为 8 字符加 3 字符的扩展。文件名不能有多个句号。如果打开此选
	项，在附加扩展名时，文件名里的句号被下划线替换 (".~" 或 ".swp")。此选
	项在 MS-DOS 上不可用，因为那里它总应该是打开的。此选项用于编辑 MS-DOS
	兼容的文件系统的文件，比如，messydos 或 crossdos。运行 Win32s 上的
	Win32 GUI 版本时，缺省总是打开此选项。


+-*/+-*/+-*/tempname f 取得一个临时文件的名称
tempname()					*tempname()* *temp-file-name*
		返回字符串，它是一个不存在的文件名。可以用作临时文件。该文件在
		至少 26 个接连的调用内不会重复。例如: >
			:let tmpfile = tempname()
			:exe "redir > " . tmpfile
<		Unix 上，文件会在用户个人的目录中 |tempfile|。
		MS-Windows 上，如果置位了 'shellslash' 选项或者 'shellcmdflag'
		以 '-' 开始的时候，使用正斜杠。


+-*/fold _ 折叠
+-*/+-*/commentstring o 注释的样板；用于折叠的标志
					*'commentstring'* *'cms'* *E537*
'commentstring' 'cms'	字符串	(缺省为 "/*%s*/")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	注释行的样板。该值里面的 "%s" 被注释文本替换。目前，只用于为折叠增加标
	志。见 |fold-marker|。


+-*/+-*/fold c 创建折叠
:{range}fo[ld]						*:fold* *:fo*
		对 {range} 内的行创建折叠。其余同 "zf" 。

+-*/+-*/foldclose o 当光标离开时关闭折叠
						*'foldclose'* *'fcl'*
'foldclose' 'fcl'	字符串 (缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	如果设为 "all"，不包含光标且级别高于 'foldlevel' 的折叠被关闭。用于光
	标移出后，自动关闭折叠。


+-*/+-*/foldclose c 关闭折叠
							*:foldc* *:foldclose*
:{range}foldc[lose][!]
		在 {range} 内关闭折叠。当加上 [!] 时，所有的折叠都被关闭。对隐
		藏在 {range} 内的所有文本很有用。没有 [!] 时，关闭一级折叠。

+-*/+-*/foldclosed f 检查某一行是否被折叠起来
foldclosed({lnum})					*foldclosed()*
		返回数值，如果行 {lnum} 在关闭的折叠中，返回该折叠开始的行号。
		如果行 {lnum} 不在关闭的折叠中，返回 -1。


+-*/+-*/foldclosedend f 类似 foldclosed() 但同时返回最后一行
foldclosedend({lnum})					*foldclosedend()*
		返回数值，如果行 {lnum} 在关闭的折叠中，返回该折叠结束的行号。
		如果行 {lnum} 不在关闭的折叠中，返回 -1。


+-*/+-*/foldcolumn o 设定指示折叠的列宽度
						*'foldcolumn'* *'fdc'*
'foldcolumn' 'fdc'	数值型 (缺省为 0)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	如果非零，指定宽度的列在窗口的一侧显示，指示折叠的打开和关闭。最大值为
	12。
	见 |folding|。


+-*/+-*/folddoclosed c 对所有在关闭折叠的行执行命令
:[range]folddoc[losed] {cmd}			*:folddoc* *:folddoclosed*
		对所有在关闭的折叠里的行，执行 {cmd}。
		其它同 ":folddoopen" 命令。

+-*/+-*/folddoopen c 对所有不在关闭折叠的行执行命令
:[range]foldd[oopen] {cmd}			*:foldd* *:folddoopen*
		对所有不在关闭的折叠中的行执行 {cmd}。
		给定 [range] 时，仅对范围内那些行起作用。
		每次命令被执行时，光标会被定位在要被操作的行上。
		就如 ":global" 命令：首先标记出所有不在关闭的折叠中的行。然后
		对所有标记过的行，执行 {cmd}。所以当 {cmd} 改变了文本的折叠
		时，对命令执行的位置没有影响 (当然，删除行例外)。
		如： >
			:folddoopen s/end/loop_end/ge
<		使用标志位 "e" 避免了当 "end" 不匹配时得到错误消息。

+-*/+-*/foldenable o 设置为显示所用打开的折叠
			*'foldenable'* *'fen'* *'nofoldenable'* *'nofen'*
'foldenable' 'fen'	布尔型 (缺省打开)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	如果关闭，所有的折叠都被打开。本选项用于在文本显示的完全打开折叠和保留
	折叠之间 (包括手动打开或关闭的折叠) 快速切换。|zi| 命令切换本选项。
	如果 'foldenable' 关闭，'foldcolumn' 会保持空白。
	建立新折叠或者关闭折叠的命令置位本选项。见 |folding|。


+-*/+-*/foldexpr o 当 'foldmethod' 为 ""expr"" 时使用的表达式
						*'foldexpr'* *'fde'*
'foldexpr' 'fde'	字符串 (缺省: "0")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 和 |+eval| 特性才有效}
	'foldmethod' 为 "expr" 时使用的表达式。每行使用它计算折叠级别。见
	|fold-expr|。
	
	可能在沙盘 |sandbox| 里计算此表达式。见 |sandbox-option|。
	如果 'diff' 选项置位，不能从 |modeline| 中设置。

	计算 'foldexpr' 时不允许修改文本或者跳到其它窗口 |textlock|。

表 达 式						*fold-expr*

就象用 "indent" 方式一样，表达式方式的折叠也是由折叠级别自动定义的。对每行，通
过计算选项 'foldexpr' 的值来并得到它的折叠级别。如：
对所有以制表符开始的连续的几行，创建折叠： >
	:set foldexpr=getline(v:lnum)[0]==\"\\t\"
调用一函数来计算折叠级别：  >
	:set foldexpr=MyFoldLevel(v:lnum)
用空白行分开的段落构成折叠：  >
	:set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
同上：  >
	:set foldexpr=getline(v:lnum-1)=~'^\\s*$'&&getline(v:lnum)=~'\\S'?'>1':1
备注: ":set" 要特殊处理的字符必须用反斜杠转义。(空格，反斜杠，双引号等等，参考
|option-backslash|)

这些是表达式的计算条件：
- 当前缓冲区和窗口值依所在行而定
- 变量 "v:lnum" 被定为该行行号
- 计算结果将用以下方式解释：
  值			代表 ~
  0			这行不折叠
  1, 2, ..		这行的折叠级别 1，2 等
  -1			折叠级别没有定义，使用这行之前或之后一行的级别值，取其
  			中较小的一个。
  "="			使用上一行的折叠级别。
  "a1", "a2", ..	上一行的折叠级别加 1，2，..
  "s1", "s2", ..	上一行的折叠级别减 1，2，..
  "<1", "<2", ..	此折叠级别在本行结束
  ">1", ">2", ..	此折叠级别在本行开始

不需要用 ">1" ("<1") 标志折叠的开始 (结束)。当这行折叠级别高于 (低于) 上一行的
级别时，折叠将开始 (结束)。

表达式必须没有副作用。在缓冲区里的文字，光标位置，查找模式，选项等等，不能被改
动。如果你非常小心，改动并恢复这些设置还是可以的。

表达式中有错误或者计算结果不能识别时，Vim 不会产生错误消息，而是将折叠级别设为
0。所以当需要调试时，可将 'debug' 选项设为 "msg"，错误消息就可以被见到了。

备注: 由于每一行关于表达式的值都要被计算，这一折叠方式可能会很慢！

最好避免使用 "=" ， "a" 和 "s" 作为返回值，因为 Vim 不得不经常向后回溯以得到折
叠级别。这会降低执行速度。


+-*/+-*/foldignore o 当 'foldmethod' 为 ""indent"" 时忽略的行
						*'foldignore'* *'fdi'*
'foldignore' 'fdi'	字符串 (缺省: "#")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	只有 'foldmethod' 为 "indent" 时才用到。以 'foldignore' 里的字符开始的
	行会从包围它的行里取得折叠级别。检查字符时，跳过空白。缺省的 "#" 对于
	C 程序非常适用。见 |fold-indent|。


+-*/+-*/foldlevel f 检查某行的折叠级别
foldlevel({lnum})					*foldlevel()*
		返回数值，当前缓冲区第 {lnum} 行的折叠级别。如果在嵌套的折叠
		里，返回最深的那层。如果行 {lnum} 没有折叠，返回零。这和折叠是
		打开还是关闭无关。在更新折叠时 (在 'foldexpr' 里)，如果折叠还
		在更新而相应的折叠级别未知，返回 -1。一个特例是前一行的级别通
		常总是知道的。

							*foldtext()*
+-*/+-*/foldlevel o 当折叠级别高于此值时关闭折叠
						*'foldlevel'* *'fdl'*
'foldlevel' 'fdl'	数值型 (缺省: 0)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	设置折叠级别: 高于此级别的折叠会被关闭。
	设置此选项为零关闭所有的折叠。更高的数字关闭更少的折叠。
	|zm|、|zM| 和 |zR| 等命令设置此选项。
	见 |fold-foldlevel|。


+-*/+-*/foldlevelstart o 开始编辑文件的 'foldlevel'
						*'foldlevelstart'* *'fdls'*
'foldlevelstart' 'fdls'	数值型 (缺省: -1)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	在窗口里开始编辑一个缓冲区时设置 'foldlevel'。用于开始编辑时总是关闭所
	有的折叠 (值为零)，关闭某些折叠 (1) 或者没有折叠 (99)。
	它在读入任何模式行之前进行，因此模式行里的设置可以否决本选项的设定。开
	始编辑 |diff-mode| 的文件也忽略本选项，并关闭所有折叠。
	它也在 BufReadPre 自动命令之前完成，使得自动命令可以为特定文件重新设定
	'foldlevel' 的值。
	如果值为负，不使用本选项。


+-*/+-*/foldmarker o 当 'foldmethod' 为 ""marker"" 时的标志
						*'foldmarker'* *'fmr'* *E536*
'foldmarker' 'fmr'	字符串 (缺省: "{{{,}}}")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	'foldmethod' 为 'marker' 时使用的开始和结束标志。必须有一个逗号分隔开
	始和结束标志。标志是一个按本义出现的字符串 (正规表达式太慢了)。
	见 |fold-marker|。


+-*/+-*/foldmethod o 折叠的类型
						*'foldmethod'* *'fdm'*
'foldmethod' 'fdm'	字符串 (缺省: "manual")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	当前窗口使用的折叠方式。可能的值是:
	|fold-manual|	manual	    手动建立折叠。
	|fold-indent|	indent	    相同缩进距离的行构成折叠。
	|fold-expr|	expr	    'foldexpr' 给出每行的折叠级别。
	|fold-marker|	marker	    标志用于指定折叠。
	|fold-syntax|	syntax	    语法高亮项目指定折叠。
	|fold-diff|	diff	    没有改变的文本构成折叠。


+-*/+-*/foldminlines o 折叠关闭所需的最少行数
						*'foldminlines'* *'fml'*
'foldminlines' 'fml'	数值型 (缺省: 1)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	设置会显示为关闭折叠的最少屏幕行数。也适用于手动关闭的折叠。
	注意 这只对显示的效果有影响。使用 "zc" 关闭折叠以后，如果该折叠比
	'foldminlines' 小，会显示为打开。但接下来的 "zc" 就可能会关闭包含该折
	叠的折叠。


+-*/+-*/foldnestmax o 最大折叠深度
						*'foldnestmax'* *'fdn'*
'foldnestmax' 'fdn'	数值型 (缺省: 20)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	设置 "indent" 和 "syntax" 方法的最大折叠嵌套层数。它避免建立过多的折
	叠。本值不能超过 20，因为内部的限制就是 20 层。


+-*/+-*/foldopen o 打开折叠所使用的命令
						*'foldopen'* *'fdo'*
'foldopen' 'fdo'	字符串 (缺省: "block,hor,mark,percent,quickfix,
						     search,tag,undo")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	如果某个命令移动光标到关闭的折叠，本选项指定该命令是什么类型时会打开折
	叠。这是一个逗号分隔的项目列表。
		项目		命令 ~
		all		任何
		block		"("、"{"、"[["、"[{" 等。
		hor		水平移动: "l"、"w"、"fx" 等。
		insert		任何插入模式下的命令
		jump		远距离跳转: "G"、"gg" 等。
		mark		跳转到位置标记: "'m"、CTRL-O 等。
		percent		"%"
		quickfix	":cn"、":crew"、":make" 等。
		search		模式搜索: "/"、"n"、"*"、"gd" 等。
				(不适用于 ":" 命令里的模式搜索)
				也用于 |[s| 和 |]s|。
		tag		跳转到标签: ":ta"、CTRL-T 等。
		undo		撤销或重做: "u" 和 CTRL-R
	如果命令是映射的一部分，不使用本选项。要达到相同的效果，在映射里加入
	|zv| 命令。
	如果移动命令用作操作符 (比如，"dl" 或 "y%")，不使用本选项。这意味着操
	作符会包含整个关闭的折叠。
	注意 这里不包括垂直移动命令，否则移过关闭的折叠会非常困难。
	插入模式下，插入文本时总会打开光标所在的折叠。
	要关闭折叠，你可以用 |zx| 命令重新应用 'foldlevel'，或者把 'foldclose'
	选项设为 "all"。


+-*/+-*/foldopen c 打开折叠
							*:foldo* *:foldopen*
:{range}foldo[pen][!]
		在 {range} 内打开折叠。当加上 [!] 时，所有的折叠都被打开。对查
		看在 {range} 内的所有文本很有用。没有 [!] 时，打开一级折叠。

+-*/+-*/foldtext f 产生折叠关闭时所显示的行
foldtext()	返回关闭的折叠所显示的行。这是 'foldtext' 选项使用的缺省函数，
		而且也只应该在计算 'foldtext' 时使用。它使用 |v:foldstart|、
		|v:foldend| 和 |v:folddashes| 变量。
		返回的字符串看起来像: >
			+-- 45 lines: abcdef
<		连字符的数目取决于折叠级别。"45" 是折叠的行数。"abcdef" 是折叠
		第一个非空白行的文本。开头的空白、"//" 和 "/*" 还有
		'foldmarker' 和 'commentstring' 选项的文本都被去除。
		{仅当编译时加入 |+folding| 特性才有效}


+-*/+-*/foldtext o 显示关闭的折叠所用的表达式
						*'foldtext'* *'fdt'*
'foldtext' 'fdt'	字符串 (缺省: "foldtext()")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+folding| 特性才有效}
	用来指定替代关闭折叠的显示文本的表达式。见 |fold-foldtext|。

	可能在沙盘 |sandbox| 里计算此表达式。见 |sandbox-option|。

	计算 'foldtext' 时不允许修改文本或者跳到其它窗口 |textlock|。


+-*/+-*/foldtextresult f 得到关闭折叠显示的文本
foldtextresult({lnum})					*foldtextresult()*
		返回行 {lnum} 所在的关闭的折叠显示的文本。在合适的上下文里计算
		'foldtext'。
		如果 {lnum} 没有关闭的折叠，返回空字符串。
		{lnum} 的用法类似于 |getline()|。所以 "." 是当前行，"'m" 是位
		置标记 m，等等。
		可用于输出折叠文本，例如，到 HTML 格式。
		{仅当编译时加入 |+folding| 特性才有效}

							*foreground()*
+-*/gui _ gvim
+-*/+-*/antialias o Mac OS X: 用平滑反锯齿的字体
			*'antialias'* *'anti'* *'noantialias'* *'noanti'*
'antialias' 'anti'	布尔型 (缺省: 关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 Mac OS X 的 GUI 支持才有效}
	只有在 Mac OS X v10.2 或以后版本的 Vim 的 GUI 版本上，本选项才有效。如
	果打开，Vim 使用平滑 ("反锯齿") 字体。在特定显示上的特定大小的字体，可
	能会较易阅读。有时，如果 'guifont' 设为缺省值 (空字符串)，置位该选项会
	引起问题。


+-*/+-*/balloondelay o 弹出气泡之前的延迟 (以毫秒计)
						*'balloondelay'* *'bdlay'*
'balloondelay' 'bdlay'	数值型	(缺省: 600)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+balloon_eval| 特性才有效}
	弹出气泡之前以毫秒计的延迟。见 |balloon-eval|。


+-*/+-*/ballooneval o 打开气泡表达式求值功能
		       *'ballooneval'* *'beval'* *'noballooneval'* *'nobeval'*
'ballooneval' 'beval'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+balloon_eval| 特性才有效}
	打开 |balloon-eval| 功能。


+-*/+-*/balloonexpr o 计算气泡显示内容的表达式
						     *'balloonexpr'* *'bexpr'*
'balloonexpr' 'bexpr'	字符串	(缺省 "")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
			{仅当编译时加入 |+balloon_eval| 特性才有效}
	计算气泡显示文本的表达式。只在 'ballooneval' 打开时才使用。它用到以下
	变量:

	v:beval_bufnr	要显示气泡的缓冲区号
	v:beval_winnr	窗口编号
	v:beval_lnum	行号
	v:beval_col	列号 (字节位置)
	v:beval_text	鼠标指针所在或之后的单词

	表达式的计算不能有副作用！
	例如: >
    function! MyBalloonExpr()
	return 'Cursor is at line ' . v:beval_lnum .
		\', column ' . v:beval_col .
		\ ' of file ' .  bufname(v:beval_bufnr) .
		\ ' on word "' . v:beval_text . '"'
    endfunction
    set bexpr=MyBalloonExpr()
    set ballooneval
<
	注意: 只有光标在文本字符上的时候才会显示气泡。如果 'balloonexpr' 的计
	算结果非空，Vim 不会试图发送消息给外部调试器 (Netbeans 或 Sun
	Workshop)。

	表达式的计算可能在沙盘 |sandbox| 里进行，见 |sandbox-option|。

	计算 'balloonexpr' 时，不能改变文本或跳到别的窗口 |textlock|。

	要检查气泡文本是否可以包含换行符: >
		if has("balloon_multiline")
<	如果支持，"\n" 字符开启新行。如果表达式计算结果为 |List|，这相当于把每
	个列表项目当作字符串，然后之间用 "\n" 连接。


+-*/+-*/behave c 设置鼠标和选择行为
							*:behave* *:be*
:be[have] {model}	设置鼠标和选择的行为。可接受的参数是:
			   mswin	MS-Windows 行为
			   xterm	Xterm 行为

+-*/+-*/browse f 显示文件查找器
browse({save}, {title}, {initdir}, {default})
		启动文件请求窗口。只有在 "has("browse")" 返回非零时 (只有在一
		些 GUI 版本里) 才可以。
		输入的字段包括:
		    {save}	非零时，选择要写入的文件
		    {title}	请求窗口的标题
		    {initdir}	开始浏览的目录
		    {default}	缺省文件名
		如果按了 "Cancel" 按钮、出错、或者无法浏览，返回空字符串。

							*browsedir()*
+-*/+-*/browse c 使用文件选择对话框
			*:browse* *:bro* *E338* *E614* *E615* *E616* *E578*
:bro[wse] {command}	为 {command| 的参数显示文件选择对话框。目前这可用于
			|:e|、|:w|、|:wall|、|:wq|、|:wqall|、|:x|、|:xall|、
			|:exit|、 |:view|、|:sview|、|:r|、|:saveas|、|:sp|、
			|:mkexrc|、|:mkvimrc|、|:mksession|、|:mkview|、
			|:split|、|:vsplit|、|:tabe|、|:tabnew|、|:cfile|、
			|:cgetfile|、|:caddfile|、|:lfile|、|:lgetfile|、
			|:laddfile|、|:diffsplit|、|:diffpatch|、|:open|、
			|:pedit|、|:redir|、|:source|、|:update|、|:visual|、
			|:vsplit|，还有如果置位 'confirm' 的话，|:qall|。

+-*/+-*/browsedir f 显示目录查找器
browsedir({title}, {initdir})
		启动目录请求窗口。只有在 "has("browse")" 返回非零时 (只有在一
		些 GUI 版本里) 才能工作。
		有的系统上不支持目录浏览器，这时使用文件浏览器。此时: 选择要用
		的目录里的文件。
		输入的字段包括:
		    {title}	请求窗口的标题
		    {initdir}	开始浏览的目录
		如果按了 "Cancel" 按钮、出错、或者无法浏览，返回空字符串。


+-*/+-*/browsedir o 开始浏览文件的目录
						*'browsedir'* *'bsdir'*
'browsedir' 'bsdir'	字符串	(缺省为 "last")
			全局
			{Vi 无此功能}
			{仅适用于 Motif、Athena、GTK、Mac 和 Win32 GUI}
	文件浏览器使用的目录:
	   last		使用文件浏览器最近打开或保存文件时相同的访问目录。
	   buffer	使用相关缓冲区的目录。
	   current	使用当前目录。
	   {path}	使用指定目录。


+-*/+-*/columns o 显示屏幕的列数
						*'columns'* *'co'* *E594*
'columns' 'co'		数值型	(缺省为 80 或终端宽度)
			全局
			{Vi 无此功能}
	屏幕的列数。通常，它由终端初始化代码设置，不需要手动完成。另见
	|posix-screen-size|。
	如果 Vim 运行 GUI 或者在可改变大小的窗口里，设置此选项可以改变窗口的大
	小。如果你只想设置 GUI 的大小，在 |gvimrc| 文件里放入设置命令。
	如果你设置此选项而 Vim 无法改变物理的显示列数，显示可能会混乱。GUI 没
	有这种约束，但 Vim 限制能在屏幕上显示的行数。你可以用此命令得到可用的
	最大窗口宽度: >
		:set columns=9999
	最小值为 12，最大值为 10000。


+-*/+-*/confirm f 让用户作出选择
confirm({msg} [, {choices} [, {default} [, {type}]]])
		confirm() 提供用户一个对话框，从中可以作出选择。返回选择的序
		号。第一个选择为 1。
		注意: confirm() 只有在编译时加入对话框支持才存在，见
		|+dialog_con| 和 |+dialog_gui|。
		在 |dialog| 里显示 {msg} 消息，并提供可能的选择 {choices}。如
		果 {choices} 不存在或者为空，使用 "&OK" (经过翻译)。
		{msg} 是字符串，'\n' 用来包含换行符。在有些系统上该字符串在放
		不下时被回绕，但并非所有系统都如此。
		{choices} 是一个字符串，用 '\n' 分隔各个选择，例如 >
			confirm("Save changes?", "&Yes\n&No\n&Cancel")
<		'&' 之后的字符提供该选择的快捷键。这样，你可以输入 'c' 来选择
		"Cancel"。快捷键不一定是第一个字符: >
			confirm("file has been modified", "&Save\nSave &All")
<		控制台里，每个选择的第一个字符用作缺省的快捷键。
		可选的 {default} 参数是用户按 <CR> 使用的选择号。设定 1 使得第
		一个选项成为缺省，如果是 0，则不设定任何缺省。如果不提供
		{default}，假设为 1。

		可选的 {type} 参数指定对话框的类型。只有在 GTK、Mac、Motif 和
		Win32 GUI 上才用得上，它用以指定图标。可以取的值是: "Error"、
		"Question"、 "Info"、 "Warning" 或 "Generic"。只有第一个字符是
		重要的。如果忽略 {type}，使用 "Generic"。

		如果用户用 <Esc>、CTRL-C 或者别的合法的中断键中止对话框，
		confirm() 返回 0。

		一个例子: >
   :let choice = confirm("你要吃什么？", "&苹果\n&桔子\n&香蕉", 2)
   :if choice == 0
   :	echo "快下定决心！"
   :elseif choice == 3
   :	echo "好吃"
   :else
   :	echo "我本人喜欢香蕉。"
   :endif
<		GUI 的对话框使用按钮。按钮的排放方式取决于 'guioptions' 里的
		'v' 标志位。如果包含该标志位，按钮总是竖排的。不然，confirm()
		试图把按钮放在一行里。如果放不下，那么还是使用竖排的方式。在有
		的系统上，无论如何总是使用横排。

							*copy()*
+-*/+-*/getfontname f 得到当前使用的字体名
getfontname([{name}])					*getfontname()*
		如果没有参数，返回使用的正常字体的名字，也就是 Normal 高亮组
		|hl-Normal| 使用的。
		如果带了参数，检查 {name} 是否合法的字体名。如果不是，返回空字
		符串。否则，返回实际的字体名，或者如果 GUI 不支持取得真正的名
		字，返回 {name}。
		只有在 GUI 运行的时候才能用，所以不能用于你的 vimrc 和 gvimrc
		文件。用 |GUIEnter| 自动命令可以在 GUI 刚开始之后使用此函数。
		注意 GTK 2 GUI 接受任何字体名，所以不会检查名字是否合法。


+-*/+-*/getwinposx f GUI Vim 窗口的 X 位置
getwinposx()	返回数值，即 GUI Vim 窗口以像素计从左起算的 X 坐标。如果该信息
		得不到，返回 -1。

							*getwinposy()*
+-*/+-*/getwinposy f GUI Vim 窗口的 Y 位置
getwinposy()	返回数值，即 GUI Vim 窗口以像素计从顶部起算的 Y 坐标。如果该信
		息得不到，返回 -1。


+-*/+-*/gui c 启动 GUI
	:gui [++opt] [+cmd] [-f|-b] [files...]			*:gu* *:gui*
	:gvim [++opt] [+cmd] [-f|-b] [files...]			*:gv* *:gvim*
"-f" 参数在前台运行 Vim。
"-b" 参数在后台运行 Vim (默认)。
参考 |++opt| 和 |+cmd|。

+-*/+-*/guicursor o GUI: 光标形状和闪烁的设置
			*'guicursor'* *'gcr'* *E545* *E546* *E548* *E549*
'guicursor' 'gcr'	字符串	(缺省为 "n-v-c:block-Cursor/lCursor,
					ve:ver35-Cursor,
					o:hor50-Cursor,
					i-ci:ver25-Cursor/lCursor,
					r-cr:hor20-Cursor/lCursor,
					sm:block-Cursor
					-blinkwait175-blinkoff150-blinkon175"，
				MS-DOS 和 Win32 终端:
					"n-v-c:block,o:hor50,i-ci:hor15,
					r-cr:hor30,sm:block")
			全局
			{Vi 无此功能}
			{仅适用于 GUI 和 MS-DOS 还有 Win32 控制台}
	本选项告诉 Vim 光标在不同模式的外观。GUI 里完全支持。MSDOS 或者 Win32
	控制台上，只能改变光标高度，这可以通过指定块光标、或者带百分比的垂直和
	水平光标完成。
	控制台上使用 't_SI' 和 't_EI' 转义序列。

	本选项是逗号分隔的部分列表。每个部分由模式/位置列表和参数列表组成:
		模式列表:参数列表,模式列表:参数列表,..
	"模式列表" 是指连字符分隔的下面这些模式/位置的列表:
		n	普通模式
		v	可视模式
		ve	可视模式，仅限于 'selection' 为 "exclusive" 时 (如果不
			是，和 'v' 相同)
		o	操作符等待模式
		i	插入模式
		r	替换模式
		c	在命令行附加
		ci	在命令行插入
		cr	在命令行替换
		sm	插入模式下的显示匹配 ('showmatch')
		a	所有模式
	参数列表是连字符分隔的下面参数的列表:
		hor{N}	水平线，字符高度的百分之 {N}
		ver{N}	垂直线，字符宽度的百分之 {N}
		block	块光标，填充整个字符
			[以上三者只能且必须择一]
		blinkwait{N}				*cursor-blinking*
		blinkon{N}
		blinkoff{N}
			光标的闪烁时间: blinkwait 指定光标开始闪烁前的延迟，
			blinkon 指定光标显示的时间而 blinkoff 指定光标不显示的
			时间。这些时间均以毫秒计。如果任何一个数值为零，就不会
			有闪烁的效果。缺省为:
			"blinkwait700-blinkon400-blinkoff250"。这些数值用于没
			有提供项目的缺省值。这意味着缺省打开闪烁。要关闭闪烁，
			可用 "blinkon0"。光标只有在 Vim 等待输入时才会闪烁，执
			行命令时不会。
			要使得光标在 xterm 上闪烁，见 |xterm-blink|。
		{group-name}
			一个高亮组名，设置光标的颜色和字体
		{group-name}/{group-name}
			一对高亮组名。没有语言映射时用第一个，否则用另一个。
			|language-mapping|

	"部分" 的例子:
	   n-c-v:block-nCursor	在普通、命令行和可视模式里，使用块光标和
				"nCursor" 高亮组的颜色
	   i-ci:ver30-iCursor-blinkwait300-blinkon200-blinkoff150
				在插入和命令行插入模式里，使用 30% 的垂直线光
				标和 "iCursor" 高亮组的颜色。闪烁也加快一点。

	'a' 模式有所不同。它给所有的模式设置相同的参数列表。没有出现的参数并不
	复位为缺省值。可用于给所有模式增加一个通用的设置。例如，关闭闪烁:
	"a:blinkon0"

	光标高亮的例子: >
	    :highlight Cursor gui=reverse guifg=NONE guibg=NONE
	    :highlight Cursor gui=NONE guifg=bg guibg=fg
<

+-*/+-*/guifont o GUI: 使用的字体名
					*'guifont'* *'gfn'*
						   *E235* *E596* *E610* *E611*
'guifont' 'gfn'		字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 GUI 的支持才有效}
	这是 Vim 的 GUI 版本使用的字体列表。最简单的形式是单个字体名。如果找不
	到字体，你会得到错误信息。要设置别的字体，可以指定一个列表，其中字体名
	以逗号分隔。使用第一个合法的字体。
	支持 'guifontset' 的系统上 (X11)，如果 'guifontset' 不为空，不使用
	'guifont'。
	忽略逗号之后的空格。要在字体名里包含逗号，在它之前加上反斜杠。选项的设
	置需要在空格和反斜杠之前加上额外的反斜杠。另见 |option-backslash|。比
	如: >
	    :set guifont=Screen15,\ 7x13,font\\,with\\,commas
<	会使 Vim 先寻找字体 "Screen15"，如果失败，再找 "7x13"，最后
	"font,with,commas"。

	如果没有载入任何字体，Vim 保持原先的设置。如果给出空的字体列表，Vim 会
	试图使用别的资源设置 (对 X 而言，会寻找 Vim.font 资源)，最后，选择总是
	可用的内建缺省值 (X 使用的是 "7x13")。给出的字体必须是 "正常" 字体。
	Vim 会试图找到相关的粗体和斜体字体。

	对于 Win32、GTK、Motif、Mac OS 和 Photon: >
	    :set guifont=*
<	给出字体请求对话框，从中可以选择你需要的字体。

	字体名取决于不同的 GUI。|setting-guifont| 提供一个为不同系统设置
	'guifont' 的方法。

	GTK+ 2 GUI 的字体名看起来如此: >
	    :set guifont=Andale\ Mono\ 11
<	就这样多。不使用 XLFD (X 逻辑字体描述)。有报告说对中文而言，可以这
	样设: >
	    if has("gui_gtk2")
	      set guifont=Bitstream\ Vera\ Sans\ Mono\ 12,Fixed\ 12
	      set guifontwide=Microsoft\ Yahei\ 12,WenQuanYi\ Zen\ Hei\ 12
	    endif

	Mac OSX 上，你可以这么用: >
	    :set guifont=Monaco:h10
<	另见 'macatsui'。可以修正显示问题。
								*E236*
	注意 字体必须等宽 (所有字符相同宽度)。GTK 2 是例外: 可以接受所有字体，
	不过等宽字体的视觉效果最好。

	要在 X11 上预览字体，可以使用 "xfontsel" 程序。"xlsfonts" 程序给出所有
	可用的字体的列表。

	对 Win32 GUI 而言					*E244* *E245*
	- 字体名里接受如下选项:
		hXX - 高度为 XX (点 (point)，可以是浮点数)
		wXX - 宽度为 XX (点 (point)，可以是浮点数)
		b   - 粗体
		i   - 斜体
		u   - 下划线
		s   - 突出
		cXX - 字符集 XX。合法的字符集是: ANSI、ARABIC、BALTIC、
		      CHINESEBIG5、DEFAULT、EASTEUROPE、GB2312、GREEK、
		      HANGEUL、HEBREW、JOHAB、MAC、OEM、RUSSIAN、SHIFTJIS、
		      SYMBOL、THAI、TURKISH、VIETNAMESE ANSI 和 BALTIC。
		      通常你会用 "cDEFAULT"。

	  选项间用 ':' 分隔。
	- '_' 可以代替空格，这样就无须用反斜杠转义空格。
	- 例如: >
	    :set guifont=courier_new:h12:w5:b:cRUSSIAN
	    :set guifont=Andale_Mono:h7.5:w4.5
<	另见 |font-sizes|。


+-*/+-*/guifontset o GUI: 使用的多字节字体名
					*'guifontset'* *'gfs'*
					*E250* *E252* *E234* *E597* *E598*
'guifontset' 'gfs'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时打开 GUI 支持并加入 |+xfontset| 特性才有效}
			{not in the GTK+ 2 GUI (对 GTK+ 2 GUI 无效)}
	如果非空，指定两个 (或更多) 的字体。第一个为普通的英语而设，第二个为你
	的特殊语言而设。见 |xfontset|。
	设置该选项意味着所有字体名作为字体集名处理。这也包括 |:highlight| 命令
	的 "font" 参数。
	这些字体必须和当前 locale 匹配。如果没有包含当前 locale 使用的字符集的
	字体，设置 'guifontset' 会失败。
	注意 'guifont' 和 'guifontset' 的区别: 'guifont' 里，逗号分隔的名字是
	相互替代的名字，只有一个会使用。'guifontset' 里整个字符串是一个字体集
	名，包括逗号在内。不可以指定相互替代的多个字体集名。
	下例在许多 X11 系统上工作: >
		:set guifontset=-*-*-medium-r-normal--16-*-*-*-c-*-*-*
<

+-*/+-*/guifontwide o 双倍宽度字符的字体名列表
				*'guifontwide'* *'gfw'* *E231* *E533* *E534*
'guifontwide' 'gfw'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 GUI 的支持才有效}
	如果非空，指定逗号分隔的用于双宽字符的字体列表。使用第一个能载入的字
	体。
	注意: 这些字体必须使用 'guifont' 指定的两倍宽度和相同的高度。

	除了 GTK+ 2 之外的所有 GUI 版本:

	'guifontwide' 只有在 'encoding' 设为 "utf-8" 并且 'guifontset' 为空或
	非法时才使用。
	如果设置 'guifont' 并且从中找到合法的字体，但 'guifontwide' 为空的时
	候，Vim 会试图找到匹配的双宽的字体并设置 'guifontwide' 为此值。

	仅限于 GTK+ 2 GUI:			*guifontwide_gtk2*

	如果设置且合法，总为双宽字符使用 'guifontwide'，即使 'encoding' 没有设
	为 "utf-8"。
	Vim 不会试图自动寻找 'guifontwide' 的合适的值。如果 'guifontwide' 为
	空，Pango/Xft 会选择 'guifont' 里没有的字符的字体。所以，你完全可以不
	必设置 'guifontwide'，除非你想改变 Pango/Xft 的选择。


+-*/+-*/guiheadroom o GUI: 用于窗口装饰的像素空间
						*'guiheadroom'* *'ghr'*
'guiheadroom' 'ghr'	数值型	(缺省为 50)
			全局
			{Vi 无此功能} {仅有 GTK 和 X11 GUI 才支持}
	为了在屏幕上使 GUI 窗口合身 (fit) 而从屏幕高度减去的像素点数。在 GUI
	启动前设置，比如在你的 |gvimrc| 文件里。如果为零，整个屏幕的高度都被窗
	口使用。如果为正，指定数目的像素行会被减去，以用于窗口的装饰和屏幕的其
	它项目。设为负值使得窗口比屏幕更高。


+-*/+-*/guioptions o GUI: 使用的部件和选项
						*'guioptions'* *'go'*
'guioptions' 'go'	字符串	(缺省为 "gmrLtT"   (MS-Windows)，
					"agimrLtT" (GTK、Motif 和 Athena))
			全局
			{Vi 无此功能}
			{仅当编译时加入 GUI 的支持才有效}
	该选项只有在 Vim 的 GUI 版本才有效。它是字母的序列，分别描述 GUI 应该
	使用的部件和选项。
	建议使用 ":set" 的 "+=" 和 "-=" 特性，这可以避免未来版本增加新的标志位
	时出现的问题 |add-option-flags|。

	下面是合法的标志位字母:
							*guioptions_a* *'go-a'*
	  'a'	自动选择: 如果存在，无论什么时候启动可视模式或者扩展可视区域，
		Vim 都试图成为窗口系统全局选择区的拥有者。这意味着可以粘贴高亮
		的可视文本到其它应用程序甚至 Vim 自身。如果因为在文本之上进行
		了操作，或者应用程序需要粘贴选择区等原因使得可视区域被终止，高
		亮文本会被自动抽出到 "* 选择寄存器里。这样，即使在可视模式结束
		以后，选择区仍然可以被粘贴到别的应用程序。
		    如果不存在，Vim 不会成为窗口系统的全局选择区，除非使用 "*
		寄存器进行抽出和删除操作，这时该选择区被显式地占有。
		同样适用无模式的选择。
								*'go-A'*
	  'A'	自动选择无模式的选择。类似于 'a'，但仅限于无模式的选择。

		    'guioptions'    自动选择可视	  自动选择无模式~
			 ""		--			--
			 "a"		是			是
			 "A"		--			是
			 "aA"		是			是

								*'go-c'*
	  'c'	简单的选择使用控制台对话框而不是弹出式对话框。
								*'go-e'*
	  'e'	'showtabline' 要求时，加入标签页。
		'guitablabel' 可用来改变标签文本。
		如果没有 'e'，可能使用非 GUI 标签页行。
		只有一些系统支持 GUI 标签页，现在包括 GTK、Motif、Mac OS/X 和
		MS-Windows。
								*'go-f'*
	  'f'	前台: 不用 fork() 从启动外壳分叉出本 GUI 进程。用于需要等待编
		辑器完成的程序 (例如，e-mail 程序)。你也可以用 "gvim -f" 或
		":gui -f" 来在前台启动 GUI。|gui-fork|
		注意: 在 vimrc 文件里设置本选项。读入 |gvimrc| 文件时分叉操作
		可能已经发生。
								*'go-i'*
	  'i'	使用 Vim 图标。GTK 和 KDE 上它出现在窗口的左上角。在非 GTK 的
		环境上，因为 X11 的限制，它是黑白的。要得到彩色图标，见
		|X11-icon|。
								*'go-m'*
	  'm'	使用菜单栏。
								*'go-M'*
	  'M'	不执行系统菜单脚本 "$VIMRUNTIME/menu.vim"。注意 本标志位必须在
		.vimrc 文件里加入，在打开语法或文件类型识别之前 (执行 |gvimrc|
		文件时，系统菜单已经载入；而 ":syntax on" 和 ":filetype on" 命
		令同样会载入菜单)。
								*'go-g'*
	  'g'	灰色菜单项: 使得不活动的菜单项变灰。如果没有包含 'g'，不活动的
		菜单项完全不显示。
		特例: Athena 总会使用灰色的菜单项。
								*'go-t'*
	  't'	包含可撕下的菜单项。目前只用于 Win32、GTK+ 和 Motif 1.2 GUI。
								*'go-T'*
	  'T'	包含工具栏。目前只用于 Win32、GTK+、Motif、Photon 和 Athena
		GUI。
								*'go-r'*
	  'r'	右边的滚动条总是存在。
								*'go-R'*
	  'R'	如有垂直分割的窗口，右边的滚动条总是存在。
								*'go-l'*
	  'l'	左边的滚动条总是存在。
								*'go-L'*
	  'L'	如有垂直分割的窗口，左边的滚动条总是存在。
								*'go-b'*
	  'b'	底部的 (水平) 滚动条总是存在。它的大小取决于最长的可见行，或者
		如果包含 'h' 标志位的话，光标所在的行。|gui-horiz-scroll|
								*'go-h'*
	  'h'	限制水平滚动条的大小为光标所在行的长度，以减少计算量。
		|gui-horiz-scroll|

	是的，如果你真的想要，左右两边都可以有滚动条。:-)。详情可见
	|gui-scrollbars|。

								*'go-v'*
	  'v'	对话框使用垂直的按钮布局。如果不包含，倾向使用水平布局，但如果
		空间不够，还是用垂直的布局。
								*'go-p'*
	  'p'	使用 X11 GUI 的指针回调。有些窗口管理器需要。如果光标不闪烁或
		者在一定场合下变空，考虑增加此标志位。必须在启动 GUI 之前完
		成。在你的 |gvimrc| 里设置。在 GUI 启动后增加或删除不会有任何
		效果。
								*'go-F'*
	  'F'	增加信息页脚。只适用于 Motif。见 |gui-footer|。



+-*/+-*/guipty o GUI: "":!"" 命令尝试仿终端
						*'guipty'* *'noguipty'*
'guipty'		布尔型	(缺省打开)
			全局
			{Vi 无此功能}
			{仅当编译时加入 GUI 的支持才有效}
	只适用于 GUI: 如果打开，到/从外壳命令的输入/出会尝试打开伪终端
	(psuedo-tty)。见 |gui-pty|。


+-*/+-*/gvim c 启动 GUI
	:gvim [++opt] [+cmd] [-f|-b] [files...]			*:gv* *:gvim*
"-f" 参数在前台运行 Vim。
"-b" 参数在后台运行 Vim (默认)。
参考 |++opt| 和 |+cmd|。

+-*/+-*/icon o 让 Vim 设定窗口图标的文本
						*'icon'* *'noicon'*
'icon'			布尔型	(缺省关闭，如果标题可以恢复则打开)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+title| 特性才有效}
	如果打开，窗口的图标文本会被设为 'iconstring' 的值 (如果非空)，否则，
	设为当前编辑的文件名，只使用名字的最后一部分。
	可以用 'iconstring' 选项覆盖。
	只适用于支持设置窗口图标的终端 (目前，只有 X11 GUI 版本和带有非空的
	't_ts' 选项的终端 - 缺省情况下，它们是 Unix xterm 和 iris-ansi，其中
	't_ts' 从内建的 termcap 读取)。
	如果 Vim 编译时定义 HAVE_X11，在可能的情况下恢复原来的图标 |X11|。
	|X11-icon| 说明如何改变 X11 的图标。


+-*/+-*/iconstring o Vim 图标文本所用的字符串
						*'iconstring'*
'iconstring'		字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+title| 特性才有效}
	如果此选项非空，它被用于窗口的图标文本。只有 'icon' 选项打开才会如此。
	只适用于支持设置窗口图标的终端 (目前，只有 X11 GUI 版本和带有非空的
	't_ts' 选项的终端)。
	不支持 MS Windows。
	如果 Vim 编译时定义 HAVE_X11，在可能的情况下恢复原来的图标 |X11|。如果
	此选项包含 printf 风格的 '%' 项目，它们根据 'statusline' 使用的规则进
	行扩展。'titlestring' 给出示例设置。
	{仅当编译时加入 |+statusline| 特性才有效}


+-*/+-*/keymodel o 允许用键击开始/停止选择
					*'keymodel'* *'km'*
'keymodel' 'km'		字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	逗号分隔的单词列表，打开一些特殊的键功能。可以使用下面的值:
	   startsel	使用 Shift + 特殊键可以开始选择 (选择模式或可视模式，
			取决于 'selectmode' 里有没有 "key")。
	   stopsel	使用非 Shift + 特殊键停止选择。
	这里，特殊键指光标键、<End>、<Home>、<PageUp> 和 <PageDown>。
	|:behave| 命令设置 'keymodel' 选项。


+-*/+-*/lines o 显示屏幕的行数
						*'lines'* *E593*
'lines'			数值型	(缺省为 24 或者终端高度)
			全局
	Vim 窗口的行数。
	通常，你不需要设置此选项。终端初始化代码会自动完成。另见
	|posix-screen-size|。
	如果 Vim 运行 GUI 或者在可改变大小的窗口里，设置此选项可以改变窗口的大
	小。如果你只想设置 GUI 的大小，在 |gvimrc| 文件里放入命令。
	Vim 限制能在屏幕上显示的行数。你可以用此命令得到可用的最大窗口高度: >
		:set lines=999
<	最小值为 2，最大值为 1000。
	如果你得到的行数少于预期，检查 'guiheadroom' 选项。
	如果你设置此选项而 Vim 无法改变物理的显示行数，显示可能会混乱。


+-*/+-*/linespace o 字符之间的像素行数
						*'linespace'* *'lsp'*
'linespace' 'lsp'	数值型	(缺省为 0，Win32 GUI 为 1)
			全局
			{Vi 无此功能}
			{仅有 GUI 里才支持}
	字符之间插入的像素行数。如果所用字体占用全部字符单元的高度，使得行与行
	之间互相接触到，这会有用。
	如果非零，有下划线的空间。
	有些字体的行间距可能又过大 (为了给 ascent 和 descent 留出空间)。这时给
	'linespace' 赋负值可能有意义。不过这样显示可能会有问题！


+-*/+-*/macatsui o Mac GUI: 使用 ATSUI 文本绘制
						*'macatsui'* *'nomacatsui'*
'macatsui'		布尔型	(缺省打开)
			全局
			{仅用于 Mac GUI 版本}
	这是绘制不能正确工作时的一个临时解决方法。如果置位并且编译时加入多字节
	支持，使用 ATSUI 文本绘制。如果不置位，不使用 ATSUI 文本绘制。如果你遇
	到绘制的问题，关闭此选项。将来的版本可能会解决这个问题，那时此选项就会
	被废弃。如果这样，用此方法来进行复位: >
		if exists('&macatsui')
		   set nomacatsui
		endif
<	另一个可以检查是否有绘制问题的选项是 'termencoding'。


+-*/+-*/menuitems o 菜单可用的最大项目数
						*'menuitems'* *'mis'*
'menuitems' 'mis'	数值型	(缺省为 25)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+menu| 特性才有效}
	菜单可用的最大项目数量。用于从项目列表生成的菜单，比如 Buffers 菜单。
	改变此选项不会立即生效，刷新菜单后才可以。


+-*/+-*/mouse o 允许使用鼠标点击
						*'mouse'* *E538*
'mouse'			字符串	(缺省为 ""，GUI、MS-DOS 和 Win32 为 "a")
			全局
			{Vi 无此功能}
	允许使用鼠标。只可用于特定终端 (xterm、MS-DOS、Win32 |win32-mouse|、
	QNX pterm、带 sysmouse 的 *BSD 控制台 和带 gpm 的 Linux 控制台)。关于
	GUI 里如何使用鼠标，见 |gui-mouse|。
	可以为不同模式分别打开鼠标:
		n	普通模式
		v	可视模式
		i	插入模式
		c	命令行模式
		h	编辑帮助文件时，所有前面的模式
		a	所有前面的模式
		r	|hit-enter| 和 |more-prompt| 提示时
	通常你会这样为所有四个模式打开鼠标: >
		:set mouse=a
<	如果鼠标没有打开，GUI 仍然使用鼠标进行无模式的选择。此行为不会移动文本
	光标。

	见 |mouse-using|。另见 |'clipboard'|。

	注意: 在终端里打开鼠标时，如果能连接到 X 服务器，复制/粘贴会使用 * 寄
	存器。按住 Shift 键仍然可以使用 xterm 对鼠标按钮的处理。
	另见 'clipboard' 选项。


+-*/+-*/mousefocus o 键盘焦点追随鼠标点击
			*'mousefocus'* *'mousef'* *'nomousefocus'* *'nomousef'*
'mousefocus' 'mousef'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅适用于 GUI}
	自动激活鼠标指针所在的窗口。如果改变窗口布局或用别的方式改变窗口焦点，
	鼠标指针移动到带有键盘焦点的窗口。缺省是关闭的，因为它使得下拉菜单操作
	不太舒服，不小心移动鼠标会意外地激活窗口。


+-*/+-*/mousehide o 输入时隐藏鼠标指针
			*'mousehide'* *'mh'* *'nomousehide'* *'nomh'*
'mousehide' 'mh'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
			{仅适用于 GUI}
	如果打开，输入字符时隐藏鼠标指针。鼠标移动时恢复鼠标指针。


+-*/+-*/mousemodel o 改变鼠标按钮的含义
						*'mousemodel'* *'mousem'*
'mousemodel' 'mousem'	字符串	(缺省为 "extend"，MS-DOS 和 Win32 为 "popup")
			全局
			{Vi 无此功能}
	设置鼠标使用的模型。这些名字主要用来设定鼠标右键的用途:
	   extend	鼠标右键扩展选择区。这种工作方式和 xterm 类似。
	   popup	鼠标右键弹出菜单。Shift + 鼠标左键扩展选择区。这种工作
			方式和 Microsoft Windows 类似。
	   popup_setpos 类似于 "popup"，但光标移动到鼠标点击的地方，因而菜单选
			择的操作会根据点击的对象而定。如果在选择区内点击，那么
			使用选择区进行操作而没有光标移动。当然这也意味着，在选
			择区之外点击右键会结束可视模式。
	在不同模型下，按钮工作方式的总览:
	鼠标		    extend		popup(_setpos) ~
	左键点击	    放置光标		放置光标
	左键拖动	    开始选择		开始选择
	Shift + 左键	    搜索单词		扩展选择
	右键点击	    扩展选择		弹出菜单 (放置光标)
	右键拖动	    扩展选择		-
	中键点击	    粘贴		粘贴

	在 "popup" 模型里，鼠标右键产生一个弹出式菜单。你需要先定义此菜单，见
	|popup-menu|。

	注意 你可以接着用映射重定义按钮的含义。见 |gui-mouse-mapping|。但映射
	_不_用于无模式的选择 (因为这是 GUI 代码直接处理的)。

	|:behave| 命令设置 'mousemodel' 选项。


+-*/+-*/mouseshape o 不同模式下改变鼠标指针的形状
					*'mouseshape'* *'mouses'* *E547*
'mouseshape' 'mouses'	字符串	(缺省为 "i:beam,r:beam,s:updown,sd:cross,
					m:no,ml:up-arrow,v:rightup-arrow")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+mouseshape| 特性才有效}
	本选项指示 Vim 鼠标指针在不同的模式里应有的外观。它是逗号分隔的部分列
	表，和 'guicursor' 所用的类似。每个部分由模式/位置列表和参数列表组成:
		模式列表:外型,模式列表:外型,..
	"模式列表" 是指连字符分隔的下面这些模式/位置的列表:
			普通窗口里: ~
		n	普通模式
		v	可视模式
		ve	可视模式，仅限于 'selection' 为 "exclusive" 时 (如果不
			是，和 'v' 相同)
		o	操作符等待模式
		i	插入模式
		r	替换模式

			其它: ~
		c	在命令行上附加
		ci	在命令行上插入
		cr	在命令行上替换
		m	在 'Hit ENTER' 或 'More' 等提示上
		ml	同上，但光标在最后一行
		e	任何模式，指针在最后一个窗口之下
		s	任何模式，指针在状态行上
		sd	任何模式，拖动状态行时
		vs	任何模式，指针在垂直分割线上
		vd	任何模式，拖动垂直分割线时
		a	所有地方

	外型可从下表选一:
	可用	名字		看起来像 ~
	w x	arrow		普通鼠标箭头
	w x	blank		没有指针 (小心使用！)
	w x	beam		I 型横梁
	w x	updown		上下改变大小的指针
	w x	leftright	左右改变大小的指针
	w x	busy		系统通常的忙指针
	w x	no		系统通常的 '没有输入' 指针
	  x	udsizing	指示上下改变大小
	  x	lrsizing	指示左右改变大小
	  x	crosshair	像一个大而细的 +
	  x	hand1		黑色的手
	  x	hand2		白色的手
	  x	pencil		你用来书写的东西
	  x	question	大的 ?
	  x	rightup-arrow	指向右上方的箭头
	w x	up-arrow	指向上方的箭头
	  x	<number>	X11 指针号 (见 X11/cursorfont.h)

	"可用" 列包含 'w' 意味该外型可用于 Win32，x 代表 X11。
	任何没有指定的模式或者不可用的外型都会使得普通鼠标指针被使用。

	例如: >
		:set mouseshape=s:udsizing,m:no
<	会使得鼠标在状态行上变成上下改变大小的箭头，在 hit-enter 提示显示时指
	示没有输入 (因为此状态下，点击鼠标没有作用。)


+-*/+-*/mousetime o 鼠标双击之间的最大时间
						*'mousetime'* *'mouset'*
'mousetime' 'mouset'	数值型	(缺省为 500)
			全局
			{Vi 无此功能}
	只限于 GUI、MS-DOS、Win32 和使用 xterm 的 Unix。定义两个鼠标点击之间最
	大的使第二击被识别为多击的毫秒数。


+-*/+-*/paste o 允许粘贴文本
						*'paste'* *'nopaste'*
'paste'			布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	将 Vim 切换到粘贴模式。可用于从一个窗口剪切或复制文本并粘贴到 Vim。它
	的使用会避免一些意想不到的效果。
	设置此选项可用于终端上运行的 Vim，因为那里 Vim 没法区别输入和粘贴的文
	本。在 GUI 里，Vim 知道何者来自粘贴，即使不打开 'paste' 也基本上不会做
	错。对 Vim 能自己处理鼠标点击的终端也是如此。
	启动 GUI 时复位本选项。所以如果你在 .vimrc 里置位它，可以使它在终端里
	工作，但不是在 GUI 里。在 GUI 里置位 'paste' 有副作用: 例如，Paste 工
	具栏按钮在插入模式下不能工作，因为它使用了映射。
	打开 'paste' 选项时 (包括它本来就是打开的也会如此):
		- 屏蔽插入模式和命令行模式的映射
		- 屏蔽缩写
		- 'textwidth' 设为 0
		- 'wrapmargin' 设为 0
		- 'autoindent' 被复位
		- 'smartindent' 被复位
		- 'softtabstop' 设为 0
		- 'revins' 被复位
		- 'ruler' 被复位
		- 'showmatch' 被复位
		- 'formatoptions' 的使用方式就像它为空一样
	下面这些选项保持原来的值，但没有实际的效果:
		- 'lisp'
		- 'indentexpr'
		- 'cindent'
	注意: 打开 'paste' 选项时如果你开始编辑别的文件，模式行或者自动命令可
	能会再次改变这些设置，从而在粘贴文本时造成麻烦。这时，你可能需要再次置
	位 'paste' 选项。
	'paste' 选项复位时，上面提到的选项被复原为上次 'paste' 从关到开时的设
	置。置位 'paste' 之前复位 'paste' 没有任何效果。因为 'paste' 激活时不
	能用映射，'pastetoggle' 选项可以用来指定切换 'paste' 选项的热键。


+-*/+-*/pastetoggle o 切换 'paste' 的键盘代码
						*'pastetoggle'* *'pt'*
'pastetoggle' 'pt'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	如果非空，指定切换 'paste' 选项的键序列。类似于设定如下的映射: >
	    :map {keys} :set invpaste<CR>
<	其中的 {keys} 是 'pastetoggle' 的值。
	区别是，即使 'paste' 置位以后，它仍然工作。'pastetoggle' 可用于插入模
	式和普通模式，但不能用于命令行模式。
	映射先检查，它可能会覆盖 'pastetoggle'。不过，打开 'paste' 时，插入模
	式里的映射被忽略，所以你可以这么做: >
	    :map <F10> :set paste<CR>
	    :map <F11> :set nopaste<CR>
	    :imap <F10> <C-O>:set paste<CR>
	    :imap <F11> <nop>
	    :set pastetoggle=<F11>
<	这使得 <F10> 开始粘贴模式而 <F11> 终止粘贴模式。
	注意 在粘贴模式里输入 <F10> 会插入 "<F10>"。因为在粘贴模式里，除了
	'pastetoggle' 键序列以外，一切都是按本义插入的。
	如果该值需要若干字节，适用 'ttimeoutlen'。


+-*/+-*/promptfind c 打开 GUI 对话框进行搜索
							*:pro* *:promptfind*
:promptf[ind] [string]
			弹出搜索对话框。如果给出 [string]，它被用作初始的搜索
			字符串。
			{仅适用于 Win32、Motif 和 GTK GUI 环境}

+-*/+-*/promptrepl c 打开 GUI 对话框进行搜索/替代
						*:promptr* *:promptrepl*
:promptr[epl] [string]
			弹出搜索/替代对话框。如果给出 [string]，它被用作初始的
			搜索字符串。
			{仅适用于 Win32、Motif 和 GTK GUI 环境}

+-*/+-*/selection o 使用何种选择方式
						*'selection'* *'sel'*
'selection' 'sel'	字符串	(缺省为 "inclusive")
			全局
			{Vi 无此功能}
	本选项定义选择区的行为。只有可视和选择模式使用该选项。
	可能的值:
	   值		  越行	      闭区间 ~
	   old		   否		是
	   inclusive	   是		是
	   exclusive	   是		否
	"越行" 意味着光标是否允许定位在行后一个字符的地方。
	"闭区间" 意味着选择区的最后一个字符包含在操作范围之内。比如，用 "x" 删
	除选择区时。
	注意 如果从普通模式开始、'virtualedit' 为空、使用 "exclusive" (开区间)
	而从行尾开始反向选择，你无法包含行尾的字符。

	|:behave| 命令设置 'selection' 选项。


+-*/+-*/selectmode o 何时使用选择模式而不是可视模式
						*'selectmode'* *'slm'*
'selectmode' 'slm'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	这是逗号分隔的单词列表，指定什么场合开始选择时启动选择模式而不是可视模
	式。
	可能的值:
	   mouse	使用鼠标时
	   key		使用 Shift + 特殊键时
	   cmd		使用 "v"、"V" 或 CTRL-V 时
	见 |Select-mode|。
	|:behave| 命令设置 'selectmode' 选项。


+-*/+-*/simalt c Win32 GUI: 模拟 Windows ALT 键
							*:simalt* *:si*
:si[malt] {key}		模拟 Alt-{key} 组合键。
			{Vi 无此功能} {仅适用 Win32 版本}

+-*/+-*/title o 让 Vim 设置窗口标题
						*'title'* *'notitle'*
'title'			布尔型	(缺省关闭，标题能恢复时打开)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+title| 特性才有效}
	如果打开，窗口标题会被设为 'titlestring' 的值 (如果非空的话)，否则:
		filename [+=-] (path) - VIM
	其中:
		filename	编辑的文件名
		-		指示文件不能修改，'ma' 关闭
		+		指示文件已被修改
		=		指示文件只读
		=+		指示文件只读并且被修改
		(path)		被编辑文件的路径
		- VIM		服务器名 |v:servername| 或为 "VIM"
	只有终端支持设置窗口标题时才可用 (目前有 Amiga 控制台、Win32 控制台、
	所有的 GUI 版本和带有非空的 't_ts' 选项的终端 - 缺省情况下，它们是
	Unix xterm 和 iris-ansi，其中 't_ts' 从内建的 termcap 读取)。
								*X11*
	如果 Vim 编译时定义 HAVE_X11，在可能的情况下会恢复原先的标题。
	":version" 的输出会在 HAVE_X11 有定义时包含 "+X11"，否则将是 "-X11"。
	这也适用于图标名字 |'icon'|。
	不过: 如果 Vim 启动时带 |-X| 参数，标题无法恢复 (除了 GUI 以外)。如果
	标题无法恢复，它被设为 'titleold' 的值。那时，你可能希望在 Vim 之外恢
	复标题。
	如果在远程的机器上使用 xterm，你可以使用命令:
	    rsh machine_name xterm -display $DISPLAY &
	那么应该会继承 WINDOWID 环境变量，而窗口的标题在退出 Vim 之后应该会换
	回原先的值。


+-*/+-*/titlelen o 用于窗口标题的 'columns' 比例
								*'titlelen'*
'titlelen'		数值型	(缺省为 85)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+title| 特性才有效}
	给出 'columns' 的一个百分比，用于窗口标题的长度。如果标题较之更长，只
	有路径的尾部会被显示。路径名字前面的 '<' 字符用于指示这种情况。使用百
	分比使得这和窗口的宽度相适应。但这并不完美，因为实际的字符数也取决于使
	用的字体还有标题栏的其它部分。如果 'titlelen' 为零，使用完整的路径。不
	然，可以使用百分之 1 到 30000 的值。
	'titlelen' 也用于 'titlestring' 选项。


+-*/+-*/titleold o 旧的标题，用于退出时恢复
						*'titleold'*
'titleold'		字符串	(缺省为 "Thanks for flying Vim")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+title| 特性才有效}
	退出 Vim 时如果无法恢复原来的标题，使用本选项。这只会在 'title' 打开或
	'titlestring' 不为空时发生。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/titlestring o 用于 Vim 窗口标题的字符串
						*'titlestring'*
'titlestring'		字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+title| 特性才有效}
	如果此选项不为空，用来设置窗口的标题。只有在 'title' 选项打开时才会发
	生。
	只有终端支持设置窗口标题时才可用 (目前有 Amiga 控制台、Win32 控制台、
	所有的 GUI 版本和带有非空的 't_ts' 选项的终端)。
	如果 Vim 编译时定义 HAVE_X11，在可能的情况下恢复原来的标题 |X11|。
	如果本选项包含 printf 风格的 '%' 项目，依照 'statusline' 使用的规则进
	行扩展。
	例如: >
    :auto BufEnter * let &titlestring = hostname() . "/" . expand("%:p")
    :set title titlestring=%<%F%=%l/%L-%P titlelen=70
<	'titlelen' 的值用来在可用空间的中间或右侧对齐项目。
	有的人喜欢文件名放在前面: >
    :set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
<	注意 "%{ }" 的使用，以及用于得到不含文件名的文件名路径的表达式。只有在
	必要时，"%( %)" 构造才会加入分隔的空格。
	注意: 'titlestring' 使用特殊字符可能会使显示引起混乱 (比如，如果它包含
	CR 或者 NL 字符的话)。
	{仅当编译时加入 |+statusline| 特性才有效}


+-*/+-*/winaltkeys o 何时窗口系统处理 ALT 键
						*'winaltkeys'* *'wak'*
'winaltkeys' 'wak'	字符串	(缺省为 "menu")
			全局
			{Vi 无此功能}
			{仅适用于 Win32、Motif、GTK 和 Photon GUI}
	有的 GUI 版本允许用 ALT 键和菜单中下划线标出的字符的组合来访问菜单项。
	这和使用 ALT 键进行映射和输入特殊字符冲突。本选项指定此时如何做:
	  no	不用 ALT 键访问菜单。ALT 键组合可以被映射，但不会自动处理。之
		后可以用 |:simalt| 命令来完成。
	  yes	ALT 键的处理由窗口系统完成。ALT 键的组合不能被映射。
	  menu	使用 ALT 和菜单快捷键字符的组合会被窗口系统处理。其余的键仍然
		可以被映射。
	如果用 'guioptions' 里排除 'm' 的方式来屏蔽菜单，ALT 键决不会被菜单所
	使用。
	此选项不用于 <F10>；在 Win32 和 GTK 上，<F10> 会选择菜单，除非它被映
	射。


+-*/+-*/winpos c 取得或者设置窗口位置
						*:winp* *:winpos* *E188*
:winp[os]
		显示 GUI vim 窗口以像素计的当前左上角位置。并非在所有系统上都
		可以。

+-*/+-*/menu _ 菜单
+-*/+-*/+-*/amenu c 为所有模式输入菜单项
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/anoremenu c 为所有模式输入菜单项，不会被重新映射
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/aunmenu c 删除所有模式下的菜单
						*:aun*   *:aunmenu*
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/emenu c 按名字执行菜单
						*:em*  *:emenu* *E334* *E335*
:[range]em[enu] {menu}		从命令行上执行 {menu} 菜单。缺省执行普通模式的
				命令。如果给出行范围 range，执行可视模式的菜
				单。
				如果从 <c-o> 那里调用，执行插入模式命令。例如:
>
	:emenu File.Exit

+-*/+-*/+-*/imenu c 为插入模式增加菜单
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/inoremenu c 类似于 "":noremenu""，但用于插入模式
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/iunmenu c 删除插入模式的菜单
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/menu c 输入新的菜单项
				*:me*  *:menu*  *:noreme*  *:noremenu*
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

   :menu File.Save  :w<CR>
   :inoremenu File.Save  <C-O>:w<CR>
   :menu Edit.Big\ Changes.Delete\ All\ Spaces  :%s/[ ^I]//g<CR>

最后一项会在菜单栏里创建一个新的项目 "Edit"，在它上面按下鼠标键，会弹出菜单，
里面包含 "Big Changes" 一项，这又是包含 "Delete All Spaces" 项的一个子菜单。如
果选择了该项，执行操作。

菜单名里可用的特殊字符:

	&	下一个字符是快捷键。确信该快捷键在 (子) 菜单里只使用一次。如果
		你想插入按本义出现的 "&"，使用 "&&"。
	<Tab>	分隔菜单名和右对齐的文本。这被用来显示等价的命令输入。为了方便
		起见，这里可以使用文本 "<Tab>"。如果你使用真正的制表键，别忘了
		在前面加上反斜杠！
示例: >

   :amenu &File.&Open<Tab>:e  :browse e<CR>

+-*/+-*/+-*/nmenu c 为普通模式增加菜单
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/nnoremenu c 类似于 "":noremenu""，但使用普通模式
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/noremenu c 输入不会被重新映射的菜单
				*:me*  *:menu*  *:noreme*  *:noremenu*
				*:am*  *:amenu* *:an*      *:anoremenu*
				*:nme* *:nmenu* *:nnoreme* *:nnoremenu*
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/nunmenu c 删除普通模式的菜单
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/omenu c 为操作符等待模式增加菜单
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/onoremenu c 类似于 "":noremenu""，但使用操作符等待模式
				*:ome* *:omenu* *:onoreme* *:onoremenu*
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/ounmenu c 删除操作符等待模式的菜单
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/popup c 根据名字弹出菜单
							*:popup* *:popu*
:popu[p] {name}			弹出菜单 {name}。菜单名必须有至少一项子项，但
				不一定需要出现在菜单栏上 (见 |hidden-menus|)。
				{仅在 Win32 和 GTK GUI 上有效}

+-*/+-*/+-*/smenu c 增加选择模式菜单
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/snoremenu c 类似于 "":noremenu""，但用于选择模式
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/sunmenu c 删除选择模式的菜单
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/tearoff c 撕下一个菜单
							*:tearoff* *:te*
:te[aroff] {name}	撕下菜单 {name}。菜单中必须至少有一个选项，但是不必出
			现在主菜单栏里 (参见 |win32-hidden-menus|)。

+-*/+-*/+-*/tmenu c 定义菜单的工具提示
							*:tmenu* *:tm*
:tm[enu] {menupath} {rhs}	为菜单或者工具定义提示。{仅存在于 X11 和 Win32
				GUI}

+-*/+-*/+-*/toolbar o GUI: 工具栏显示何种项目
				*'toolbar'* *'tb'*
'toolbar' 'tb'		字符串	(缺省为 "icons,tooltips")
			全局
			{仅适用于 |+GUI_GTK|、|+GUI_Athena|、|+GUI_Motif| 和
			|+GUI_Photon|}
	该选项的内容控制若干工具栏的设置。可能的值是:
		icons		工具栏按钮使用图标显示。
		text		工具栏按钮使用文字显示。
		horiz		工具栏按钮使用水平排放的图标和文本。{仅适用于
				GTK+ 2 GUI}
		tooltips	激活工具栏按钮的工具提示。
	工具提示指的是鼠标光标在工具栏按钮上停留短暂的时间后弹出的帮助文本。

	如果你希望工具栏同时显示图标和文本，这么做: >
		:set tb=icons,text
<	Motif 和 Athena 不能同时显示图标和文本。如果两者都被请求，只显示图标。

	如果 'toolbar' 指定的字符串都不合法或者 'toolbar' 为空，本选项被忽略。
	如果你想关闭工具栏，需要设置 'guioptions' 选项。例如: >
		:set guioptions-=T
<	另见 |gui-toolbar|。


+-*/+-*/+-*/toolbariconsize o 工具栏图标的大小 (只适用于 GTK 2)
						*'toolbariconsize'* *'tbis'*
'toolbariconsize' 'tbis'	字符串	(缺省为 "small")
				全局
				{Vi 无此功能}
				{仅用于 GTK+ 2 GUI}
	控制工具栏图标的大小。可能的值是:
		tiny		使用微小工具栏图标。
		small		使用小工具栏图标 (缺省)。
		medium		使用中等大小的工具栏图标。
		large		使用大型的工具栏图标。
	准确的以像素点计算的尺寸取决于当前使用的主题。常见的大小为
	large=32x32，medium=24x24，small=20x20 和 tiny=16x16。

	如果 'toolbariconsize' 为空，使用用户偏好里设定的全局缺省大小，或者应
	用当前的主题。


+-*/+-*/+-*/tunmenu c 删除菜单的工具提示
							*:tunmenu* *:tu*
:tu[nmenu] {menupath}		删除菜单或者工具的提示。{仅存在于 X11 和 Win32
				GUI}

+-*/+-*/+-*/unmenu c 删除菜单
						*:unme*  *:unmenu*
						*:aun*   *:aunmenu*
						*:nunme* *:nunmenu*
						*:ounme* *:ounmenu*
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/vmenu c 为可视+选择模式增加菜单
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/vnoremenu c 类似于 "":noremenu""，但使用可视+选择模式
				*:vme* *:vmenu* *:vnoreme* *:vnoremenu*
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/vunmenu c 删除可视+选择模式的菜单
						*:vunme* *:vunmenu*
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/+-*/xmenu c 增加可视模式的菜单
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/xnoremenu c 类似于 "":noremenu""，但使用可视模式
				*:xme* *:xmenu* *:xnoreme* *:xnoremenu*
				*:sme* *:smenu* *:snoreme* *:snoremenu*
				*:ime* *:imenu* *:inoreme* *:inoremenu*
				*:cme* *:cmenu* *:cnoreme* *:cnoremenu*
				*E330* *E327* *E331* *E336* *E333*
				*E328* *E329* *E337* *E792*
要创建新的菜单项，使用 ":menu" 命令群。它们和 ":map" 命令群非常类似，但是第一
个参数是菜单项名。形式为 '.' 分隔的菜单或子菜单的路径，例如: >

+-*/+-*/+-*/xunmenu c 删除可视模式的菜单
						*:xunme* *:xunmenu*
						*:sunme* *:sunmenu*
						*:iunme* *:iunmenu*
						*:cunme* *:cunmenu*
要删除一个菜单项或者整个子菜单，使用 umenu 命令，类似于 unmap 命令。例如: >
    :unmenu! Edit.Paste

+-*/+-*/tab _ 标签页
+-*/+-*/+-*/guitablabel o GUI: 标签页定制的标签
						*'guitablabel'* *'gtl'*
'guitablabel' 'gtl'	字符串	(缺省为空)
			全局
			{Vi 无此功能}
			{仅当编译时加入 GUI 的支持和 |+windows| 特性时才有效}
	如果非空，描述 GUI 标签页行使用的标签的文本。如果为空或结果为空，Vim 
	使用缺省的标签。详情见 |setting-guitablabel|。

	此选项的格式类似于 'statusline'。
	'guitabtooltip' 用于工具提示，见下。

	只有显示 GUI 标签页的时候才用到。'guioptions' 必须包含 'e'。非 GUI 的
	标签页行使用 'tabline'。


+-*/+-*/+-*/guitabtooltip o GUI: 标签页定制的工具提示
						*'guitabtooltip'* *'gtt'*
'guitabtooltip' 'gtt'	字符串	(缺省为空)
			全局
			{Vi 无此功能}
			{仅当编译时加入 GUI 的支持和 |+windows| 特性时才有效}
	如果非空，描述 GUI 标签页行使用的工具提示文本。如果为空，Vim 使用缺省
	的工具提示。
	此选项的其它方面类似于上面的 'guitablabel'。
	可以包含换行符。最简单的方法是用 |:let|: >
		:let &guitabtooltip = "line one\nline two"
<


+-*/+-*/+-*/showtabline o 是否显示标签页行
						*'showtabline'* *'stal'*
'showtabline' 'stal'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	本选项的值指定何时显示带有标签页标签的行:
		0: 永远不会
		1: 至少有两个标签页时才会
		2: 永远会
	标签页行有 GUI 和非 GUI 两种实现。
	|tab-page| 解释标签页的更多信息。


+-*/+-*/+-*/tab c 打开新窗口时建立新的标签页
:[count]tab {cmd}					*:tab*
		执行 {cmd}，如果它打开新窗口，使用新标签页代替。不能用于
		|:diffsplit|、|:diffpatch|、|:execute| 和 |:normal|。
		如果省略 [count]，标签页出现在当前标签页之后。
		如果指定 [count]，新标签页出现在第 [count] 个标签页之后。
		":0tab cmd" 使新标签页出现在第一个位置。
		例如: >
			:tab split	" 在新标签页上打开当前缓冲区
			:tab help gt	" 打开标签页显示 "gt" 的帮助

+-*/+-*/+-*/tabNext c 跳到上一个标签页
:tabN[ext]				*:tabNext* *CTRL-<PageUp>*
<C-PageUp>			 *<C-PageUp>* *i_CTRL-<PageUp>* *i_<C-PageUp>*
gT		转到前一个标签页。首个标签页则回绕到最后一个。

+-*/+-*/+-*/tabclose c 关闭当前标签页
							*:tabc* *:tabclose*
:tabc[lose][!]	关闭当前标签页。
		如下情形使该命令失败:
		- 屏幕上只有一个标签页。				*E784*
		- 如果 'hidden' 没有置位，没有 [!]，缓冲区有修改，而且该缓冲区
		  没有其它窗口。
		缓冲区的修改不会被写入，也不会丢失。所以这可以说是个 "安全的"
		命令。

+-*/+-*/+-*/tabdo c 为每个标签页执行命令
							*:tabd* *:tabdo*
:tabd[o] {cmd}	对每个标签页执行 {cmd}。
		大致相当于: >
			:tabfirst
			:{cmd}
			:tabnext
			:{cmd}
			等等
<		只对每个标签页的当前窗口进行操作。如果某个标签页出现错误，不再
		继续访问其余的标签页。
		最后一个标签页 (或任何出错的标签页) 成为当前标签页。
		{cmd} 可以包含 '|' 以连接多个命令。
		{cmd} 不能打开标签页、关闭标签页或重排标签页。
		{Vi 无此功能} {仅当编译时加入 |+listcmds| 特性才有效}
		另见 |:windo|、|:argdo| 和 |:bufdo|。

+-*/+-*/+-*/tabedit c 在新标签页里编辑文件
:[count]tabe[dit]				*:tabe* *:tabedit* *:tabnew*
:[count]tabnew
		在当前标签页之后打开带空窗口的新标签页。关于 [count] 见下面的
		|:tab|。

+-*/+-*/+-*/tabfind c 寻找 'path' 里的文件，在新标签页里编辑之
:[count]tabf[ind] [++opt] [+cmd] {file}			*:tabf* *:tabfind*
		打开新标签页并编辑 'path' 里的 {file}，其余和 |:find| 类同。关
		于 [count] 见下面的 |:tab|。
		{仅当编译时加入 |+file_in_path| 特性才有效}

+-*/+-*/+-*/tabfirst c 转到第一个标签页
:tabr[ewind]			*:tabfir* *:tabfirst* *:tabr* *:tabrewind*
:tabfir[st]	转到第一个标签页。

+-*/+-*/+-*/tablast c 转到最后一个标签页
							*:tabl* *:tablast*
:tabl[ast]	转到最后一个标签页。

+-*/+-*/+-*/tabline o 终端标签页行的定制格式
						*'tabline'* *'tal'*
'tabline' 'tal'		字符串	(缺省为空)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	如果非空，此选项决定 Vim 窗口顶部标签页行的内容。如果为空，Vim 使用缺
	省的标签页行。详见 |setting-tabline|。

	只有符合 'showtabline' 选项的要求而且没有 GUI 标签页行时才显示这里的标
	签页行。如果 'guioptions' 里包含 'e' 且 GUI 支持标签页行，用
	'guioptions' 代替。

	此值的计算类似于 'statusline'。你可以用 |tabpagenr()|、
	|tabpagewinnr()| 和 |tabpagebuflist()| 来决定要显示的文本。用 "%1T" 来
	指定第一个标签，"%2T" 第二个，依此类推。用 "%X" 项目指定关闭的标签。

	记住只有一个标签页是当前标签页，其它标签页都是不可见的，你不能调到它们
	的窗口里。



+-*/+-*/+-*/tabmove c 把标签页移到别的位置
:tabm[ove] [N]						*:tabm* *:tabmove*
		把当前标签页移到第 N 个标签页之后。用 0 使当前标签页成为首个标
		签页。如果没有 N，当前标签页成为最后一个。

+-*/+-*/+-*/tabnew c 在新标签页里编辑文件
:[count]tabe[dit]				*:tabe* *:tabedit* *:tabnew*
:[count]tabnew
		在当前标签页之后打开带空窗口的新标签页。关于 [count] 见下面的
		|:tab|。

+-*/+-*/+-*/tabnext c 转到下一个标签页
:tabn[ext]				*:tabn* *:tabnext* *gt*
<C-PageDown>				*CTRL-<PageDown>* *<C-PageDown>*
gt					*i_CTRL-<PageDown>* *i_<C-PageDown>*
		转到下一个标签页。最后一个标签页则回绕到第一个。

+-*/+-*/+-*/tabonly c 关闭所有除了当前标签页以外的所有标签页
							*:tabo* *:tabonly*
:tabo[nly][!]	关闭所有其它的标签页。
		如果置位 'hidden' 选项，所有关闭窗口的缓冲区成为隐藏。
		如果没有置位 'hidden' 但置位 'autowrite' 选项，写回修改过的缓
		冲区。否则，包含修改过的缓冲区的窗口不会被删除。但如果给出
		[!]，这些窗口成为隐藏。修改过的缓冲区永远不会被放弃，所以永远
		不被丢失这些改动。

+-*/+-*/+-*/tabpagemax o |-p| 和 ""tab all"" 的最大标签页数
						*'tabpagemax'* *'tpm'*
'tabpagemax' 'tpm'	数值型	(缺省为 10)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	|-p| 命令行参数或 ":tab all" 命令打开的最大标签页数。|tabpage|



+-*/+-*/+-*/tabprevious c 转到前一个标签页
:tabp[revious]				*:tabp* *:tabprevious* *gT* *:tabN*
:tabN[ext]				*:tabNext* *CTRL-<PageUp>*
<C-PageUp>			 *<C-PageUp>* *i_CTRL-<PageUp>* *i_<C-PageUp>*
gT		转到前一个标签页。首个标签页则回绕到最后一个。

+-*/+-*/+-*/tabrewind c 转到第一个标签页
:tabr[ewind]			*:tabfir* *:tabfirst* *:tabr* *:tabrewind*
:tabfir[st]	转到第一个标签页。

+-*/+-*/+-*/tabs c 列出标签页以及里面包含的内容
							*:tabs*
:tabs		列出标签页和它们包含的窗口。
		当前窗口显示 ">"。
		修改过的缓冲区显示 "+"。

+-*/indent _ 缩进
+-*/+-*/autoindent o 根据上一行决定新行的缩进
			*'autoindent'* *'ai'* *'noautoindent'* *'noai'*
'autoindent' 'ai'	布尔型	(缺省关闭)
			局部于缓冲区
	开启新行时 (插入模式下输入 <CR>，或者使用 "o" 或 "O" 命令)，从当前行复
	制缩进距离。如果你在新行除了 <BS> 或 CTRL-D 以外不输入任何东西，然后输
	入 <Esc>、CTRL-O 或 <CR>，缩进又被删除。移动光标到其它行也有同样的效
	果，除非 'cpoptions' 里包含 'I' 标志位。
	如果打开自动缩进，排版 (用 "gq" 命令或者插入模式下到达了 'textwidth')
	使用第一行的缩进距离。
	打开 'smartindent' 或 'cindent' 时，缩进的修改方式有所不同。
	置位 'paste' 选项时，'autoindent' 选项被复位。
	{Vi 稍有不同: Vim 里输入 <Esc> 或 <CR> 删除缩进后，上下移动把光标放在
	删除的缩进之后；Vi 则把光标放在已删除的缩进的某处}。
	

+-*/+-*/cindent f 根据 C 缩进法则的某行的缩进
cindent({lnum})						*cindent()*
		得到第 {lnum} 行根据 C 缩进规则应有的缩进距离，见 'cindent'。
		缩进的计算以空格计，因而和 'tabstop' 的值是有关系的。{lnum} 的
		使用方式和 |getline()| 相同。
		如果 {lnum} 非法或者 Vim 编译时不带 |+cindent| 特性，返回 -1。
		见 |C-indenting|。


+-*/+-*/cindent o 实现 C 程序的缩进
				   *'cindent'* *'cin'* *'nocindent'* *'nocin'*
'cindent' 'cin'		布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+cindent| 特性才有效}
	打开自动 C 程序缩进。'cinkeys' 说明如何设置插入模式下启动重新缩进的热
	键，'cinoptions' 说明如何设置你喜欢的缩进风格。
	如果 'indentexpr' 非空，它否决 'cindent' 的设置。
	如果没有打开 'lisp'，而 'indentexpr' 和 'equalprg' 都为空，"=" 操作符
	使用本算法缩进，而不调用外部程序。
	见 |C-indenting|。
	如果你不喜欢 'cindent' 的工作方式，可以试试 'smartindent' 选项或者
	'indentexpr'。
	如果置位 'paste'，不使用本选项。
	注意: 如果置位 'compatible'，本选项被复位。


+-*/+-*/cinkeys o 设置 'cindent' 时启动缩进的键
							*'cinkeys'* *'cink'*
'cinkeys' 'cink'	字符串	(缺省为 "0{,0},0),:,0#,!^F,o,O,e")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+cindent| 特性才有效}
	键列表，在插入模式输入这些键时，当前行被重新缩进。只有打开 'cindent'
	而且 'indentexpr' 为空时才会用到。
	本选项的格式见 |cinkeys-format|。
	见 |C-indenting|。


+-*/+-*/cinoptions o 设置 'cindent' 时如何缩进
						*'cinoptions'* *'cino'*
'cinoptions' 'cino'	字符串	(缺省为 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+cindent| 特性才有效}
	'cinoptions' 影响 'cindent' 重新缩进 C 程序行的方式。
	|cinoptions-values| 说明如何设置本选项的值，而 |C-indenting| 提供总体
	的 C 缩进方式的信息。



+-*/+-*/cinwords o 'si' 和 'cin' 在这些词后加入额外的缩进
						*'cinwords'* *'cinw'*
'cinwords' 'cinw'	字符串	(缺省为 "if,else,while,do,for,switch")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时同时加入 |+cindent| 和 |+smartindent| 特性
			才有效}
	如果使用 'smartindent' 或 'cindent'，这些关键字在下一行开启额外的缩
	进。对于 'cindent'，只有在合适的地方才会这么做 (在 {} 里)。
	注意 'ignorecase' 对 'cinwords' 没有影响。如果希望忽略大小写，包含关键
	字所有的大小写: "if,If,IF"。


+-*/+-*/comments o 可以开始注释行的模式
					*'comments'* *'com'* *E524* *E525*
'comments' 'com'	字符串	(缺省
				"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+comments| 特性才有效}
	逗号分隔的可以开始注释行的字符串列表。见 |format-comments|。
	|option-backslash| 说明如何包含空格和使用反斜杠。


+-*/+-*/copyindent o 使得 'autoindent' 使用已有的缩进结构
			*'copyindent'* *'ci'* *'nocopyindent'* *'noci'*
'copyindent' 'ci'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
	自动缩进新行时，复制已有的行的缩进结构。通常，用连续的制表，必要时后面
	再跟若干空格，重新构造新缩进 (除非打开 |'expandtab'|，这时只用空格)。
	打开此选项使得新行准确地复制已有行中用来缩进的所有字符。'expandtab' 对
	这些字符没有影响，制表还是制表。如果新的缩进比已有行的缩进要多，多余部
	分的空白使用平常的填充方式。
	注意: 如果置位 'compatible'，'copyindent' 被复位。
	另见 'preserveindent'。


+-*/+-*/indent f 某行的缩进
indent({lnum})	返回数值，第 {lnum} 行的缩进距离。缩进的计算以空格计，因而它和
		'tabstop' 的值是有关系的。{lnum} 的使用方式和 |getline()| 相
		同。
		如果 {lnum} 非法，返回 -1。



+-*/+-*/indentexpr o 得到一行的缩进位置的表达式
						*'indentexpr'* *'inde'*
'indentexpr' 'inde'	字符串	(缺省为 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+cindent| 和 |+eval| 特性才有效}
	计算一行所需的缩进距离的表达式。在建立新行、|=| 操作符和插入模式下输入
	'indentkeys' 选项指定的热键时使用。
	如果此选项非空，它否决 'cindent' 和 'smartindent' 的缩进计算。
	如果置位 'paste'，不使用此选项来计算缩进。
	计算此表达式时，|v:lnum| 设为要计算缩进的行号。光标在计算表达式时也在
	该行上 (但此后可以移开)。
	表达式必须返回缩进对应的空格数目。它可以返回 "-1"，保持当前的缩进 (这
	意味着该缩进使用 'autoindent' 的计算)。
	计算缩进过程中，有用的函数包括 |indent()|、|cindent()| 和
	|lispindent()|。
	该表达式的计算不能有副作用！它不能改变文本，跳到别的窗口，等等。此后，
	光标的位置总是会被复原，所以光标可以移动。
	通常，设置该选项为一个函数的调用: >
		:set indentexpr=GetMyIndent()
<	除非 'debug' 选项包含 "msg"，错误信息会被压抑。
	见 |indent-expression|。
	注意: 如果置位 'compatible'，该选项被清空。

	可能在沙盘 |sandbox| 里计算此表达式。见 |sandbox-option|。

	计算 'indentexpr' 时不允许修改文本或者跳到其它窗口 |textlock|。



+-*/+-*/indentkeys o 使用 'indentexpr' 时启动缩进的键
						*'indentkeys'* *'indk'*
'indentkeys' 'indk'	字符串	(缺省为 "0{,0},:,0#,!^F,o,O,e")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+cindent| 特性才有效}
	热键的列表。在插入模式输入时，重新缩进当前行。只有在 'indentexpr' 不为
	空时才会发生。
	格式和 'cinkeys' 完全相同。见 |indentkeys-format|。
	见 |C-indenting| 和 |indent-expression|。


+-*/+-*/lisp o 自动 lisp 缩进
						*'lisp'* *'nolisp'*
'lisp'			布尔型	(缺省关闭)
			局部于缓冲区
			{仅当编译时加入 |+lispindent| 特性才有效}
	Lisp 模式: 如果在插入模式下输入 <Enter>，根据 Lisp 标准 (大致上) 设置
	下一行缩进。也用于 "cc" 或 "S"。
	必须打开 'autoindent' 才能使此选项工作。
	'cpoptions' 里的 'p' 标志位改变缩进的方法: Vi 兼容或者更好的方法。
	另见 'lispwords'。
	在关键字可用的字符里 ('iskeyword') 加入 '-' 字符。
	重定义 "=" 操作符，使用这里描述的缩进算法，而不是调用外部程序。
	如果置位 'paste'，不使用本选项。
	{Vi: 行为略有不同}


+-*/+-*/lispindent f 根据 Lisp 缩进法则的某行的缩进
lispindent({lnum})					*lispindent()*
		得到第 {lnum} 行根据 lisp 缩进规则应有的缩进距离，见 'lisp'。
		缩进的计算以空格计，因而和 'tabstop' 的值是有关系的。
		{lnum} 的使用方式和 |getline()| 相同。
		如果 {lnum} 非法或者 Vim 编译时不带 |+lispindent| 特性，返回
		-1。


+-*/+-*/lispwords o 改变 lisp 缩进方式的单词
						*'lispwords'* *'lw'*
'lispwords' 'lw'	字符串	(缺省很长)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+lispindent| 特性才有效}
	逗号分隔单词的列表，影响 Lisp 的缩进方式。|'lisp'|


+-*/+-*/preserveindent o 重排时保持原有的缩进结构
			*'preserveindent'* *'pi'* *'nopreserveindent'* *'nopi'*
'preserveindent' 'pi'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
	改变当前行缩进时，尽量保持缩进结构。通常，缩进被连续的制表，必要时后面
	再跟若干空格，来替换 (除非打开 |'expandtab'|，这时只使用空格)。打开此
	选项意味着缩进会保留尽可能多的已有字符，只有必要时才加入附加的制表或空
	格。
	对保持的空白不应用 'expandtab'，制表还是制表。
	注意: 多次使用 ">>" 产生的缩进是制表和空格的混合。你可能不喜欢这样。
	注意: 如果置位 'compatible'，'preserveindent' 被复位。
	另见 'copyindent'。
	使用 |:retab| 来清理空白。


+-*/+-*/smartindent o C 程序智能自动缩进
			     *'smartindent'* *'si'* *'nosmartindent'* *'nosi'*
'smartindent' 'si'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+smartindent| 特性才有效}
	开启新行时使用智能自动缩进。适用于 C 这样的程序，但或许也能用于其它语
	言。'cindent' 类似，它多数情况下更好，但更严格，见 |C-indenting|。如果
	打开 'cindent'，置位 'si' 没有效果。
	'indentexpr' 是更高级的替代方案。
	通常，使用 'smartindent' 时也应该打开 'autoindent'。
	在这些情况下自动插入缩进:
	- '{' 结束的行后。
	- 'cinwords' 中的某个关键字开始的行后。
	- '}' 开始的行前 (只有使用 "O" 命令才会)。
	在新行第一个输入的字符如果是 '}'，该行使用匹配的 '{' 相同的缩进。
	在新行第一个输入的字符如果是 '#'，该行的缩进被删除，'#' 被放到第一列。
	下一行上，恢复原来缩进。如果你不想这么做，使用下面的映射:
	":inoremap # X^H#"，其中的 ^H 用 CTRL-V CTRL-H 输入。
	使用 ">>" 命令时，'#' 开始的行不右移。
	注意: 如果置位 'compatible'，复位 'smartindent'。如果置位 'paste'，关
	闭这里的智能缩进功能。


+-*/map _ 键盘映射(命令行映射看cmd)
+-*/+-*/abbreviate c 输入缩写
						*:ab* *:abbreviate*
:ab[breviate]		列出所有的缩写。第一栏中的字符表示该缩写作用的模式:
			'i' 指插入模式，'c' 指命令行模式，'!' 指两种模式都有。
			这和映射的相同，参看 |map-listing| 。

+-*/+-*/abclear c 删除所有的缩写
							*:abc* *:abclear*
:abc[lear]		删除所有的缩写。{Vi 无此功能}

+-*/+-*/hasmapto f 检查映射是否存在
hasmapto({what} [, {mode} [, {abbr}]])			*hasmapto()*
		返回数值，如果存在某映射，其右边的表达式 (被映射到的部分) 的某
		处包含 {what}，并且该映射在 {mode} 指定的模式下存在，返回 1。
		如果提供 {abbr} 且非零，使用缩写而不是映射。不要忘记指定插入
		和/或命令行模式。
		同时检查全局映射和局部于当前缓冲区的映射以寻找匹配。
		如果没有匹配的映射，返回 0。
		{mode} 识别下列字符:
			n	普通模式
			v	可视模式
			o	操作符等待模式
			i	插入模式
			l	Language-Argument ("r"、 "f"、"t" 等等) 模式
			c	命令行模式
		如果没有提供 {mode}，使用 "nvo"。

		该函数可用于检查是否存在映射到 Vim 脚本的某个函数的映射。例
		如: >
			:if !hasmapto('\ABCdoit')
			:   map <Leader>d \ABCdoit
			:endif
<		这样，到 "\ABCdoit" 的映射只有在到 "\ABCdoit" 的映射还不存在的
		时候才会进行。

+-*/+-*/smap c 输入映射，但用于选择模式
:smap	{lhs} {rhs}		|mapmode-s|		      *:smap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/smapclear c 删除选择模式所有的映射
:smapc[lear]			|mapmode-s|		*:smapc*  *:smapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/snoremap c 输入映射，但用于选择模式，不递归
:snor[emap] {lhs} {rhs}		|mapmode-s|		*:snor* *:snoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

+-*/+-*/sunmap c 删除映射，但用于选择模式
:sunm[ap] {lhs}			|mapmode-s|		*:sunm* *:sunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/iabbrev c 输入缩写，但用于插入模式
						*:ia* *:iabbrev*
:ia[bbrev] [<expr>] [lhs] [rhs]
			与 ":ab" 一样，但仅在插入模式中使用。{Vi 无此功能}

缩写进行之后移动光标是可能的: >
   :iab if if ()<Left>
如果 'cpoptions' 里面包含 '<' 标志位时，这不能正常工作。|<>|

你甚至可以做更复杂的事情。例如，要消灭一个缩写后面输入的空格: >
   func Eatchar(pat)
      let c = nr2char(getchar(0))
      return (c =~ a:pat) ? '' : c
   endfunc
   iabbr <silent> if if ()<Left><C-R>=Eatchar('\s')<CR>

没有缺省的缩写。

缩写永远不会递归。你可以设置 ":ab f f-o-o" 而不会有任何问题。但是缩写能被映
射。{一些版本的 Vi 支持递归缩写，这毫无道理}

'paste' 选项打开时，缩写被禁止。

+-*/+-*/iabclear c 删除所有的缩写，但用于插入模式
							*:iabc* *:iabclear*
:iabc[lear]		为插入模式删除所有的缩写。{Vi 无此功能}

+-*/+-*/imap c 显示或者输入映射，但用于插入模式
:im[ap]	{lhs} {rhs}		|mapmode-i|		*:im* *:imap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。
"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/imapclear c 清除所有的映射，但用于插入模式
:imapc[lear]			|mapmode-i|		*:imapc*  *:imapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/inoreabbrev c 输入缩写，但用于插入模式，不递归
						*:inorea* *:inoreabbrev*
:inorea[bbrev] [<expr>] [lhs] [rhs]
			与 ":ab" 一样，但仅在插入模式中使用并且 {rhs} 不进行重
			映射。{Vi 无此功能}

+-*/+-*/inoremap c 输入映射，但用于插入模式，不递归
:ino[remap] {lhs} {rhs}		|mapmode-i|		*:ino* *:inoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/cabbrev c 输入缩写，但用于命令行模式
						*:ca* *:cabbrev*
:ca[bbrev] [<expr>] [lhs] [rhs]
			与 ":ab" 一样，但仅在命令行模式中使用。{Vi 无此功能}

+-*/+-*/cabclear c 清除所有缩写，用于命令行模式
							*:cabc* *:cabclear*
:cabc[lear]		为命令行模式删除所有的缩写。{Vi 无此功能}

+-*/+-*/cmap c 输入映射，但用于命令行模式
:cm[ap]	{lhs} {rhs}		|mapmode-c|		*:cm* *:cmap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/cmapclear c 清除所有映射，用于命令行模式
:cmapc[lear]			|mapmode-c|		*:cmapc*  *:cmapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/cnoreabbrev c 输入缩写，但用于命令行模式，不递归
						*:cnorea* *:cnoreabbrev*
:cnorea[bbrev] [<expr>] [lhs] [rhs]
			与 ":ab" 一样，但仅在命令行模式中使用并且 {rhs} 不进行
			重映射。{Vi 中无此功能}

+-*/+-*/cnoremap c 输入映射，但用于命令行模式，不递归
:cno[remap] {lhs} {rhs}		|mapmode-c|		*:cno* *:cnoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/cunabbrev c 删除缩写，但用于命令行模式
						*:cuna* *:cunabbrev*
:cuna[bbrev] {lhs}	与 ":una" 一样，但仅在命令行模式中使用。{Vi 无此功能}

+-*/+-*/cunmap c 删除映射，但用于命令行模式
:cu[nmap] {lhs}			|mapmode-c|		*:cu*   *:cunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/iunabbrev c 删除缩写，但用于插入模式
						*:iuna* *:iunabbrev*
:iuna[bbrev] {lhs}	与 ":una" 一样，但仅在插入模式中使用。{Vi 无此功能}

+-*/+-*/iunmap c 删除映射，但用于插入模式
:iu[nmap] {lhs}			|mapmode-i|		*:iu*   *:iunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/map c 显示或者输入映射
:map	{lhs} {rhs}		|mapmode-nvo|		*:map*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

						*:map-<special>* *:map-special*
定义映射时，特殊键可用 <> 记法，即使 'cpoptions' 包含了 "<" 标志位也没问题。这
可用于不希望看到设置 'cpoptions' 时出现的副作用的场合。例如: >
	:map <special> <F12> /Header<CR>
<
						*:map-<expr>* *:map-expression*
如果给用于定义新映射或缩写的命令的第一个参数是 "<expr>"，那么参数会作为表达式
来进行计算，结果作为实际使用的 {rhs}。例如: >
	:inoremap <expr> . InsertDot()
会插入 InsertDot() 函数的返回值。这可以用来检查光标之前的文本并在一定条件下启
动全能 (omni) 补全。

+-*/+-*/maparg f 取得映射的右部 (rhs)
maparg({name}[, {mode} [, {abbr}]])			*maparg()*
		返回模式 {mode} 名为 {name} 的映射的右边。如果没有名为 {name}
		的映射，返回空字符串。
		{mode} 可以使用下列字符串之一:
			n	普通模式
			v	可视模式
			o	操作符等待模式
			i	插入模式
			c	命令行模式
			l	Language-Argument ("r"、 "f"、"t" 等等) 模式
			""	普通、可视和操作符等待模式。
		如果没有提供 {mode}，使用 "" 指定的模式。
		如果提供 {abbr} 且非零，使用缩写而不是映射。
		{name} 可以使用特殊键名，如同 ":map" 命令那样。返回的字符串会
		把特殊的字符翻译成和 ":map" 命令所列出输出结果一样的格式。
		先检查局部于当前缓冲区的映射，然后再检查全局映射。
		此函数可以用来给键映射。如果已经映射过，还可以使用原来映射的内
		容。大意: >
			exe 'nnoremap <Tab> ==' . maparg('<Tab>', 'n')



+-*/+-*/mapcheck f 检查匹配的映射是否存在
mapcheck({name}[, {mode} [, {abbr}]])			*mapcheck()*
		检查是否有模式 {mode} 下匹配 {name} 的映射。|maparg()| 说明
		{mode} 和 {name} 里的特殊键名。
		如果提供 {abbr} 且非零，使用缩写而不是映射。
		匹配在映射名以 {name} 开始或者映射名等于 {name} 的开始部分时候
		发生。

			匹配映射	"a"     "ab"    "abc" ~
		   mapcheck("a")	是	是	 是
		   mapcheck("abc")	是	是	 是
		   mapcheck("ax")	是	否	 否
		   mapcheck("b")	否	否	 否

		和 maparg() 的差别是，mapcheck() 查找匹配 {name} 的映射，而
		maparg() 只查找名字完全符合 {name} 的映射。
		如果没有 {name} 开始的映射，返回空字符串。如果有一个，返回该映
		射的右边。如果有多个，返回其中某一个的右边。
		    先检查局部于当前缓冲区的映射，然后再检查全局映射。
		该函数用于检查是否可以无二义性地添加映射。例如: >
	:if mapcheck("_vv") == ""
	:   map _vv :set guifont=7x13<CR>
	:endif
<		就避免了在已有 "_v" 或者 "_vvv" 映射的时候添加 "_vv" 映射。


+-*/+-*/mapclear c 清除所有普通和可视模式的映射
:mapc[lear]			|mapmode-nvo|		*:mapc*   *:mapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/nmap c 输入映射，但使用普通模式
:nm[ap]	{lhs} {rhs}		|mapmode-n|		*:nm* *:nmap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。
"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/nmapclear c 清除普通模式的所有映射
:nmapc[lear]			|mapmode-n|		*:nmapc*  *:nmapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/nnoremap c 输入映射，但使用普通模式，不递归
:nn[oremap] {lhs} {rhs}		|mapmode-n|		*:nn*  *:nnoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/noreabbrev c 输入不会被重新映射的缩写
						*:norea* *:noreabbrev*
:norea[bbrev] [<expr>] [lhs] [rhs]
			与 ":ab" 一样，但 {rhs} 不进行重映射。{Vi 无此功能}

+-*/+-*/noremap c 输入不会被重新映射的映射
:no[remap]  {lhs} {rhs}		|mapmode-nvo|		*:no*  *:noremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/nunmap c 删除映射，但使用普通模式
:nun[map] {lhs}			|mapmode-n|		*:nun*  *:nunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/omap c 输入映射，但使用操作符等待模式
:om[ap]	{lhs} {rhs}		|mapmode-o|		*:om* *:omap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/omapclear c 删除操作符等待模式的所有映射
:omapc[lear]			|mapmode-o|		*:omapc*  *:omapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/onoremap c 输入映射，但使用操作符等待模式，不递归
:ono[remap] {lhs} {rhs}		|mapmode-o|		*:ono* *:onoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/operatorfunc o |g@| 操作符调用的函数
						*'operatorfunc'* *'opfunc'*
'operatorfunc' 'opfunc'	字符串	(缺省: 空)
			全局
			{Vi 无此功能}
	指定 |g@| 操作符调用的函数。
	详情和示例见 |:map-operator|。

	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。



+-*/+-*/ounmap c 删除映射，但使用操作符等待模式
:ou[nmap] {lhs}			|mapmode-o|		*:ou*   *:ounmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/remap o 允许映射可以递归调用
						*'remap'* *'noremap'*
'remap'			布尔型	(缺省打开)
			全局
	允许递归映射。如果对单个项目你不想这样，使用 :noremap[!] 命令。
	注意: 为了避免使用模式的移植性问题，永远把本选项设为缺省 "打开" 状态。
	只有在旧的 Vi 脚本里才需要把它关闭。


+-*/+-*/ttimeout o 映射等待超时
						*'ttimeout'* *'nottimeout'*
'ttimeout'		布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
	这两个选项一起决定收到部分映射的键序列或键码时的行为:

	'timeout'    'ttimeout'		动作	~
	   关闭		关闭		没有超时
	   打开		打开或关闭	为这些打开超时: 映射和键码
	   关闭		打开		为键码打开超时

	如果两个选项都关闭，Vim 会一直等待，直到收到完整的映射或键序列为止，如
	果收到的字符没有对应的映射或者键序列，清除状态。比如: 如果映射 "vl" 而
	Vim 收到 'v'，需要下一个字符来决定 'v' 后面跟的是不是 'l'。如果打开这
	里的一个选项，Vim 会为下个字符等待一秒。在此之后，已经收到的字符被解释
	为单个字符。等待的时间可以用 'timeoutlen' 选项改变。
	在慢速的终端或者很繁忙的系统中，超时可能使得光标键操作不正常。如果两个
	选项都关闭，Vim 在输入 <Esc> 后会永远等待下去，如果键码以 <Esc> 开始，
	你需要输入 <Esc> 两次。如果键码没有问题而你希望 :map 映射的键序列不等
	待 1 秒钟超时，置位 'ttimeout' 但关闭 'timeout' 选项。

	注意: 如果置位 'compatible'，'ttimeout' 被复位。


+-*/+-*/unabbreviate c 删除缩写
						*:una* *:unabbreviate*
:una[bbreviate] {lhs}	从列表中删除 {lhs} 的缩写。如果找不到，删除 {rhs} 匹配
			这里的 {lhs} 参数的缩写。这是为了方便你删除扩展后的缩
			写。要避免扩展，插入 CTRL-V (记住输入两次)。

+-*/+-*/unmap c 删除映射
:unm[ap]  {lhs}			|mapmode-nvo|		*:unm*  *:unmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/vmap c 输入映射，但使用可视+选择模式
:vm[ap]	{lhs} {rhs}		|mapmode-v|		*:vm* *:vmap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/vmapclear c 删除可视+选择模式所有的映射
:vmapc[lear]			|mapmode-v|		*:vmapc*  *:vmapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/vnoremap c 输入映射，但使用可视+选择模式，不递归
:vn[oremap] {lhs} {rhs}		|mapmode-v|		*:vn*  *:vnoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/vunmap c 删除映射，但使用可视+选择模式
:vu[nmap] {lhs}			|mapmode-v|		*:vu*   *:vunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/xmap c 输入映射，但使用可视模式
:xm[ap]	{lhs} {rhs}		|mapmode-x|		*:xm* *:xmap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/xmapclear c 删除可视模式的所有映射
:xmapc[lear]			|mapmode-x|		*:xmapc*  *:xmapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/xnoremap c 输入映射，但使用可视模式，不递归
:xn[oremap] {lhs} {rhs}		|mapmode-x|		*:xn*  *:xnoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

"<buffer>"，"<silent>"，"<special>"、"<script>"、"<expr>" 和 "<unique>" 可以按
任意顺序使用。它们必须紧跟在命令的后边，而在其它任何参数的前边。

+-*/+-*/xunmap c 删除映射，但使用可视模式
:xu[nmap] {lhs}			|mapmode-x|		*:xu*   *:xunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/move _ 文本内移动
+-*/+-*/Next c 转到参数列表的上一个文件
:[count]N[ext] [count] [++opt] [+cmd]			*:Next* *:N* *E164*
			编辑向前第 [count] 个文件。如果已经作了修改而 vim 不能
			放弃 |abandon| 当前的缓冲区，该命令失败。另见 |++opt|
			和 |+cmd|。{Vi 没有 count 和 ++opt}

+-*/+-*/byte2line f 取得某字节位置所在行号
byte2line({byte})					*byte2line()*
		返回当前缓冲区第 {byte} 个字节所在的行号。取决于当前缓冲区的
		'fileformat' 选项，这可以包括不同的换行符。第一个字符的字节编
		号为 1。
		另见 |line2byte()|、|go| 和 |:goto|。
		{仅当编译时加入 |+byte_offset| 特性才有效}


+-*/+-*/changes c 显示修改的列表
							*:changes*
:changes		打出改变表。 ">" 字符指示当前的位置。在一个改变之后，
			它在最新的一项之后，这意味着 "g;" 会带你到最新一项的位
			置。第一列则指示要到该位置需要的次数。例如:

+-*/+-*/checkpath c 列出包含的头文件
							*:che* *:checkpath*
:che[ckpath]		列出所有找不到的头文件。{Vi 无此功能}

+-*/+-*/col f 光标或位置标记所在的列
col({expr})	返回数值，即 {expr} 给定的列位置的字节索引。可接受的位置是:
		    .	    光标位置
		    $	    光标行的行尾 (返回光标行的字符数加 1)
		    'x	    位置标记 x 的位置 (如果该位置标记没有设置，返回 0)
		另外，{expr} 可以是 [lnum, col]: 包含行号和列号的 |List|。常用
		于指定列号为 "$" 以得到特定行的末列列号。如果 "lnum" 或 "col"
		超出范围，col() 返回零。
		要得到行号用 |line()|。两者都要用 |getpos()|。
		要得到屏幕列的位置，用 |virtcol()|。
		注意 只能使用当前文件的位置标记。
		例如: >
			col(".")		光标所在列
			col("$")		光标行的长度加 1
			col("'t")		位置标记 t 的列号
			col("'" . markname)	等于 markname 的位置标记的列号
<		第一列为 1。0 用来返回错误。
		大写位置标记的对应列可能在另一个缓冲区中。
		如果激活了 'virtualedit' 并且如果光标在行尾之后的话，计算光标
		位置得到的列号比实际的多 1。可用来在插入模式得到列数: >
			:imap <F2> <C-O>:let save_ve = &ve<CR>
				\<C-O>:set ve=all<CR>
				\<C-O>:echo col(".") . "\n" <Bar>
				\let &ve = save_ve<CR>
<


+-*/+-*/cursor f 置光标于 行／列 处
cursor({lnum}, {col} [, {off}])				*cursor()*
cursor({list})
		把光标定位在第 {lnum} 行的第 {col} 列 (字节计数)。第一列为 1。
		如果只有一个参数 {list}，它被看作带两个或三个参数 {lnum}、
		{col} 和 {off} 的 |List|。和 |getpos()| 的返回值类似，但没有第
		一项。
		不改变跳转表。
		如果 {lnum} 超过缓冲区的行数，光标定位在缓冲区的末行。
		如果 {lnum} 为零，光标留在当前行。
		如果 {col} 超过该行的字节数，光标定位在该行的最后一个字符上。
		如果 {col} 为零，光标留在当前列。
		如果使用 'virtualedit'，{off} 指定从该字符开始以屏幕列计算的偏
		移。例如，在制表里或者在最后一个字符之后的某个位置。
		如果定位成功，返回 0，否则返回 -1。



+-*/+-*/define o 查找宏定义所使用的模式
						*'define'* *'def'*
'define' 'def'		字符串	(缺省为 "^\s*#\s*define")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	用以找到宏定义的模式。这是一个搜索模式，和 "/" 命令使用的相同。本选项
	用于 "[i" 和 "[d" 等命令 |include-search|。'isident' 选项在该匹配之后
	用于识别定义名本身:
		{'define' 的匹配}{非标识符字符}{定义名}{非标识符字符}
	|option-backslash| 说明如何插入反斜杠以包含空格和反斜杠。
	缺省值是为 C 程序设计的。C++ 也可用，但如果也要包含常数类型定义的话: >
		^\(#\s*define\|[a-z]*\s*const\s*[a-z]*\)
<	用 ":set" 命令设置时，要加倍反引号！


+-*/+-*/delmarks c 删除位置标记
							*:delm* *:delmarks*
:delm[arks] {marks}	删除指定的位置标记。可以删除的位置标记也包括 A-Z 或
			0-9。不能删除 ' 位置标记。
			指定的方式包括给出位置标记名的列表和使用连字符分隔的范
			围。忽略空格。例如: >
			   :delmarks a	      删除位置标记 a
			   :delmarks a b 1    删除位置标记 a，b 和 1
			   :delmarks Aa       删除位置标记 A 和 a
			   :delmarks p-z      删除位置标记 p 到 z
			   :delmarks ^.[]     删除位置标记 ^ . [ ]
			   :delmarks \"	      删除位置标记 "
<			{Vi 无此功能}

+-*/+-*/diff_filler f 得到一行之上的填充行数目
diff_filler({lnum})					*diff_filler()*
		返回第 {lnum} 行之上的填充行的数目。
		这些是在另一个进行比较的窗口里在此位置插入的行。这些填充行在屏
		幕上显示，但缓冲区里并不存在。
		{lnum} 的用法类似于 |getline()|。所以 "." 是当前行，"'m" 是位
		置标记 m，等等。
		如果当前窗口不处于 diff 模式，返回 0。


+-*/+-*/djump c 跳转到 #define
							*:dj* *:djump*
:[range]dj[ump][!] [count] [/]string[/]
			类似于 "[ CTRL-D"  和 "] CTRL-D"，但是在 [range] 行范
			围内搜索 (缺省: 整个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/dlist c 列出所有的 #define
							*:dli* *:dlist*
:[range]dl[ist][!] [/]string[/]
			类似于 "[D" 和 "]D"，但在 [range] 行范围搜索 (缺省: 整
			个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}
			注意 ":dl" 功能同带 "l" 标志的 ":delete"。

+-*/+-*/dsearch c 列出一个 #define
							*:ds* *:dsearch*
:[range]ds[earch][!] [count] [/]string[/]
			类似于 "[d"  和 "]d"，但在 [range] 行范围搜索 (缺省: 整
			个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/dsplit c 分割窗口并跳转到 #define
							*:dsp* *:dsplit*
:[range]dsp[lit][!] [count] [/]string[/]
			类似于 "CTRL-W d"，但是在 [range] 行范围内查找
			(缺省: 整个文件).
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/getpos f 得到光标、位置标记等的位置
getpos({expr})	得到 {expr} 的位置。可用的 {expr} 的值见 |line()|。
		返回 |List|，包含四个数值:
		    [bufnum, lnum, col, off]
		"bufnum" 为零，除非使用了 '0 或 'A 这样的位置标记，这时它是此
		位置标记所在的缓冲区号。
		"lnum" 和 "col" 是缓冲区里的位置。第一列为 1。
		除非使用了 'virtualedit'。"off" 值为零，这是从对应字符开始位置
		计算的屏幕列。例如，在制表之中或最后一个字符之后的某个位置。可
		以用来保存和恢复光标位置: >
			let save_cursor = getpos(".")
			移动光标
			call setpos('.', save_cursor)
<		另见 |setpos()|。


+-*/+-*/goto c 转到缓冲区某字节处
:[range]go[to] [count]					*:go* *:goto* *go*
[count]go		到缓冲区的第 {count} 个字节。缺省的 [count] 是 1，即文
			件开始处。如果给定 [range]，则最后的一个数字用作字节的
			序号。'fileformat' 的当前设置决定如何计算换行符的个数。
			{Vi 无此功能}
			{仅当编译时加入 |+byte_offset| 特性才有效}

+-*/+-*/include o 查找包含文件所使用的模式
						*'include'* *'inc'*
'include' 'inc'		字符串	(缺省为 "^\s*#\s*include")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
			{仅当编译时加入 |+find_in_path| 特性才有效}
	用来查找包含命令的模式。这是一个搜索模式，和 "/" 命令使用的相同 (见
	|pattern|)。缺省值是为 C 程序设置的。本选项用于命令 "[i"、"]I"、
	"[d" 等等。
	通常 'isfname' 选项用于识别跟随在此匹配模式之后的文件。但如果 "\zs" 出
	现在模式里，那么匹配文本从 "\zs" 到最后或如有 "\ze" 的话到 "\ze" 为止
	的文本用作文件名。这样可以包含比如空格这样不在 'isfname' 里的字符。
	然后你可以用 'includeexpr' 来处理匹配的文本。
	|option-backslash| 说明如何包含空格和反斜杠。


+-*/+-*/includeexpr o 处理包含文件行所使用的表达式
						*'includeexpr'* *'inex'*
'includeexpr' 'inex'	字符串	(缺省为 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+find_in_path| 和 |+eval| 特性才有效}
	把 'include' 选项找到的字符串转换为文件名的表达式。Java 里，多用此将
	"." 换成 "/": >
		:set includeexpr=substitute(v:fname,'\\.','/','g')
<	"v:fname" 变量会被设为检测到的文件。

	如果 |gf| 命令找不到未经修改的文件名，也用此选项。这样，可以在
	'include' 语句之后的名字上执行 "gf"。
	也用于 |<cfile>|。

	可能在沙盘 |sandbox| 里计算此表达式。见 |sandbox-option|。

	计算 'includeexpr' 时不允许修改文本或者跳到其它窗口 |textlock|。


+-*/+-*/jumps c 显示跳转表
							*:ju* *:jumps*
:ju[mps]		打出跳转表 (不是动作命令)。 {Vi 无此功能}
			{仅当编译时加入 |+jumplist| 特性才有效}

+-*/+-*/k c 设置位置标记
						*:k*
:[range]k{a-zA-Z'}	和 :mark 相同， 但是标记名之前的空格可以省略。

+-*/+-*/keepjumps c 跟随的命令保持跳转表和位置标记不变
							*:keepj* *:keepjumps*
:keepj[umps] {command}
			在 {command} 的移动不改变 |''|，|'.| 和 |'^| 标记，跳
			转表 |jumplist| 或是改变表 |changelist|。这对于自动改
			变或者插入文本而不需要用户跳转到那个位置有用。例如，当
			更新 "最近改变" 的时间标签: >

+-*/+-*/keepmarks c 跟随的命令保持位置标记不变
:kee[pmarks] {command}					*:kee* *:keepmarks*
			目前，这只对过滤命令 |:range!| 有效:
			- 如果过滤后的行数不少于过滤之前，那么所有的过滤行中的
			  标记保持行号不变。
			- 如果行数减少，那么消失了的行中的标记就被删除掉。
			在任何情况下，过滤文本之后的标记需要调整行号，以保持和
			文本同步。
			如果 'cpoptions' 中没有 'R' 标志，那么直接执行过滤命令
			和使用 ":keepmarks" 的效果一样。

+-*/+-*/line f 光标或位置标记所在行
line({expr})	返回数值，即 {expr} 给定的文件位置的行号。可接受的位置是:
		    .	    光标位置
		    $	    缓冲区的最后一行
		    'x	    位置标记 x 的位置 (如果该位置标记没有设置，返回 0)
		    w0	    当前窗口可见部分的首行
		    w$	    当前窗口可见部分的末行
		    v	    可视模式下: 可视区域的起始行 (光标在尾部)。如果不
			    在可视模式下，返回光标位置。不同于 |'<|，可以得到
			    立即的更新。
		注意 可以使用其它文件的位置标记。此时行号应用于那个缓冲区。
		要得到列号用 |col()|。两者都要可用 |getpos()|。
		例如: >
			line(".")		光标所在的行号
			line("'t")		位置标记 t 的行号
			line("'" . marker)	名为 marker 的位置标记的行号
<							*last-position-jump*
		如果设置了 '" 位置标记的话，下面的自动命令在打开文件后跳转到最
		后已知的文件位置: >
	:au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
<

+-*/+-*/line2byte f 取得某行之前的字节数
line2byte({lnum})					*line2byte()*
		返回当前缓冲区第 {lnum} 行从缓冲区开始计算的字节数。这里包括换
		行符，但它具体的值取决于当前缓冲区的 'fileformat' 选项，第一行
		返回 1。
		这也可以用来得到最后一行之后的 "那行" 的字节计数: >
			line2byte(line("$") + 1)
<		这就等于文件大小加 1。
		如果 {lnum} 非法或者编译时关闭了 |+byte_offset| 特性，返回
		-1。另见 |byte2line()|、|go| 和 |:goto|。


+-*/+-*/lockmarks c 跟随的命令保持位置标记不变
:loc[kmarks] {command}					*:loc* *:lockmarks*
			执行命令 {command}，并且不调整位置标记。这可以用于不影
			响行的数目的文本改变。如果行数发生变化，那么改变之后的
			标记将仍然保持它们的行号，从而实际上移到了别的行上。

+-*/+-*/mark c 设置位置标记
						*:ma* *:mark* *E191*
:[range]ma[rk] {a-zA-Z'}
			把位置标记 {a-zA-Z'} 设在 [range] 的最后一行，第 0
			列。缺省的 [range] 是当前行。

+-*/+-*/marks c 列出所有的位置标记
						*:marks*
:marks			列出所有的位置标记 (这不是动作命令)，
			但不包括 |'(|，|')|，|'{| 和 |'}| 标记。
			第一列的编号为零。
			{Vi 无此功能}
						*E283*
:marks {arg}		列出所有 {arg} 包含的位置标记 (这不是动作命令)。例
			如， >
				:marks aB
<			列出位置标记 'a' 和 'B'。  {Vi 无此功能}

+-*/+-*/matchpairs o ""%"" 能匹配的字符对
						*'matchpairs'* *'mps'*
'matchpairs' 'mps'	字符串	(缺省为 "(:),{:},[:]")
			局部于缓冲区
			{Vi 无此功能}
	形成配对的字符。|%| 命令从其中一个跳转到另一个。目前，只能使用单字节的
	字符配对，而且必须不同。字符使用冒号分隔。多个配对之间使用逗号分隔。包
	含 '<' 和 '>' 的例子 (HTML): >
		:set mps+=<:>

<	更奇特的例子，在赋值语句的 '=' 和 ';' 来回跳转，用于 C 和 Java 这样的
	语言: >
		:au FileType c,cpp,java set mps+==:;

<	更高级的 "%" 的使用方式，可见 $VIMRUNTIME/macros 目录的 matchit.vim 插
	件。|add-local-help|


+-*/+-*/paragraphs o 分隔段落的 nroff 宏
						*'paragraphs'* *'para'*
'paragraphs' 'para'	字符串	(缺省为 "IPLPPPQPP TPHPLIPpLpItpplpipbp")
			全局
	指定用于分隔段落的 nroff 宏的列表，它们各是两个字符构成的组对 (见
	|object-motions|)。


+-*/+-*/path o ""gf"" 等命令搜索用的目录列表
					*'path'* *'pa'* *E343* *E345* *E347*
'path' 'pa'		字符串	(缺省在 Unix 上: ".,/usr/include,,"
				   OS/2:	  ".,/emx/include,,"
				   其它系统: ".,,")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	这是一个目录列表，|gf|、[f、]f、^Wf、|:find|、|:sfind|、|:tabfind| 和
	其它命令的文件搜索如果使用相对路径 (不以 "/"、"./" 或 "../" 开始) 的
	话，会在这里进行。'path' 选项里的目录可以是相对也可以是绝对路径。
	- 使用逗号分隔目录名: >
		:set path=.,/usr/local/include,/usr/include
<	- 空格可以用来分隔目录名 (为了和 3.0 版本后向兼容)。要在目录名里使用空
	  格，在它前面加额外的反斜杠，然后转义空格: >
		:set path=.,/dir/with\\\ space
<	- 要在目录名里加上空格，在它前面加上额外的反斜杠: >
		:set path=.,/dir/with\\,comma
<	- 要搜索相对于当前文件所在的目录，使用: >
		:set path=.
<	- 要在当前目录下搜索，在两个逗号之间使用空字符串: >
		:set path=,,
<	- 目录名可以用 ':' 或 '/' 结尾。
	- 环境变量被扩展 |:set_env|。
	- 如果使用 |netrw.vim|，可以使用 URL。比如，加入 "http://www.vim.org"
	  会使 ":find index.html" 能够工作。
	- 使用 "*"、"**" 和 ";" 在目录树里往上和往下搜索。相关信息和语法见
	  |file-searching|。
	  {仅当编译时加入 |+path_extra| 特性才有效}
	- 小心使用 '\' 字符，在选项里输入两个得到一个: >
		:set path=.,c:\\include
<	  也可使用 '/' 代替: >
		:set path=.,c:/include
<	不要忘记 "."，否则甚至不会在文件的同一目录里搜索文件！
	最大的长度有限制。具体多少由系统决定，一般是 256 或 1024 个字符。
	你可以检查是不是所有的头文件都能用 'path' 的值找到，见 |:checkpath|。
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减目录。这可以避免未来版本使
	用其它缺省值出现的问题。要删除当前目录，可以用: >
		:set path-=
<	要增加当前目录，使用: >
		:set path+=
<	环境变量的使用可能意味着需要更换分隔符。这里是一个加上 $INCL 的例子，
	该变量里的路径名以分号分隔: >
		:let &path = &path . "," . substitute($INCL, ';', ',', 'g')
<	把 ';' 换成 ':' 或者任何你使用的分隔符。注意 如果 $INCL 里包含逗号或者
	空格，这不会工作。


+-*/+-*/scroll o 用 CTRL-U 和 CTRL-O 滚动的行数
						*'scroll'* *'scr'*
'scroll' 'scr'		数值型	(缺省: 窗口高度的一半)
			局部于窗口
	使用 CTRL-U 和 CTRL-D 滚动的行数。如果改变窗口大小，本选项设为窗口新行
	数的一半。如果 CTRL-U 或 CTRL-D 命令给出计数，该计数会成为 'scroll' 的
	新值。":set scroll=0" 可以复位到缺省情况: 使用窗口高度的一半。
	{Vi 有所不同: 'scroll' 给出屏幕的行数而不是文件行数，在行有回绕时有所
	不同}


+-*/+-*/sections o 分隔小节的 nroff 宏
						*'sections'* *'sect'*
'sections' 'sect'	字符串	(缺省为 "SHNHH HUnhsh")
			全局
	指定用于分隔小节的 nroff 宏的列表，它们各是两个字符构成的组对 (见
	|object-motions|)。缺省值使得小节用以下的 nroff 宏开始: ".SH"、".NH"、
	".H"、".HU"、".nh" 和 ".sh"。


+-*/+-*/setpos f 设置光标、位置标记等的位置
setpos({expr}, {list})
		设置 {expr} 的位置。可能的值:
			.	光标
			'x	位置标记 x

		{list} 必须是带四个数值的 |List|:
		    [bufnum, lnum, col, off]

		"bufnum" 是缓冲区号。零代表当前缓冲区。只能为当前缓冲区设置光
		标。要设置别的缓冲区里的位置标记，可以用 |bufnr()| 函数把文件
		名转化为缓冲区号。
		不修改跳转表。

		"lnum" 和 "col" 是缓冲区里的位置。第一列为 1。"lnum" 为零则删
		除位置标记。"col" 如小于 1，则以 1 代替。

		除非使用了 'virtualedit'。不用 "off" 值。这是从对应字符开始位置
		计算的屏幕列。例如，在制表之中或最后一个字符之后的某个位置。

		如果位置可以设置，返回 0，否则返回 -1。如果 {expr} 不合法，报
		错。

		另见 |getpos()|

		这并不能恢复垂直移动使用的列。为此，可见 |winrestview()|。



+-*/+-*/startofline o 命令移动光标到行的第一个非空白
			   *'startofline'* *'sol'* *'nostartofline'* *'nosol'*
'startofline' 'sol'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	如果打开，下面列出的命令把光标移动到行首的第一个非空白。如果关闭，光
	标保持在同一列上 (如果可能的话)。这适用于以下命令:
	CTRL-D、CTRL-U、CTRL-B、CTRL-F、"G"、"H"、"M"、"L"，gg，以及使用面向行
	操作符的 "d"、"<<" 和 ">>"，还有带计数的 "%" 和缓冲区改变命令
	(CTRL-^、 :bnext、:bNext，等等)，最后包括只有单个行号的 Ex 命令，比如
	":25" 或 ":+"。
	在缓冲区改变命令里，光标定位在上次缓冲区编辑时它所在的列上。
	注意: 如果置位 'compatible'，该选项也被置位。


+-*/+-*/suffixesadd o 搜索文件时附加的后缀
						*'suffixesadd'* *'sua'*
'suffixesadd' 'sua'	字符串	(缺省为 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+file_in_path| 特性才有效}
	逗号分隔的后缀名列表。"gf"、"[I" 等命令搜索文件时使用它们。例如: >
		:set suffixesadd=.java
<

+-*/+-*/virtcol f 光标或位置标记所在的屏幕列
virtcol({expr})						*virtcol()*
		要得到屏幕列的位置，用 |virtcol()|。
		注意 只能使用当前文件的位置标记。

		返回数值，即 {expr} 给定的文件位置的屏幕列号。也就是，该位置的
		字符占据的最后一个屏幕位置，这里假设屏幕有无限的宽度。如果该位
		置是一个 <Tab>，返回的数值是 <Tab> 占据的最后一列。比如，如果
		<Tab> 在第 1 列，而 'ts' 设为 8 的话，返回 8。
		关于字节位置，见 |col()|。
		{expr} 用法见 |col()|。
		如果使用 'virtualedit'，{expr} 可以用 [lnum, col, off]，其中
		"off" 是字符位置开始计算的屏幕列。例如，制表中或最后一个字符之
		后的某个位置。
		如果在当前模式下使用了虚拟编辑，也可能返回行尾之后的位置。
		|'virtualedit'|
		可接受的位置是:
		    .	    光标位置
		    $	    光标行的行尾 (返回光标行显示的字符数加 1)
		    'x	    位置标记 x 的位置 (如果该位置标记没有设置，返回 0)
		注意 只能使用当前文件的位置标记。
		示例: >
  virtcol(".")	   文本 "foo^Lbar"，光标在 "^L" 上，返回 5
  virtcol("$")	   文本 "foo^Lbar"，返回 9
  virtcol("'t")    文本 "    there"，'t 在 'h' 上，返回 6
<		第一列为 1。返回 0 代表错误。
		一个更高级的示例，显示所有行的最大长度: >
		    echo max(map(range(1, line('$')), "virtcol([v:val, '$'])"))



+-*/+-*/whichwrap o 允许指定键跨越行边界
						*'whichwrap'* *'ww'*
'whichwrap' 'ww'	字符串	(Vim 缺省: "b,s"，Vi 缺省: "")
			全局
			{Vi 无此功能}
	使指定的左右移动光标的键在行首或行尾可以移到前一行或者后一行。连接这些
	字符，可以让所有指定的键都有此功能:
		字符   键	 模式	~
		 b    <BS>	 普通和可视
		 s    <Space>	 普通和可视
		 h    "h"	 普通和可视 (不建议)
		 l    "l"	 普通和可视 (不建议)
		 <    <Left>	 普通和可视
		 >    <Right>	 普通和可视
		 ~    "~"	 普通
		 [    <Left>	 插入和替换
		 ]    <Right>	 插入和替换
	例如: >
		:set ww=<,>,[,]
<	只允许光标键进行回绕。
	如果移动键和删除和改变操作符一起使用时，<EOL> 也被看作一个字符。这使得
	光标跨过行尾时，"3h" 和 "3dh" 效果不同。这也适用于 "x" 和 "X"，因为它
	们分别和 "dl" 以及 "dh" 相同。如果这么用，你可能想用映射 ":map <BS> X"
	来使退格键删除光标之前的字符。
	如果包含 'l'，位于行尾时如果在操作符之后使用它，不会移动到下一行。这样
	"dl"、"cl"、"yl" 等都能正常工作。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/wincol f 光标所在窗口列
wincol()	返回数值，窗口光标的虚拟列。亦即从窗口左侧起算的屏幕列数。最左
		列为第一列。


+-*/+-*/window o CTRL-F 和 CTRL-B 滚动的行数
						*'window'* *'wi'*
'window' 'wi'		数值型  (缺省为屏幕高度 - 1)
			全局
	窗口高度。不要和 Vim 窗口的高度混淆。那里要用 'lines'。
	|CTRL-F| 和 |CTRL-B| 执行时，如果只有一个窗口且本选项的值小于 'lines'
	减 1，用到本选项。此时，屏幕滚动的行数为 'window' 减两行，但至少一行。
	如果 'window' 等于 'lines' 减 1，CTRL-F 和 CTRL-B 的滚动更智能一些，它
	们会照顾到回绕行。
	改变 Vim 窗口大小时，本值如果小于 1 或者大于等于 'lines'，它被设为
	'lines' 减 1。
	{Vi 也用此选项指定显示的行数}


+-*/+-*/winline f 光标所在窗口行
winline()	返回数值，窗口光标所在的屏幕行，亦即，从窗口顶部起算的屏幕行
		数。第一行返回 1。
		如果光标移动，文件的视图会先更新，这可能会导致滚动。

							*winnr()*
+-*/multi _ 多语言
+-*/+-*/aleph o Aleph 字母 (希伯来语) 的 ASCII 代码
					*'aleph'* *'al'* *aleph* *Aleph*
'aleph' 'al'		数值型	(MS-DOS 的缺省为 128，否则为 224)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	希伯来字母表的第一个字母的 ASCII 码。希伯来模式下的键盘映射例程，包括
	插入模式 (如果置位 hkmap) 和命令行模式 (如果按了 CTRL-_)，都使用
	[aleph..aleph+26] 范围输出希伯来字符。
	aleph=128 适用于 PC 代码，而 aleph=224 适用于 ISO 8859-8。
	见 |rileft.txt|。


+-*/+-*/allowrevins o 允许插入和命令行模式的 CTRL-_
			*'allowrevins'* *'ari'* *'noallowrevins'* *'noari'*
'allowrevins' 'ari'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	允许插入和命令行模式使用 CTRL-_。缺省是关闭的，以免用户想输入 SHIFT-_
	时不小心输入 CTRL-_ 而进入反向插入模式又不知道怎么退出。见 'revins'。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/altkeymap o 缺省的第二语言 (波斯语/希伯来语)
			 *'altkeymap'* *'akm'* *'noaltkeymap'* *'noakm'*
'altkeymap' 'akm'	布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+farsi| 特性才有效}
	如果打开，第二语言是波斯语。编辑模式下如果打开 'allowrevins' 的话，
	CTRL-_ 切换波斯语和英语的键盘映射表。

	如果关闭，在希伯来语和英语之间切换键盘映射表。可用于以原始方式，即英语
	(从左到右模式)，启动 Vim，又可以使用第二语言即波斯语或者希伯来语 (从右
	到左模式) 的场合。见 |farsi.txt|。


+-*/+-*/ambiwidth o 如何处理有多种宽度的 Unicode 字符
						*'ambiwidth'* *'ambw'*
'ambiwidth' 'ambw'	字符串 (缺省: "single")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+multi_byte| 特性才有效}
	只有在 'encoding' 为 "utf-8" 或别的 Unicode 编码时才有效。告诉 Vim 怎
	么处理东亚二义性宽度字符类 (East Asian Width Class Ambiguous) (例如
	欧元符号、注册记号、版权记号、希腊字母、西里尔字母等等)。

	目前有两个可能的选择:
	"single":	使用和 US-ASCII 字符相同的宽度。多数用户希望如此。
	"double":	使用 US-ASCII 字符两倍的宽度。
							*E834* *E835*
	如果 'listchars' 或 'fillchars' 包含会是双倍宽度的字符，不能使用
	"double" 值。

	在一些 CJK 字体里，这些字符的字形宽度完全由它们在传统的 CJK 编码里占据
	字节的数目决定。那些编码中，欧元、注册记号、希腊/西里尔字母等占据两个
	字节，因而它们在这些字体里用 "宽" 字形显示。这也包括文本文件里制表用的
	一些画线字符。因此如果 GUI Vim 使用 CJK 字体、或者在使用 CJK 字体的终
	端 (模拟器) (包括带有 "-cjkwidth" 选项的 xterm) 里运行 Vim，应把该选项
	设为 "double"，这样可以匹配这些字体里 Vim 实际看到相关字形的宽度。 CJK
	Windows 9x/ME 或 Windows 2k/XP 上，如果系统 locale 为 CJK locale，也应
	把本选项设为 "double"。见 Unicode Standard Annex #11
	(http://www.unicode.org/reports/tr11)。


+-*/+-*/arabic o 使用阿拉伯语为缺省的第二语言
				*'arabic'* *'arab'* *'noarabic'* *'noarab'*
'arabic' 'arab'		布尔型 (缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+arabic| 特性才有效}
	可以置位本选项来开始编辑阿拉伯文本。
	置位本选项会:
	- 置位 'rightleft' 选项，除非置位 'termbidi'。
	- 置位 'arabicshape' 选项，除非置位 'termbidi'。
	- 设置 'keymap' 选项为 "arabic"；插入模式下 CTRL-^ 会切换英语和阿拉伯
	  键盘映射。
	- 置位 'delcombine' 选项。
	注意 要使用阿拉伯文本，'encoding' 必须是 "utf-8"。

	复位本选项会:
	- 复位 'rightleft' 选项。
	- 关闭 'keymap' 的使用 (但不改变其值)。
	注意 这里不复位 'arabicshape' 和 'delcombine' (这些是全局选项)。
	另见 |arabic.txt|。


+-*/+-*/arabicshape o 阿拉伯语的字型重整
					*'arabicshape'* *'arshape'*
					*'noarabicshape'* *'noarshape'*
'arabicshape' 'arshape'	布尔型 (缺省打开)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+arabic| 特性才有效}
	如果打开且 'termbidi' 关闭，启动必须的可见字符的校正，以正确显示阿拉伯
	语言。本质上它打开了字型重整；这是一个广义的术语，它包括:
	  a) 根据词内位置 (开头、中间、结尾和单独出现) 改变/调整字符的形状。
	  b) 启动合成字符的能力
	  c) 启动一些字符所需的组合
	如果关闭，屏幕用每个字符原来单独显示的方式显示。
	阿拉伯语是一个复杂的语言，还需要其他的设置。详见 |arabic.txt|。


+-*/+-*/bomb o 文件头附加字节顺序标记 (Byte Order Mark)
							*'bomb'* *'nobomb'*
'bomb'			布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+multi_byte| 特性才有效}
	写入文件时，如果满足以下条件，在文件头部写入 BOM (Byte Order Mark，字
	节顺序标记):
	- 打开本选项
	- 关闭 'binary' 选项
	- 'fileencoding' 是 "utf-8"、"ucs-2"、"ucs-4" 或它们的 little/big
	  endian (高位在右侧/左侧的字节序) 变种。
	有些应用程序使用 BOM 识别文件的编码。通常用于 MS-Windows 上的 UCS-2
	文件。对别的程序而言，这会造成麻烦，比如: "cat file1 file2" 使得 file2
	的 BOM 出现在结果文件的中间。gcc 不接受 BOM。
	读入文件时，如果 'fileencodings' 以 "ucs-bom" 开头，Vim 会检查 BOM 是
	否存在，并相应地设置 'bomb'。
	除非置位 'binary'，BOM 会从首行上移去，所以编辑时你看不到它。如果你没
	有改变相应设置，写回文件时恢复 BOM。


+-*/+-*/casemap o 指定字母大小写如何改变
						*'casemap'* *'cmp'*
'casemap' 'cmp'		字符串	(缺省: "internal,keepascii")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+multi_byte| 特性才有效}
	指定改变字母大小写的细节。它包含以下单词，以逗号分隔:
	internal	使用内部大小写映射函数，当前的 locale 不改变大小写映
			射。这只影响 'encoding' 为 Unicode 编码、"latin1" 或
			"iso-8859-15" 的情况。如果没有 "internal"，使用系统库
			函数 (如果有的话) towupper() 和 towlower()。
	keepascii	ASCII 字符 (0x00 到 0x7f)，使用美国的大小写映射，当前
			locale 不起作用。这可能只影响土耳其语。


+-*/+-*/charconvert o 完成字符编码转换的表达式
				*'charconvert'* *'ccv'* *E202* *E214* *E513*
'charconvert' 'ccv'	字符串 (缺省为 "")
			全局
			{仅当编译时加入 |+multi_byte| 和 |+eval| 特性才有效}
			{Vi 无此功能}
	用于进行字符编码转换的表达式。文件读写时如果和期望的编码不同，计算本
	表达式。
	如果内部支持 iconv() 函数并且它能完成本次转换，不使用 'charconvert'。
	iconv() 更好，因为它快得多。
	读入标准输入 |--| 时不使用 'charconvert'，因为没有可以文件可以进行转
	换。你需要先把文本保存到文件里。
	表达式必须返回零或空字符串表示成功，非零表示失败。
	可能遇到的编码名字来自 'encoding'。另外，也使用 'fileencodings' 和
	'fileencoding' 里的名字。
	"latin1"、"unicode"、"ucs-2"、"ucs-4" 和 "utf-8" 之间的转换由 Vim 内部
	完成，'charconvert' 不用于此种转换。
	如果 'viminfo' 包含 'c' 标志位，'charconvert' 也被用来转换 viminfo 文
	件。它也用于 Unicode 转换。
	示例: >
		set charconvert=CharConvert()
		fun CharConvert()
		  system("recode "
			\ . v:charconvert_from . ".." . v:charconvert_to
			\ . " <" . v:fname_in . " >" v:fname_out)
		  return v:shell_error
		endfun
<	相关的 Vim 变量是:
		v:charconvert_from	当前的编码名
		v:charconvert_to	期待的编码名
		v:fname_in		输入文件名
		v:fname_out		输出文件名
	注意 v:fname_in 和 v:fname_out 永远不会相同。
	注意 v:charconvert_from 和 v:charconvert_to 可能与 'encoding' 不同。
	Vim 内部使用 UTF-8 代替 UCS-2 或 UCS-4。
	使用 'charconvert' 时，Vim 不进行加密。如果你希望转换后加密文件，
	'charconvert' 需要自己负责这一点。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/delcombine o 在单独使用时删除组合用字符
			*'delcombine'* *'deco'* *'nodelcombine'* *'nodeco'*
'delcombine' 'deco'	布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+multi_byte| 特性才有效}
	如果编辑 Unicode 时打开本选项，退格和普通模式的 "x" 删除单个组合用字
	符。如果关闭 (缺省值) 每个字符连同它的组合用字符一并删除。
	注意: 置位 'delcombine' 时，"xx" 可能和 "2x" 不一样！

	这对阿拉伯语、希伯来语和许多其他语言有用，那里需要在基础字符的上方使用
	组合用字符，而有时只想删除组合用的部分。


+-*/+-*/digraph o 允许插入模式时输入二合字母
				     *'digraph'* *'dg'* *'nodigraph'* *'nodg'*
'digraph' 'dg'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+digraphs| 特性才有效}
	允许插入模式下使用 {char1} <BS> {char2} 输入二合字母。见 |digraphs|。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/digraphs c 显示或者输入二合字母
						*:dig* *:digraphs*
:dig[raphs]		显示当前定义的二合字母。
							*E104* *E39*
:dig[raphs] {char1}{char2} {number} ...
			把二合字母 {char1}{char2} 加入列表。{number} 是字符的
			十进制表示形式。例如: >
	:digr e: 235 a: 228
<			避免定义 '_' (下划线) 开头的二合字母，将来它会有特殊的
			含义。

+-*/+-*/encoding o 内部使用的编码方式
					*'encoding'* *'enc'* *E543*
'encoding' 'enc'	字符串 (缺省: "latin1" 或者 $LANG 的值)
			全局
			{仅当编译时加入 |+multi_byte| 特性才有效}
			{Vi 无此功能}
	设置 Vim 内部使用的字符编码。它应用于缓冲区、寄存器、表达式所用的字符
	串、viminfo 保存的等等各种文本。该选项设置 Vim 可以工作的字符类型。可
	用的值见 |encoding-names|。

	注意: 改变此选项不会改变 Vim 已有文本的编码。但可能会使非 ASCII 文本变
	成非法。通常，应该保持其为缺省值，或者只有在 Vim 启动时设置之。见
	|multibyte|。要重新载入菜单，见 |:menutrans|。

	不能从 |modeline| 设置本选项。否则很有可能破坏文本。

	注意: GTK+ 2 上高度建议设置 'encoding' 为 "utf-8"。尽管已经付出一定努
	力使得设置别的 'encoding' 值成为可能，"utf-8" 是该环境下的自然选择，而
	且可以避免不必要的转换开销。"utf-8" 之所以没有成为缺省，是为了避免
	GUI 和终端的行为不同步，也避免在你不知情的情况下改变新建立文件的编码
	(如果 'fileencodings' 为空的话)。

	文件的字符编码可以和 'encoding' 不同。这由 'fileencoding' 指定。转换通
	过 iconv() 完成或者通过 'charconvert' 指定。

	如果你需要知道 'encoding' 指定的是否是多字节编码，可用: >
		if has("multi_byte_encoding")
<
	通常，'encoding' 应该等同于你现有的 locale。如果 Vim 能识别环境变量的
	设定，这应是该选项的缺省值。如果 'encoding' 没有设为你现有的 locale，
	必须设定 'termencoding' 来转换输入和显示的文本。见 |encoding-table|。

	设置此选项激活 |EncodingChanged| 自动命令事件，使得你可以在必要时设置
	字体。

	设置此选项时，其值被转成小写。所以，你也可以用大写的值来设置。下划线被
	换成 '-' 符号。
	如果该编码能够识别，它被转换为标准值。比如 "Latin-1" 成为 "latin1"，
	"ISO_88592" 成为 "iso-8859-2"，还有 "utf8" 成为 "utf-8"。

	注意: 如果无法识别该编码，总是使用 "latin1"。只有编辑的文件实际使用相
	同的编码才不会有问题！如果实际的字符集不是 latin1，确保 'fileencoding'
	和 'fileencodings' 为空。如果转换是必要的，切换该值为 utf-8。

	如果使用 "unicode"、"ucs-2" 或 "ucs-4"，Vim 内部总是使用 utf-8。编辑时
	你可能没有注意到这一点，但使用 |viminfo-file| 就有关系了。还有，Vim 此
	时假定你的终端使用 utf-8。所以，设置 'encoding' 为这里某个非 utf-8 的
	值唯一的效果是指定 'fileencoding' 为空时文件使用的编码。

	如果设置 'encoding' 为 Unicode 编码并且还没有设置过 'fileencodings'，
	'fileencodings' 的缺省值相应改变。


+-*/+-*/fileencoding o 多字节文本的文件编码
				*'fileencoding'* *'fenc'* *E213*
'fileencoding' 'fenc'	字符串 (缺省: "")
			局部于缓冲区
			{仅当编译时加入 |+multi_byte| 特性才有效}
			{Vi 无此功能}
	设置此缓冲区所在文件的字符编码。
	如果 'fileencoding' 不同于 'encoding'，写文件时需要进行转换。读文件时
	见下。
	如果 'fileencoding' 为空，使用 'encoding' 相同的值 (而读写文件也不需要
	转换)。
	如果 'encoding' 和 'fileencoding' 都是某种 Unicode 编码而且
	'fileencoding' 不是 utf-8，会进行转换。这是因为 Unicode 在内部总是使用
	utf-8 编码进行存储。
		警 告: 转换可能导致信息的丢失！如果 'encoding' 为 "utf-8" 或其
		它 Unicode 编码，那么转换的结果通过逆转换很有可能产生相同的文
		本。相反，如果 'encoding' 不是 "utf-8"，一些字符可能会丢失！
	'encoding' 说明该选项可用的值。另外，也许还有其它转换器能够处理的值可
	用，见 |mbyte-conversion|。
	读入文件时，'fileencoding' 会根据 'fileencodings' 进行设置。
	要用特定编码读入文件，不能设置 'fileencoding'，用 |++enc| 参数。但有一
	个例外: 如果 'fileencodings' 为空，则使用 'fileencoding'。
	新文件使用全局的 'fileencoding' 值。
	这里，在前面附加 "8bit-" 和 "2byte-" 没有意义，它们也被忽略。
	设置该选项时其值被转换为小写。所以，你设置大写的值也没关系。
	'_' 字符被替换成 '-'。如果是一个 'encoding' 列表里能识别的名字，它被替
	换为标准名。比如 "ISO8859-2" 成为 "iso-8859-2"。
	开始编辑文件后，如果设置该选项，'modified' 选项被置位，因为文件被认为
	已经和当初写入时不同。
	记住从模式行设置 'fenc' 发生的时刻是在文本读入_之后_，所以它只影响文件
	的写入。如果你确实要在模式行上设置 'fenc'，最后同时设置 'nomodified'，
	否则会不能 ":q"。

	本选项在 'modifiable' 关闭时不能改变。

							*'fe'*
	注意: 在 6.0 版本之前，本选项设定整个 Vim 所用的编码，这是一个错误。现
	在用 'encoding' 代替。旧的简称是 'fe'，现已不再使用。


+-*/+-*/fileencodings o 参与自动检测的字符编码
					*'fileencodings'* *'fencs'*
'fileencodings' 'fencs'	字符串 (缺省: "ucs-bom"，
				如果 'encoding' 为某个 Unicode 的值，
					"ucs-bom,utf-8,default,latin1")
			全局
			{仅当编译时加入 |+multi_byte| 特性才有效}
			{Vi 无此功能}
	这是一个字符编码的列表，开始编辑已存在的文件时，参考此选项。如果文件被
	读入，Vim 尝试使用本列表第一个字符编码。如果检测到错误，使用列表的下一
	个。如果找到一个能用的编码，设置 'fileencoding' 为该值。如果全都失败，
	'fileencoding' 设为空字符串，这意味着使用 'encoding' 的值。
		警 告: 转换可能导致信息的丢失！如果 'encoding' 为 "utf-8" (或
		某个其它的 Unicode 变种)，那么转换的结果通过逆转换很有可能产生
		相同的文本。相反，如果 'encoding' 不是 "utf-8"，一些非 ASCII
		的字符可能会丢失！你可用 |++bad| 参数指定转换失败时的行为。

	对于空文件或者只含 ASCII 字符的文件，多数编码都可以工作，因而会使用
	'fileencodings' 的第一项 (除了 "ucs-bom" 以外，它需要 BOM)。如果你更愿
	意别的编码，用 BufReadPost 自动命令事件来测试是否需要使用你所喜欢的编
	码。比如: >
		au BufReadPost * if search('\S', 'w') == 0 |
			\ set fenc=iso-2022-jp | endif
<	如果文件没有非空白字符，该代码设置 'fileencoding' 为 "iso-2022-jp"。
	如果用 |++enc| 参数，不使用 'fileencodings' 的值。
	注意 'fileencodings' 不用于新文件。此时，使用 'fileencoding' 的全局
	值。你可以这样设置: >
		:setglobal fenc=iso-8859-2
<	这意味着不存在的文件可能和空文件得到不同的编码。
	特殊值 "ucs-bom" 可用来检查文件开始处的 Unicode 的 BOM (Byte Order
	Mark 字节顺序标记)。要使之能正常工作，不能把 "utf-8" 或别的 Unicode 编
	码放在它的前面。
	8 位编码的项目 (比如，"latin1") 应该放在最后，因为 Vim 不会检测出错，
	因而总会接受该编码。
	特殊值 "default" 可以用来指定环境使用的编码。这是 'encoding' 的缺省
	值。可用于把 'encoding' 设为 "utf-8" 而环境使用非 latin1 编码的场合，
	例如俄语。
	如果 'encoding' 为 "utf-8" 而文件包含非法的字节序列，它不会被识别为
	UTF-8。可用 |8g8| 命令寻找非法的字节序列。
	错 误 的 值:			错 在 哪 里: ~
		latin1,utf-8		总是使用 "latin1"
		utf-8,ucs-bom,latin1	utf-8 文件里的 BOM 不会被识别
		cp1250,latin1		总是使用 "cp1250"
	如果 'fileencodings' 为空，不修改 'fileencoding'。
	'fileencoding' 说明本选项可能的值。
	直到下一次读入文件时，此选项的设置才会有效果。


+-*/+-*/fkmap o 波斯键盘映射
					*'fkmap'* *'fk'* *'nofkmap'* *'nofk'*
'fkmap' 'fk'		布尔型 (缺省关闭)			*E198*
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	如果打开，键盘映射设为波斯字符集。通常，你会置位 'allowrevins' 然后用
	插入模式下的 CTRL-_ 来切换本选项 |i_CTRL-_|。见 |farsi.txt|。


+-*/+-*/helplang o 首选帮助语言
						*'helplang'* *'hlg'*
'helplang' 'hlg'	字符串	(缺省: 消息语言或为空)
			全局
			{仅当编译时加入 |+multi_lang| 特性才有效}
			{Vi 无此功能}
	逗号分隔的语言列表。Vim 使用希望得到的帮助的第一个能找到的语言版本。
	英语帮助总是最后使用。你可以把 "en" 来把英语放在其它语言之前，但那只会
	找到在那个语言里存在的标签，而不是英语的帮助。
	例如: >
		:set helplang=de,it
<	会先寻找德语，然后是意大利语，最后才是英语。
	如果在非英语的帮助文件里使用 |CTRL-]| 和 ":help!"，Vim 会先寻找该语言
	版本的那个标签，然后才使用本选项。见 |help-translated|。


+-*/+-*/hkmap o 希伯来语的键盘映射
					 *'hkmap'* *'hk'* *'nohkmap'* *'nohk'*
'hkmap' 'hk'		布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	如果打开，键盘被映射为希伯来字符集。通常，你会置位 'allowrevins' 并在
	插入模式里用 CTRL-_ 打开本模式。见 |rileft.txt|。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/hkmapp o 希伯来语的音节 (phonetic) 键盘映射
				 *'hkmapp'* *'hkp'* *'nohkmapp'* *'nohkp'*
'hkmapp' 'hkp'		布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	如果打开，把键盘映射设成 '根据读音的希伯来语' (phonetic)。'hkmap' 必须
	也打开。可用于非希伯来语的键盘。
	见 |rileft.txt|。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/imactivatekey o 激活 X 输入方法 (X input method) 的键击
						*'imactivatekey'* *'imak'*
'imactivatekey' 'imak'	字符串 (缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+xim| 和 |+GUI_GTK| 特性才有效}
								*E599*
	指定激活 X-Window 窗口输入方法 (Input Method) 的热键。如果正确指定，
	vim 可以用 'imcmdline'、'iminsert' 和 'imsearch' 来完整控制 IM。
	你不能用该选项来改变激活键。这个选项只是告知 Vim 这个键是什么。
	格式:
		[MODIFIER_FLAG-]KEY_STRING

	MODIFIER_FLAG (忽略大小写) 可以使用以下字符:
		S	    Shift 键
		L	    Lock 键
		C	    Control 键
		1	    Mod1 键
		2	    Mod2 键
		3	    Mod3 键
		4	    Mod4 键
		5	    Mod5 键
	接受组合，比如 "S-C-space" 或 "SC-space" 都代表 Shift+Ctrl+空格。
	KEY_STRING 的格式见 <X11/keysymdef.h> 和 XStringToKeysym。

	例如: >
		:set imactivatekey=S-space
<	"S-space" 代表 Shift+空格。这是 kinput2+canna (日语)，ami (韩语) (译者
	注: 还有 scim) 的激活键。


+-*/+-*/imcmdline o 开始编辑命令行时使用 IM
				*'imcmdline'* *'imc'* *'noimcmdline'* *'noimc'*
'imcmdline' 'imc'	布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+xim|、|+multi_byte_ime| 或
			|global-ime|  特性才有效}
	如果置位，开始编辑命令行时总是打开输入方法 (IM)，除了输入搜索模式以外
	(此时适用 'imsearch')。
	如果你的输入方法允许直接输入英语字符，可以置位此选项。比如，它可以使用
	死键 (dead key) 来输入带重音的字符。


+-*/+-*/imdisable o 任何模式下不使用 IM
				*'imdisable'* *'imd'* *'noimdisable'* *'noimd'*
'imdisable' 'imd'	布尔型 (缺省关闭，有的系统打开 (SGI))
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+xim|、|+multi_byte_ime| 或
			|global-ime|  特性才有效}
	如果置位，用于关闭输入方法。IM 工作不正常时可用于关闭之。目前，
	SGI/IRIX 机器上缺省打开该选项。将来的版本也许会有变化。


+-*/+-*/iminsert o 插入模式下使用 :lmap 或 IM
						*'iminsert'* *'imi'*
'iminsert' 'imi'	数值型 (缺省为 0，如果支持输入方法则为 2)
			局部于缓冲区
			{Vi 无此功能}
	指定插入模式里使用 :lmap 还是输入方法 (IM)。合法的值是:
		0	:lmap 关闭而 IM 关闭
		1	:lmap 打开而 IM 关闭
		2	:lmap 关闭而 IM 打开
	仅当编译时加入 |+multi_byte_ime|，|+xim| 或 |global-ime| 特性时，才能
	用 2。
	要在用 <Esc> 退出插入模式时总把该选项复位为 0，可以用: >
		:inoremap <ESC> <ESC>:set iminsert=0<CR>
<	这使得 :lmap 和 IM 在离开插入模式时自动关闭。
	注意 插入模式下使用 CTRL-^ 时此选项也发生改变。|i_CTRL-^|。
	如果把 'keymap' 设为合法的键盘映射表名字，此值设为 1。
	它也用于像 "r" 和 "f" 这样的命令的参数。
	在 Athena 和 Motif 上，一些 XIM 方法可能使值 0 不能正确工作。这时，用
	'imdisable' 关闭 XIM。


+-*/+-*/imsearch o 输入搜索模式时使用 :lmap 或 IM
						*'imsearch'* *'ims'*
'imsearch' 'ims'	数值型 (缺省为 0，如果支持输入方法则为 2)
			局部于缓冲区
			{Vi 无此功能}
	指定输入搜索模式时使用 :lmap 还是输入方法 (IM)。合法的值是:
		-1	使用 'iminsert' 的值，就像 'iminsert' 同时用于搜索模式
			的输入一样
		0	:lmap 关闭而 IM 关闭
		1	:lmap 打开而 IM 关闭
		2	:lmap 关闭而 IM 打开
	注意 命令行模式下使用 CTRL-^ 时此选项也发生改变。|i_CTRL-^|。
	如果此值不等于 -1，在 'keymap' 设为合法的键盘映射表名时，此值设为 1。
	在 Athena 和 Motif 上，一些 XIM 方法可能使值 0 不能正确工作。这时，用
	'imdisable' 关闭 XIM。


+-*/+-*/keymap o 键盘映射名
					*'keymap'* *'kmp'* *E544*
'keymap' 'kmp'		字符串	(缺省为 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+keymap| 特性才有效}
	键盘映射表的名字。见 |mbyte-keymap|。
	设置此选项为合法的键盘映射表名也会设置 'iminsert' 为 1，使得该键盘映射
	表生效。除非 'imsearch' 原来为 -1，它也被设为 1。
	只能使用普通的文件名字符。"/\*?[|<>" 都不合法。


+-*/+-*/langmap o 其他语言模式用的字母表字符
					*'langmap'* *'lmap'* *E357* *E358*
'langmap' 'lmap'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+langmap| 特性才有效}
	本选项允许你切换键盘到一种特殊的语言模式。插入模式下输入文本时直接插入
	这些字符。在命令模式 (译者注: 指普通模式) 下，'langmap' 选项把这些特殊
	的字符翻译成本键的原始含义。这意味着你不需要改变键盘模式就可以执行普通
	模式的命令。
	此选项和 'keymap' 选项相反，那里，映射的是插入模式下的字符。

	示例 (希腊文，UTF-8):					*greek*  >
	    :set langmap=ΑA,ΒB,ΨC,ΔD,ΕE,ΦF,ΓG,ΗH,ΙI,ΞJ,ΚK,ΛL,ΜM,ΝN,ΟO,ΠP,QQ,ΡR,ΣS,ΤT,ΘU,ΩV,WW,ΧX,ΥY,ΖZ,αa,βb,ψc,δd,εe,φf,γg,ηh,ιi,ξj,κk,λl,μm,νn,οo,πp,qq,ρr,σs,τt,θu,ωv,ςw,χx,υy,ζz
<	示例 (交换命令键 z 和 y 的意义): >
	    :set langmap=zy,yz,ZY,YZ
<
	'langmap' 选项是一个逗号分隔的部分列表。每个部分是两种形式之一:
	1.  组对的列表。每个组对包括 "from" 字符和后面立即跟随的 "to" 字符。
	    比如: "aA"，"aAbBcC"。
	2.  "from" 字符的列表，分号，然后是 "to" 字符的列表。例如: "abc;ABC"
	例如: "aA,fgh;FGH,cCdDeE"
	特殊字符需要在前面加上反斜杠。它们包括 ";"、',' 和反斜杠自身。

	这使你可以激活 vim 动作，而无须在语言之间来回切换。你的语言字符可以在
	下述情况下被理解为普通的 vim 英语字符 (根据本 langmap 的映射):
	 o 普通/可视模式 (命令，缓冲区/寄存器名，用户映射)
	 o 插入/替换模式: CTRL-R 之后的寄存器名
	 o 插入/替换模式: 映射
	命令行模式输入的字符_不_受本选项影响。注意 任何时刻，可以改变本选项来
	切换不同语言/编码的映射。使用映射以免每次都要重新输入一遍！
	(译者注: 本选项和 |:lmap| 的语言映射是两码事。)


+-*/+-*/langmenu o 菜单使用的语言
					*'langmenu'* *'lm'*
'langmenu' 'lm'		字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+menu| 和 |+multi_lang| 特性才有效}
	用于菜单翻译的语言。它指出从 'runtimepath' 里的 "lang" 目录里载入的文
	件是: >
		"lang/menu_" . &langmenu . ".vim"
<	(不包含空格)。例如，要使用荷兰语菜单，无论 $LANG 如何设置: >
		:set langmenu=nl_NL.ISO_8859-1
<	如果 'langmenu' 为空，使用 |v:lang| 代替。
	只能使用普通的文件名字符。"/\*?[|<>" 都不合法。
	如果你的 $LANG 设为非英语，但你希望使用英语的菜单: >
		:set langmenu=none
<	本选项必须在载入菜单、打开文件类型检测或语法高亮之前设置。一旦定义了菜
	单，本选项就不再有效果。但你可以这么做: >
		:source $VIMRUNTIME/delmenu.vim
		:set langmenu=de_DE.ISO_8859-1
		:source $VIMRUNTIME/menu.vim
<	警告: 这样会删除你自己定义的所有菜单！


+-*/+-*/language c 设置语言 (locale)
					    *:lan* *:lang* *:language* *E197*
:lan[guage]
:lan[guage] mes[sages]
:lan[guage] cty[pe]
:lan[guage] tim[e]
			显示当前的语言 (即 locale)。
			使用 "messages" 参数会显示出用作消息的语言。术语：
			LC_MESSAGES。
			使用 "ctype" 参数，会显示出用作字符编码的语言。术语：
			LC_CTYPE。
			使用 "time" 参数会显示出用作 strftime() 的语言。术语：
			LC_TIME。
			不加参数时显示当地语言的全称 (这个功能依赖于系统)。
			当前的语言同样也可以通过变量 |v:lang|、|v:ctype| 和
			|v:lc_time| 来获得。

+-*/+-*/lmap c 类似于 "":map!""，但包括 Lang-Arg 模式
:lm[ap]	{lhs} {rhs}		|mapmode-l|		*:lm* *:lmap*
:cm[ap]	{lhs} {rhs}		|mapmode-c|		*:cm* *:cmap*
			在映射命令作用的模式中把键系列 {lhs} 映射为 {rhs}。并
			且映射后的 {rhs} 也被进行映射扫描。这个特性可以用来进
			行映射的嵌套和递归。

+-*/+-*/lmapclear c 类似于 "":mapclear!""，但包括 Lang-Arg 模式
:lmapc[lear]			|mapmode-l|		*:lmapc*  *:lmapclear*
:cmapc[lear]			|mapmode-c|		*:cmapc*  *:cmapclear*
			在映射命令作用的模式中删除_所有_的映射。{Vi 无此功能}
			警告: 同时也会删除缺省的映射。

+-*/+-*/lnoremap c 类似于 "":noremap!""，但包括 Lang-Arg 模式
:ln[oremap] {lhs} {rhs}		|mapmode-l|		*:ln*  *:lnoremap*
:cno[remap] {lhs} {rhs}		|mapmode-c|		*:cno* *:cnoremap*
			在映射命令作用的模式中把键序列 {lhs} 映射为 {rhs} 。禁
			止对映射后的 {rhs} 进行映射扫描。这个特性可以避免映射
			的嵌套和递归。通常用于重定义一个命令。{Vi 无此功能}

+-*/+-*/loadkeymap c 载入后面的键盘映射表，直到 EOF 为止
		*keymap-file-format* *:loadk* *:loadkeymap* *E105* *E791*
键盘映射表的格式如下: >

+-*/+-*/lunmap c 类似于 "":unmap!""，但包括 Lang-Arg 模式
:lu[nmap] {lhs}			|mapmode-l|		*:lu*   *:lunmap*
:cu[nmap] {lhs}			|mapmode-c|		*:cu*   *:cunmap*
			在映射命令作用的模式中删除 {lhs} 的映射。该映射仍然可
			以在其它模式中保留其定义。
			备注: {lhs} 包含末尾的空格。该映射取消操作_不会_生效:
				:map @@ foo
				:unmap @@ | print

+-*/+-*/maxcombine o 显示的最大组合用字符数
						*'maxcombine'* *'mco'*
'maxcombine' 'mco'	数值型 (缺省为 2)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+multi_byte| 特性才有效}
	最大支持的显示用组合用字符的数目。
	只用于 'encoding' 为 "utf-8" 的时候。
	缺省值对多数语言足够了。希伯来语肯定要 4 个。
	最大值为 6。
	即使该选项设为 2，你仍然可以编辑有更多组合用字符的文本，只不过你看不到
	而已。用 |g8| 或 |ga|。见 |mbyte-combining|。


+-*/+-*/menutranslate c 增加菜单翻译项目
					*:menut* *:menutrans* *:menutranslate*
:menut[ranslate] clear
			清除所有的菜单翻译。

+-*/+-*/revins o 字符插入会反向进行
				*'revins'* *'ri'* *'norevins'* *'nori'*
'revins' 'ri'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	插入模式字符的输入反向工作。见 "反向输入" |ins-reverse|。如果置位
	'allowrevins'，本选项可以用插入模式下的 CTRL-_ 命令切换。
	注意: 如果置位 'compatible' 或 'paste'，该选项被复位。


+-*/+-*/rightleft o 窗口为从右到左模式
				 *'rightleft'* *'rl'* *'norightleft'* *'norl'*
'rightleft' 'rl'	布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	如果打开，显示的方向变为从右到左，也就是，存贮在文件里的字符看起来从右
	到左出现。
	使用该选项可以编辑从右到左书写的语言，比如希伯来语和阿拉伯语。
	该选项局部于窗口，所以可以同时编辑不同朝向的文件，或者用不同的方向阅读
	同一文件 (可用于有混合从右到左和从左到右字符串文本的文件，以便两个方向
	在不同的窗口里都能正确显示)。另见 |rileft.txt|。


+-*/+-*/rightleftcmd o 从右到左模式工作的编辑命令
			*'rightleftcmd'* *'rlc'*
'rightleftcmd' 'rlc'	字符串	(缺省为 "search")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+rightleft| 特性才有效}
	此选项里的每个单词允许命令行编辑的一组命令在从右到左模式下工作:

		search		"/" 和 "?" 命令

	可用于希伯来语、阿拉伯语和波斯语等语言。
	要使 'rightleftcmd' 生效，必须置位 'rightleft' 选项。


+-*/+-*/termbidi o 终端支持双向文本
						*'termbidi'* *'tbidi'*
						*'notermbidi'* *'notbidi'*
'termbidi' 'tbidi'	布尔型 (缺省关闭，"mlterm" 打开)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+arabic| 特性才有效}
	终端负责双向显示文本 (根据 Unicode 的定义)。也期待终端完成一些语言 (比
	如阿拉伯语) 所需的字型重整。
	置位本选项意味着置位 'arabic' 时不会置位 'rightleft'，而且也忽略
	'arabicshape' 的值。
	注意 置位 'termbidi' 会立即忽略 'arabicshape'，但 'rightleft' 不会自动
	进行修改。
	GUI 启动时复位本选项。
	详见 |arabic.txt|。


+-*/+-*/termencoding o 终端使用的编码方式
					*'termencoding'* *'tenc'*
'termencoding' 'tenc'	字符串	(缺省为 ""；GTK+ 2 GUI: "utf-8"；
					    Macintosh GUI: "macroman")
			全局
			{仅当编译时加入 |+multi_byte| 特性才有效}
			{Vi 无此功能}
	终端使用的编码。它指定键盘产生的和显示能识别的字符编码。对 GUI 而言，
	这只适用于键盘 ('encoding' 用于显示)。Mac 上如果 'macatsui' 关闭时例
	外，此时 'termencoding' 应是 "macroman"。
	在 Win32 控制台版本上，缺省值为控制台的代码页，如果和 ANSI 代码页有所
	不同的话。
								*E617*
	注意: 不适用于 GTK+ 2 GUI。那里，GUI 成功初始化后，'termencoding' 被强
	制设为 "utf-8"。任何试图设置不同值的努力都被拒绝，而且会给出错误消息。
	对于 Win32 GUI，'termencoding' 不用于输入的字符，因为 Win32 系统总是传
	入 Unicode 字符。
	如果为空，使用和 'encoding' 选项相同的编码。这是正常情况。
	不是所有的 'termencoding' 和 'encoding' 的组合都是可以的。见
	|encoding-table|。
	此选项的值必须被内部转换机制或 iconv() 支持。如果这不可能，不会进行任
	何转换，非 ASCII 字符可能会遇到问题。
	例如: 你在 euc-jp (日本语) locale 的设置下工作，但需要编辑 UTF-8 文
	件: >
		:let &termencoding = &encoding
		:set encoding=utf-8
<	如果你的系统没有 UTF-8 的 locale 支持，需要这么做。


+-*/print _ 打印
+-*/+-*/hardcopy c 发送文本到打印机
					*:ha* *:hardcopy* *E237* *E238* *E324*
:[range]ha[rdcopy][!] [arguments]
			打印 [range] 指定的行 (缺省是整个文件)。

+-*/+-*/printdevice o 用于 :hardcopy 的打印机名
						*'printdevice'* *'pdev'*
'printdevice' 'pdev'	字符串	(缺省为空)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer| 特性才有效}
	|:hardcopy| 使用的打印机名。
	见 |pdev-option|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/printencoding o 用于打印的编码方式
						*'printencoding'* *'penc'*
'printencoding' 'penc'	字符串	(缺省为空，有些系统除外)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer| 和 |+postscript| 特性才有
			效}
	设置打印时使用的字符编码。
	见 |penc-option|。


+-*/+-*/printexpr o 用于 :hardcopy 打印 PostScript 的表达式
						*'printexpr'* *'pexpr'*
'printexpr' 'pexpr'	字符串	(缺省: 见下)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer| 和 |+postscript| 特性才有
			效}
	用于打印 ":hardcopy" 产生的 PostScript 文件的表达式。
	见 |pexpr-option|。


+-*/+-*/printfont o 用于 :hardcopy 的字体名
						*'printfont'* *'pfn'*
'printfont' 'pfn'	字符串	(缺省为 "courier")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer| 特性才有效}
	|:hardcopy| 命令使用的字体名。
	见 |pfn-option|。


+-*/+-*/printheader o 用于 :hardcopy 的页眉格式
						*'printheader'* *'pheader'*
'printheader' 'pheader'	字符串  (缺省为 "%<%f%h%m%=Page %N")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer| 特性才有效}
	定义 |:hardcopy| 输出的页眉格式。
	见 |pheader-option|。


+-*/+-*/printmbcharset o 用于 :hardcopy 的 CJK 字符集
						*'printmbcharset'* *'pmbcs'*
'printmbcharset' 'pmbcs'  字符串 (缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer|、|+postscript| 和
			|+multi_byte| 特性才有效}
	|:hardcopy| 产生的 CJK 输出使用的 CJK 字符集。
	见 |pmbcs-option|。


+-*/+-*/printmbfont o 用于 :hardcopy 的 CJK 输出的字体名
						*'printmbfont'* *'pmbfn'*
'printmbfont' 'pmbfn'	字符串 (缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer|、|+postscript| 和
			|+multi_byte| 特性才有效}
	|:hardcopy| 产生的 CJK 输出使用的 CJK 字体名列表。
	见 |pmbfn-option|。


+-*/+-*/printoptions o 控制 :hardcopy 输出格式
						*'printoptions'* *'popt'*
'printoptions' 'popt'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+printer| 特性才有效}
	控制 |:hardcopy| 的输出格式的项目列表。
	见 |popt-option|。


+-*/quick _ 列表窗口
+-*/+-*/cNext c 跳转到上一个错误
:[count]cN[ext][!]			*:cp* *:cprevious* *:cN* *:cNext*
:[count]cp[revious][!]	显示含有文件名的列表中的往前第 [count] 个错误。如果没
			有文件名，则跳转到往前第 [count] 个错误。有关 [!] 和
			'switchbuf'，参见 |:cc|。

+-*/+-*/cNfile c 跳转到前一个文件的最后一个错误
:[count]cNf[ile][!]			*:cpf* *:cpfile* *:cNf* *:cNfile*
:[count]cpf[ile][!]	显示含有文件名的列表中往前第 [count] 个文件中的最后一
			个错误。如果没有文件名或是列表中没有下一个文件，则跳转
			到往前第 [count] 个错误。有关 [!] 和 'switchbuf'，参见
			|:cc|。

+-*/+-*/caddbuffer c 通过缓冲区补充错误
							*:caddb* *:caddbuffer*
:caddb[uffer] [bufnr]	读入当前缓冲区的错误列表，把这些错误加到当前 quickfix
			列表中。如果 quickfix 列表不存在，建立新的列表。其它部
			分和 ":cbuffer" 相同。

+-*/+-*/caddexpr c 通过表达式补充错误
							*:cad* *:caddexpr*
:cad[dexpr] {expr}	把 {expr} 的计算结果行加到当前 quickfix 列表中。如果
			quickfix 列表不存在，建立新的列表。不改变当前的光标位
			置。详情见 |:cexpr|。
			示例: >
    :g/mypattern/caddexpr expand("%") . ":" . line(".") .  ":" . getline(".")
<
							*:lad* *:laddexpr*
:lad[dexpr] {expr}	和 ":caddexpr" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/caddfile c 加入错误信息到当前 quickfix 列表
							*:caddf* *:caddfile*
:caddf[ile] [errorfile]	读入错误文件，把错误文件里的错误加到当前 quickfix 列表
			中。如果 quickfix 列表不存在，建立新的列表。

+-*/+-*/cbuffer c 分析错误信息并跳转到第一个
						*:cb* *:cbuffer* *E681*
:cb[uffer][!] [bufnr]	从当前缓冲区读入错误列表。如果给出 {bufnr}，它必须是已
			经载入的缓冲区号。这时使用该缓冲区，而不是当前缓冲区。
			可以指定使用的行范围。否则使用缓冲区的所有行。
			[!] 部分见 |:cc|。

+-*/+-*/cc c 跳转到特定的错误
							*:cc*
:cc[!] [nr]		显示错误 [nr]。如果不指定 [nr]，将再次显示相同的错误。
			如果不指定 [!]，则以下情况发生时无法跳转到另一个缓冲
			区: 若 'hidden' 和 'autowrite' 选项没被设定并且当前缓
			冲区只有一个窗口且被修改。
			当指定 [!] 跳转到另一个缓冲区时，当前缓冲区的修改会丢
			失，除非设定了 'hidden' 或该缓冲区还有其它窗口。
			当跳转到另一个缓冲区时，会受到 'switchbuf' 有关设定的
			影响。

+-*/+-*/cclose c 关闭 quickfix 窗口
							*:ccl* *:cclose*
:ccl[ose]		关闭 quickfix 窗口。

+-*/+-*/cexpr c 从表达式里读取错误并跳转到第一个
							*:cex* *:cexpr* *E777*
:cex[pr][!] {expr}	用 {expr} 的计算结果建立 quickfix 列表并跳转到首个错
			误。如果 {expr} 是字符串，那么字符串里每个换行符结尾的
			行用 'errorformat' 进行处理，其结果用来产生 quickfix
			列表。如果 {expr} 是列表类型，那么列表里的每个字符串项
			目被处理并加到 quickfix 列表里。列表里的非字符串项目被
			忽略。[!] 部分见 |:cc|。
			示例: >
				:cexpr system('grep -n xyz *')
				:cexpr getline(1, '$')
<
							*:lex* *:lexpr*
:lex[pr][!] {expr}	和 ":cexpr" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/cfile c 读入含有错误信息的文件，并跳转到第一个
							*:cf* *:cfile*
:cf[ile][!] [errorfile]	读入错误文件并跳转到首个错误。以 -q 选项启动 Vim 时会
			自动这样处理。用这个命令，你就可以在编译的同时继续用
			Vim 编辑。如果你指定错误文件名，那么 'errorfile' 选择
			将被设定为 [errorfile]。有关 [!]，参见 |:cc|。

+-*/+-*/cfirst c 跳转到指定的错误上，缺省为第一个
							*:cfirst* *:cfir*
:cfir[st][!] [nr]	和 ":crewind" 相同。

+-*/+-*/cgetbuffer c 从缓冲区里得到错误
						*:cgetb* *:cgetbuffer*
:cgetb[uffer] [bufnr]	从当前缓冲区读入错误列表。类似于 ":cbuffer"，只是不跳
			转到首个错误。

+-*/+-*/cgetexpr c 从表达实里得到错误
							*:cgete* *:cgetexpr*
:cgete[xpr] {expr}	用 {expr} 的计算结果建立 quickfix 列表。和 ":cexpr" 类
			似，只是不跳转到首个错误。

+-*/+-*/cgetfile c 读入含有错误信息的文件
:cg[etfile] [errorfile]					*:cg* *:cgetfile*
			读入错误文件。和 ":cfile" 类似，只是不跳转到首个错误。

+-*/+-*/clast c 跳转到指定的错误上，缺省为最后一个
							*:clast* *:cla*
:cla[st][!] [nr]	显示错误 [nr]。如果没指定 [nr]，则显示最后一个错误。参
			见 |:cc|。

+-*/+-*/clist c 列出所有错误
							*:cl* *:clist*
:cl[ist] [from] [, [to]]
			显示所有有效的错误 (参见 |quickfix-valid)。
			如果 [from] 和/或 [to] 被指定，则显示指定范围内的错
			误。负数从最后一个错误向前算起，-1 为最后一个错误。当
			跳转到另一个缓冲区时，会受到 'switchbuf' 有关设定的影
			响。

+-*/+-*/cnewer c 跳转到下一个较新的错误列表
						*:cnewer* *:cnew* *E381*
:cnew[er] [count]	到下一个新的错误列表。如果指定 [count]，则执行 [count]
			次。如果已经到达最新的列表，则报错。

+-*/+-*/cnext c 跳转到下一个错误
							*:cn* *:cnext* *E553*
:[count]cn[ext][!]d	显示含有文件名的列表中的往后第 [count] 个错误。如果没
			有文件名，则跳转到往后第 [count] 个错误。有关 [!] 和
			'switchbuf'，参见 |:cc|。

+-*/+-*/cnfile c 跳转到下一个文件的第一个错误
							*:cnf* *:cnfile*
:[count]cnf[ile][!]	显示含有文件名的列表中往后第 [count] 个文件中的首个错
			误。如果没有文件名或是列表中没有下一个文件，则跳转到往
			后第 [count] 个错误。有关 [!] 和 'switchbuf'，参见
			|:cc|。

+-*/+-*/colder c 跳转到上一个较老的错误列表
						*:colder* *:col* *E380*
:col[der] [count]	到前一个旧的错误列表。如果指定 [count]，则执行 [count]
			次。如果已经到达最旧的列表，则报错。

+-*/+-*/compiler c 为特定编译器设定选项
						*:comp* *:compiler* *E666*
:comp[iler][!] {name}		为 {name} 编译器设定相关选项。
				当没有 "!" 时设定只作用于当前缓冲区。如果使用
				了 "!" 则修改全局选项的值。
				如果你对于 "file.foo" 使用 ":compiler foo" 然
				后对另外一个缓冲区使用了 ":compiler! bar"，Vim
				会继续对 "file.foo" 文件使用 foo。
				{仅当编译时指定 |+eval|特性才有效}

+-*/+-*/copen c 打开 quickfix 窗口
					    *:cope* *:copen* *w:quickfix_title*
:cope[n] [height]	打开一个窗口显示当前的错误列表。
			如果指定 [height]，窗口设为指定高度 (如果有空间的话)，
			否则窗口为 10 行高。
			该窗口含有一个特殊的缓冲区，'buftype' 为 "quickfix"。
			不要修改此选项！ 如果已有了一个 quickfix 窗口，它将成
			为当前窗口。不可能再打开第二个 quickfix 窗口。该窗口会
			设置 w:quickfix_title 变量为生成 quickfix 列表的命令。
			可用于通过适当地调整 'statusline' 来定制状态行。

+-*/+-*/cpfile c 跳转到上一个文件的最后一个错误
:[count]cNf[ile][!]			*:cpf* *:cpfile* *:cNf* *:cNfile*
:[count]cpf[ile][!]	显示含有文件名的列表中往前第 [count] 个文件中的最后一
			个错误。如果没有文件名或是列表中没有下一个文件，则跳转
			到往前第 [count] 个错误。有关 [!] 和 'switchbuf'，参见
			|:cc|。

+-*/+-*/cprevious c 跳转到上一个错误
:[count]cN[ext][!]			*:cp* *:cprevious* *:cN* *:cNext*
:[count]cp[revious][!]	显示含有文件名的列表中的往前第 [count] 个错误。如果没
			有文件名，则跳转到往前第 [count] 个错误。有关 [!] 和
			'switchbuf'，参见 |:cc|。

+-*/+-*/cquit c 退出 Vim，带错误码
							*:cq* *:cquit*
:cq[uit][!]		以错误码退出 Vim。这样编译器就不会再次编译相同文件。
			_警告_: 对文件的所有改动都会丢失！即使没有 [!] 也是如
			此。类似于 ":qall!" |:qall|，但 Vim 返回非零退出码。

+-*/+-*/crewind c 跳到指定的错误，缺省为第一个
							*:crewind* *:cr*
:cr[ewind][!] [nr]	显示错误 [nr]。如果没指定 [nr]，则显示_首_个错误。参见
			|:cc|。

+-*/+-*/cwindow c 打开或者关闭 quickfix 窗口
							*:cw* *:cwindow*
:cw[indow] [height]	当存在可以识别的错误时，打开窗口。如果该窗口已经打开且
			没有可识别的错误，则将此窗口关闭。

+-*/+-*/errorfile o QuickFix 模式的错误文件名
						*'errorfile'* *'ef'*
'errorfile' 'ef'	字符串	(Amiga  缺省: "AztecC.Err"，
					其它: "errors.err")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+quickfix| 特性才有效}
	quickFix 模式使用的错误文件名 (见 |:cf|)。
	如果使用 "-q" 命令行参数，'errorfile' 设为它其后的参数。见 |-q|。
	_不_用于 ":make" 命令。为此目的，见 'makeef'。
	环境变量被扩展 |:set_env|。
	|option-backslash| 说明如何包含空格和反斜杠。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/errorformat o 错误文件行格式的描述
						*'errorformat'* *'efm'*
'errorformat' 'efm'	字符串	(缺省很长)
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
			{仅当编译时加入 |+quickfix| 特性才有效}
	类似于 scanf 风格的错误文件的行格式的描述 (见 |errorformat|)。


+-*/+-*/getloclist f 位置列表项目的列表
getloclist({nr})					*getloclist()*
		返回列表，包含窗口 {nr} 的位置列表的所有项目。如果 {nr} 为 0，
		使用当前窗口。
		如果是位置列表窗口，返回其显示的位置列表。如果窗口号 {nr} 非
		法，返回空列表。其它的情况和 |getqflist()| 相同。


+-*/+-*/getqflist f quickfix 错误的列表
getqflist()						*getqflist()*
		返回列表，包含所有当前 quickfix 错误。列表的每个项目是包含以下
		项目的字典:
			bufnr	有此文件名的缓冲区号，bufname() 得到缓冲区名
			lnum	缓冲区里的行号 (第一行是 1)
			col	列号 (第一列是 1)
			vcol	非零: "col" 是可视列
				零: "col" 是字节位置
			nr	错误号
			pattern	用于定位错误的搜索模式
			text	错误描述
			type	错误类型，'E'、'1' 等。
			valid	非零: 能识别该错误信息

		如果没有错误列表或者它为空，返回空列表。quickfix 列表项目如果
		包含不存在的缓冲区号，返回的 "bufnr" 置为零。

		应用: 在多个文件里寻找模式的匹配，并对之进行处理: >
			:vimgrep /theword/jg *.c
			:for d in getqflist()
			:   echo bufname(d.bufnr) ':' d.lnum '=' d.text
			:endfor



+-*/+-*/grep c 执行 'grepprg' 并转到第一个匹配处
							    *:gr* *:grep*
:gr[ep][!] [arguments]	和 ":make" 类似，但以 'grepprg' 替代 'makeprg'，以
			'grepformat' 替代 'errorformat'。
			如果 'grepprg' 是 "internal"，这等价于 |:vimgrep|。
			注意 这时模式必须用分隔字符包围。

+-*/+-*/grepadd c 类似 :grep，但附加到当前列表后
							*:grepa* *:grepadd*
:grepa[dd][!] [arguments]
			和 ":grep" 类似，但不另建一个新的错误列表，只是将匹配
			附加到当前列表中。
			比如: >
				:call setqflist([])
				:bufdo grepadd! something %
<			第一个命令新建一个空的错误列表。第二个命令对每个列出的
			缓冲区执行 "grepadd"。注意 ! 的使用是避免 ":grepadd"
			跳转到首个错误，|:bufdo| 不允许这样。
			一个使用参数列表并在没有匹配文件时不报错的例子: >
                                :silent argdo try 
				  \ | grepadd! something %
				  \ | catch /E480:/
				  \ | endtry"

+-*/+-*/lNext c 转到位置列表的上一个位置
:[count]lN[ext][!]			*:lp* *:lprevious* *:lN* *:lNext*
:[count]lp[revious][!]	和 ":cNext" 与 ":cprevious" 类似，但使用当前窗口的位置
			列表而不是 quickfix 列表。

+-*/+-*/lNfile c 转到上个文件的最近一个位置
:[count]lNf[ile][!]			*:lpf* *:lpfile* *:lNf* *:lNfile*
:[count]lpf[ile][!]	和 ":cNfile" 与 ":cpfile" 类似，但使用当前窗口的位置列
			表而不是 quickfix 列表。

+-*/+-*/laddbuffer c 通过缓冲区补充位置
							*:laddb* *:laddbuffer*
:laddb[uffer] [bufnr]	和 ":caddbuffer" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/laddexpr c 通过表达式补充位置
							*:lad* *:laddexpr*
:lad[dexpr] {expr}	和 ":caddexpr" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/laddfile c 把位置加到当前位置列表里
							*:laddf* *:laddfile*
:laddf[ile] [errorfile]	和 ":caddfile" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lbuffer c 分析位置并跳转到第一个位置
						*:lb* *:lbuffer*
:lb[uffer][!] [bufnr]	和 ":cbuffer" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lclose c 关闭位置窗口
							*:lcl* *:lclose*
:lcl[ose]		关闭显示当前窗口的位置列表的窗口。

+-*/+-*/lexpr c 从表达式里读取位置并跳转到第一个
							*:lex* *:lexpr*
:lex[pr][!] {expr}	和 ":cexpr" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lfile c 从文件里读取位置并跳转到第一个
							*:lf* *:lfile*
:lf[ile][!] [errorfile]	和 ":cfile" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。
			你不能用 -q 命令行选项设置位置列表。

+-*/+-*/lfirst c 转到指定的位置上，缺省第一个
							*:lfirst* *:lfir*
:lfir[st][!] [nr]	和 ":lrewind" 相同。

+-*/+-*/lgetbuffer c 从缓冲区里读取位置
						*:lgetb* *:lgetbuffer*
:lgetb[uffer] [bufnr]	和 ":cgetbuffer" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lgetexpr c 从表达式里读取位置
							*:lgete* *:lgetexpr*
:lgete[xpr] {expr}	和 ":cgetexpr" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lgetfile c 从文件里读取位置
:lg[etfile] [errorfile]					*:lg* *:lgetfile*
			和 ":cgetfile" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lgrep c 运行 'grepprg' 并跳转到第一个匹配
							    *:lgr* *:lgrep*

+-*/+-*/lgrepadd c 类似于 :grep，但附加到当前列表上
							*:lgrepa* *:lgrepadd*
:lgrepa[dd][!] [arguments]
			和 ":grepadd" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/ll c 转到指定位置
							*:ll*
:ll[!] [nr]		和 ":cc" 类似，但使用当前窗口的位置列表而不是 quickfix
			列表。

+-*/+-*/llast c 转到指定位置，缺省最后一个
							*:llast* *:lla*
:lla[st][!] [nr]	和 ":clast" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/llist c 列出所有的位置
							*:lli* *:llist*
:lli[st] [from] [, [to]]
			和 ":clist" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lmake c 执行外部命令 'makeprg' 并分析错误信息
							*:lmak* *:lmake*
:lmak[e][!] [arguments]
			和 ":make" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lnewer c 跳到较新的位置列表
						*:lnewer* *:lnew*
:lnew[er] [count]	和 ":cnewer" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lnext c 跳到下一个位置
							*:lne* *:lnext*
:[count]lne[xt][!]	和 ":cnext" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lnfile c 跳到下一个文件的第一个位置
							*:lnf* *:lnfile*
:[count]lnf[ile][!]	和 ":cnfile" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lolder c 转到较旧的位置列表
						*:lolder* *:lol*
:lol[der] [count]	和 ":colder" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lopen c 打开位置窗口
							*:lop* *:lopen*
:lop[en] [height]	打开一个窗口显示当前窗口的位置列表。只有当前窗口有位置
			列表的情况才能用。你可以同时打开多于一个的位置列表窗
			口。除此以外，和 ":copen" 相同。

+-*/+-*/lpfile c 转到上一个文件的最近的位置
:[count]lNf[ile][!]			*:lpf* *:lpfile* *:lNf* *:lNfile*
:[count]lpf[ile][!]	和 ":cNfile" 与 ":cpfile" 类似，但使用当前窗口的位置列
			表而不是 quickfix 列表。

+-*/+-*/lprevious c 转到前一个位置
:[count]lN[ext][!]			*:lp* *:lprevious* *:lN* *:lNext*
:[count]lp[revious][!]	和 ":cNext" 与 ":cprevious" 类似，但使用当前窗口的位置
			列表而不是 quickfix 列表。

+-*/+-*/lrewind c 转到指定的位置，缺省第一个
							*:lrewind* *:lr*
:lr[ewind][!] [nr]	和 ":crewind" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lvimgrep c 在若干文件里搜索模式
							*:lv* *:lvimgrep*
:lv[imgrep][!] /{pattern}/[g][j] {file} ...
:lv[imgrep][!] {pattern} {file} ...
			和 ":vimgrep" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lvimgrepadd c 类似于 :vimgrep，但附加到当前列表
						*:lvimgrepa* *:lvimgrepadd*
:lvimgrepa[dd][!] /{pattern}/[g][j] {file} ...
:lvimgrepa[dd][!] {pattern} {file} ...
			和 ":vimgrepadd" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/lwindow c 打开或关闭位置窗口
							*:lw* *:lwindow*
:lw[indow] [height]	和 ":cwindow" 类似，但使用当前窗口的位置列表而不是
			quickfix 列表。

+-*/+-*/make c 执行外部命令 'makeprg' 并分析其错误信息
							*:mak* *:make*
:mak[e][!] [arguments]	1. 如果 Vim 编译时带 |+autocmd|，执行所有相关的
			   |QuickFixCmdPre| 自动命令。
			2. 如果设定 'autowrite'，则写入所有修改过的缓冲区。
			3. 根据 'makeef' 的值产生错误文件。如果 'makeef' 值不
			   包含 "##" 且此文件已存在，则该文件会被先删除。
			4. 'makeprg' 选项指定的程序 (缺省为 "make") 被启动，
			   [arguments] 为其参数。其输出被储存到错误文件名 (如
			   是 Unix，也会在屏幕上显示)。
			5. 错误文件以 'errorformat' 格式读入。
			6. 如果 Vim 编译时带 |+autocmd|，执行所有相关的
			   |QuickFixCmdPost| 自动命令。
			   见下例。
			7. 如果没指定 [!]，则跳转到首个错误。
			8. 错误文件被删除。
			9. 你现在可以用 |:cnext|，|:cprevious| 等命令在错误间
			   移动。见上。
			本命令不接受注释，所有的 " 将被视为参数的一部分。

+-*/+-*/makeef o "":make"" 所用的错误文件名
						*'makeef'* *'mef'*
'makeef' 'mef'		字符串	(缺省: "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+quickfix| 特性才有效}
	|:make| 和 |:grep| 命令的错误文件的名字 (见 |:make_makeprg|)。
	如果为空，使用内部生成的临时文件。
	如果包含 "##"，它被一个数值代替，使完整的名字唯一。这确保 ":make" 命令
	不会覆盖已有的文件。
	_不_用于 ":cf" 命令。那里用到的是 'errorfile'。
	环境变量被扩展 |:set_env|。
	|option-backslash| 说明如何包含空格和反斜杠。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/setloclist f 修改位置列表
setloclist({nr}, {list} [, {action}])			*setloclist()*
		创建或替代或加入到窗口 {nr} 的位置列表。
		如果 {nr} 为零，使用当前窗口。如果是位置列表窗口，修改所显示的
		位置列表。如果窗口号 {nr} 非法，返回 -1。
		其它同 |setqflist()|。
		另见 |location-list|。


+-*/+-*/setqflist f 修改 quickfix 列表
setqflist({list} [, {action}])				*setqflist()*
		用 {list} 的项目来创建或替代或加入到 quickfix 表。每个 {list}
		项目是一个字典。
		{list} 里非字典的项目被忽略。每个字典项目可以包含以下的项目:

		    bufnr	缓冲区号；必须为某个合法缓冲区的编号
		    filename	文件名；仅当 "bufnr" 不存在或者不合法时才使用
		    lnum	缓冲区里的行号
		    pattern	用于定位错误的模式
		    col		列号
		    vcol	非零: "col" 是可视列
				零: "col" 是字节位置
		    nr		错误号
		    text	错误描述
		    type	错误类型，'E'、'W' 等。
	
		"col"、"vcol"、"nr"、"type" 和 "text" 项目是可选的。"lnum" 或
		"pattern" 项目用来定位匹配的错误行。
		如果 "filename" 和 "bufnr" 项目都不存在或者 "lnum" 和
		"pattern" 项目都不存在，那么此项目不被当作错误行处理。
		如果 "pattern" 和 "lnum" 都存在，使用 "pattern"。
		如果 {list} 为空，quickfix 列表被清除。
		注意 此列表和 |getqflist()| 返回之值不尽相同。

		如果 {action} 设为 'a'，把 {list} 项目加入已有的 quickfix 列
		表。如果该列表尚不存在，建立新表。如果 {action} 设为 'r'，
		{list} 项目替换当前 quickfix 列表项目。如果 {action} 不存在或
		者设为 ' '，那么建立新表。

		返回零代表成功，-1 代表失败。

		该函数用来独立于 'errorformat' 的设置建立 quickfix 列表。
		":cc 1" 这样的命令可以跳转到第一个位置上。


							*setreg()*
+-*/+-*/shellpipe o 把 "":make"" 结果输出到错误文件的字符串
						*'shellpipe'* *'sp'*
'shellpipe' 'sp'	字符串	(缺省为 ">"、"| tee"、"|& tee" 或 "2>&1| tee")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+quickfix| 特性才有效}
	用于把 ":make" 命令输出存到错误文件的字符串。另见 |:make_makeprg|。
	|option-backslash| 说明如何包含空格和反斜杠。
	如有需要，临时文件名可以用 "%s" 表示 (如果选项值里没有 %s，该文件名自
	动添加在最后)。
	Amiga 和 MS-DOS 上，缺省为 ">"。输出直接存到文件里，不在屏幕上回显。
	Unix 上，缺省是 "| tee"。编译器的标准输出存到文件里，并在屏幕上回显。
	如果初始化后，'shell' 选项是 "csh" 或 "tcsh"，缺省值变为 "|& tee"。如
	果 'shell' 选项为 "sh"、"ksh"、"zsh" 或 "bash"，缺省值为 "2>&1| tee"。
	这意味着标准错误 (stderr) 也被包含在内。使用 "shell" 选项时排除路径部
	分，也就是 "/bin/sh" 被当成 "sh"。
	此选项的初始化在读入 ".vimrc" 和其它初始化步骤之后完成，所以如果那里设
	置 'shell' 选项，'shellpipe' 选项被自动更改，除非之前已经被显式地设置
	过。
	如果 'shellpipe' 设为空字符串，不进行 ":make" 输出的重定向。这可用于自
	己会写入 'makeef' 的 'makeprg' 程序。如果你不用管道，但要加入 'makeef'
	作为参数，设置 'shellpipe' 为单个空格。不要忘了在空格之前加上反斜杠:
	":set sp=\ "。
	将来，管道可能用于过滤程序，而此选项可能会被废弃 (至少对 Unix 如此)。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/vimgrep c 在若干文件里查找模式
					*:vim* *:vimgrep* *E682* *E683*
:vim[grep][!] /{pattern}/[g][j] {file} ...
			在文件 {file} ... 里搜索模式 {pattern}，并用匹配结果设
			置错误列表。
			如果没有 'g' 标志位，每行只加一次。
			如果有 'g'，每个匹配都被加入。

+-*/+-*/vimgrepadd c 类似于 :vimgrep，但附加到当前列表
						*:vimgrepa* *:vimgrepadd*
:vimgrepa[dd][!] /{pattern}/[g][j] {file} ...
:vimgrepa[dd][!] {pattern} {file} ...
			和 ":vimgrep" 类似，但不是建立新的错误列表，而是附加到
			现有的列表之后。

+-*/search _ 搜索
+-*/+-*/edcompatible o 切换 "":substitute"" 命令的标志位
			   *'ed'* *'edcompatible'* *'noed'* *'noedcompatible'*
'edcompatible' 'ed'	布尔型	(缺省关闭)
			全局
	使得 ":substitute" 命令的 'g' 和 'c' 标志位在每次使用时切换。见
	|complex-change|。另见 'gdefault' 选项。
	不鼓励打开此选项！


+-*/+-*/gdefault o 缺省打开 "":substitute"" 的 'g' 标志
				   *'gdefault'* *'gd'* *'nogdefault'* *'nogd'*
'gdefault' 'gd'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果打开，":substitute" 的 'g' 标志位缺省打开。这意味着所有的行内匹配
	都被替换，而不是只有一个。这样，":substitute" 命令里使用一个 'g' 标志
	位会切换一次替代使用的所有/单个匹配方式。见 |complex-change|。

		命令		'gdefault' 打开	'gdefault' 关闭	~
		:s///		  替代所有	  替代单个
		:s///g		  替代单个	  替代所有
		:s///gg		  替代所有	  替代单个

	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/hlsearch o 高亮最近的匹配搜索模式
				 *'hlsearch'* *'hls'* *'nohlsearch'* *'nohls'*
'hlsearch' 'hls'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+extra_search| 特性才有效}
	如果有上一个搜索模式，高亮它的所有匹配。使用高亮的类型可以用
	'highlight' 选项的 'l' 位设置。缺省，使用 "Search" 高亮组。注意 只有匹
	配的文本被高亮，位移此处不予考虑。
	另见: 'incsearch' 和 |:match|。
	如果你厌倦总是看到高亮匹配，用 |:nohlsearch| 可以暂时关闭。一旦使用搜
	索命令，高亮会重新出现。
	'redrawtime' 指定寻找匹配会花费的最大时间。
	如果搜索模式可以匹配换行符，Vim 会试图高亮所有的匹配文本。不过，这依赖
	于搜索从哪里开始。如果是窗口的第一行，或者关闭折叠之下的第一行，那么从
	它们不会显示的上一行开始的匹配不会在新显示的行上继续。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/ignorecase o 搜索模式时忽略大小写
			*'ignorecase'* *'ic'* *'noignorecase'* *'noic'*
'ignorecase' 'ic'	布尔型	(缺省关闭)
			全局
	搜索模式里忽略大小写。也用于标签文件的查找。
	另见 'smartcase'。
	可以在模式里使用 "\c" 或 "\C" 否决这里的设置。见 |/ignorecase|。


+-*/+-*/incsearch o 输入搜索模式时同时高亮部分的匹配
				 *'incsearch'* *'is'* *'noincsearch'* *'nois'*
'incsearch' 'is'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+extra_search| 特性才有效}
	输入搜索命令时，显示目前输入的模式的匹配位置。匹配的字符串被高亮。如果
	该模式不合法或者没有匹配，不显示任何东西。屏幕会经常刷新，所以只有
	对快速终端，这才有意义。
	注意 会显示匹配，但如果找不到匹配和按 <Esc> 的时候，光标会回到原来的位
	置。你仍然需要用 <Enter> 完成搜索命令才会移动光标到匹配位置。
	编译时加入 |+reltime| 特性时，Vim 只会搜索大概半秒钟。如果模式太过复杂
	和/或有很多文本存在，不一定能找到匹配。这是为了避免 Vim 在输入模式的时
	候挂起。
	可以用 'highlight' 的 'i' 标志位设置高亮。另见: 'hlsearch'。
	CTRL-L 可用来在命令行上给当前匹配之后增加一个字符。如果置位了
	'ignorecase' 和 'smartcase' 而命令行上没有大写字符，加入的字符被转换为
	小写。
	CTRL-R CTRL-W 可用来在当前匹配的尾部增加单词，排除已经输入的部分。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/magic o 改变搜索模式所用的特殊字符
						*'magic'* *'nomagic'*
'magic'			布尔型	(缺省打开)
			全局
	改变搜索模式使用的特殊字符。见 |pattern|。
	注意: 为了避免使用模式的移植性问题，永远把本选项设为缺省 "打开" 状态。
	只有在旧的 Vi 脚本里才需要把它关闭。任何别的情况下，使用能在 'magic'
	打开状态下工作的模式。如果你一定要的话，包含 "\M" |\M|。


+-*/+-*/nextnonblank f 查找下一个非空白行
nextnonblank({lnum})					*nextnonblank()*
		返回第一个从 {lnum} 开始的非空白行的行号。例如: >
			if getline(nextnonblank(1)) =~ "Java"
<		如果 {lnum} 非法或者在从该行开始都没有非空白行，返回零。
		另见 |prevnonblank()|。


+-*/+-*/nohlsearch c 暂停 'hlsearch' 高亮
							*:noh* *:nohlsearch*
:noh[lsearch]		停止 'hlsearch' 选项的高亮显示。如果再执行查找命令或者
			设定 'hlsearch' 选项，高亮会自动打开。此命令无法在自动
			命令里使用，因为高亮的状态会在自动命令执行期间自动保存
			和恢复 |autocmd-searchpat|。
			执行用户函数时也是如此。

+-*/+-*/prevnonblank f 查找前一个非空白行
prevnonblank({lnum})					*prevnonblank()*
		返回第一个 {lnum} 所在或之上的非空白行的行号。例如: >
			let ind = indent(prevnonblank(v:lnum - 1))
<		如果 {lnum} 非法或者在该行和它之前都没有非空白行，返回零。
		另见 |nextnonblank()|。



+-*/+-*/search f 查找模式的匹配
search({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*search()*
		搜索正规表达式模式 {pattern}。搜索从光标位置 (用 |cursor()| 可
		以得到) 开始。
		{flags} 是字符串，可以包含以下字符标志位:
		'b'	反向搜索，而不是正向搜索
		'c'     接受光标位置上的匹配
		'e'	移到匹配的尾部
		'n'	不 (Not) 移动光标
		'p'	返回匹配的子模式号 (见下)
		's'	在光标上次的位置上设置 ' 位置标记
		'w'	在文件尾部处回绕到文件开始处
		'W'	不在文件尾部处回绕
		如果 'w' 和 'W' 都没有给出，根据 'wrapscan' 选项决定。

		如果提供 's' 标志位，只有在光标移动的时候才设置 ' 位置标记。
		's' 标志位不能和 'n' 标志位一起使用。

		适用 'ignorecase'、'smartcase' 和 'magic' 标志位。

		如果给出 {stopline} 参数，搜索在搜索完该行后结束。可用于限制搜
		索在给出的行范围内。例如: >
			let match = search('(', 'b', line("w0"))
			let end = search('END', '', line("w$"))
<		如果使用了 {stopline} 且非零，隐含意味着搜索不会在文件尾回绕。
		零就相当于没给出该参数。

		如果给出 {timeout} 参数，搜索在超过给出的毫秒数后中止。这样，
		如果 {timeout} 为 500，搜索在半秒钟后中止。该值不能为负。
		零就相当于没给出该参数。
		{仅当在编译时加入 |+reltime| 特性才有效}

		如果找不到匹配，返回 0 并且光标位置不改变。不会给出错误信息。
		如果找到了匹配，返回其所在的行号。
							*search()-sub-match*
		如果有 'p' 标志位，返回值比第一个匹配的 \(\) 里的子模式的编号
		多一。如果所有子模式都不匹配但整个模式匹配，返回一。
		要得到列号，使用 |searchpos()|。

		光标定位在匹配的文本上，除非使用了 'n' 标志位。

		示例 (遍历参数列表里的所有文件): >
		    :let n = 1
		    :while n <= argc()	    " 循环遍历参数列表的每个文件
		    :  exe "argument " . n
		    :  " 从文件最后一个字符开始并回绕，这样第一个搜索可以找到
		    :  " 文件开始的匹配
		    :  normal G$
		    :  let flags = "w"
		    :  while search("foo", flags) > 0
		    :    s/foo/bar/g
		    :	 let flags = "W"
		    :  endwhile
		    :  update		    " 如果修改过，写入文件
		    :  let n = n + 1
		    :endwhile
<


+-*/+-*/searchdecl f 查找名字的声明
searchdecl({name} [, {global} [, {thisblock}]])			*searchdecl()*
		搜索 {name} 的声明。
		
		如果 {global} 参数非零，使用 |gD| 的工作方式，寻找文件的第一个
		匹配。否则使用 |gd| 的工作方式，寻找函数里的第一个匹配。

		如果 {thisblock} 参数非零，忽略光标位置前结束的 {} 块里的匹
		配。可以避免只有在别的作用域里才有效的变量声明。

		移动光标到找到的匹配上。
		返回零代表成功，非零代表失败。
		例如: >
			if searchdecl('myvar') == 0
			   echo getline('.')
			endif
<
							*searchpair()*
+-*/+-*/searchpair f 查找 start/skip/end 配对的另一端
searchpair({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		搜索嵌套的 start-end 组对的匹配。这可以用来查找匹配 "if" 的
		"endif"。在这里面的其它的 if/endif 组对被忽略。搜索从光标开
		始。缺省正向搜索，在 {flags} 里包含 'b' 的时候反向搜索。
		如果找到一个匹配，光标移动到那里并返回行号。如果没有匹配，
		返回 0 或者 -1，光标不移动。不会给出错误信息。

		{start}、{middle} 和 {end} 都是模式，见 |pattern|。它们不能包
		含 \( \) 对，但可以使用 \%( \)。如果 {middle} 非空，在相应的方
		向试图寻找它 (如果找到，停留在哪里)，但在嵌套的 start-end 组对
		里面的不算。一个典型的应用是: >
			searchpair('\<if\>', '\<else\>', '\<endif\>')
<		如果 {middle} 为空，跳过 "else"。

		{flags} 'b'、'c'、'n'、's'、'w' 和 'W' 的使用方式和 |search()|
		类似。此外，还可用:
		'r'	重复 (Repeat) 直到没有更多匹配位置；会找到最外层的组
		        对。隐含 'W' 标志位。
		'm'	返回匹配 (Match) 的数目而不是匹配的行号；使用 'r' 时会
			> 1。
		备注: 最好使用 'W' 标志位，避免在文件尾回绕。

		如果找到 {start}、{middle} 或 {end} 的匹配，计算 {skip} 表达
		式，此时假定光标定位在匹配的开始处。如果返回零，该匹配被跳过。
		比如，可能是出现在注释里的匹配。
		如果 {skip} 不提供或者为空，接受每一个匹配。如果计算 {skip} 时
		出现错误，搜索被中止，并返回 -1。

		{stopline} 和 {timeout} 见 |search()|。

		使用 'ignorecase' 的值。忽略 'magic'，使用模式时假设它总是置位
		的。

		搜索从准确的光标处开始。根据搜索方向，寻找从下一个字符开始的
		{start}、{middle} 或 {end}。比如: >
			if 1
			  if 2
			  endif 2
			endif 1
<		如果从 "if 2" 开始且光标在 "i" 上并正向搜索，找到的是
		"endif 2"。如果刚好在 "if 2" 之前开始，找到的是 "endif 1"。因
		为先找到的了 "if 2"，而它被认为是嵌套的 if/endif，以 "if 2"
		开始，以 "endif 2" 结束。
		如果反向搜索且 {end} 多于一个字符，在模式的最后加上 "\zs" 可能
		有用，这样光标在 end 匹配的中间某位置的时候，仍然可以找到匹配
		的 start 匹配。

		例如，要找到 Vim 脚本里的 "endif" 命令: >

	:echo searchpair('\<if\>', '\<el\%[seif]\>', '\<en\%[dif]\>', 'W',
			\ 'getline(".") =~ "^\\s*\""')

<		光标必须在要寻找匹配的 "if" 之上或之后。注意 单引号字符串的使
		用，它避免了反斜杠的麻烦。skip 表达式只用来发现行首的注释，命
		令之后的不行。另外，一行中间的单词 "en" 或 "if" 也被认为是匹
		配。
		另一个例子，搜索匹配 "}" 的 "{": >

	:echo searchpair('{', '', '}', 'bW')

<		只需要光标在需要匹配的 "}" 之上或之前就可以了。要拒绝语法高亮
		识别为字符串的匹配: >

	:echo searchpair('{', '', '}', 'bW',
	     \ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string"')
<
							*searchpairpos()*
+-*/+-*/searchpairpos f 查找 start/skip/end 配对的另一端
searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}
				[, {stopline} [, {timeout}]]]])
		和 |searchpair()| 相同，但返回 |List|，包含匹配的行号和列号。
		|List| 的第一个元素是行号，而第二个元素是匹配所在的列位置的字
		节位置。如果没有匹配，返回 [0, 0]。 >

			:let [lnum,col] = searchpairpos('{', '', '}', 'n')
<
		|match-parens| 提供一个更复杂更有用的例子。


+-*/+-*/searchpos f 寻找模式的匹配
searchpos({pattern} [, {flags} [, {stopline} [, {timeout}]]])	*searchpos()*
		和 |search()| 相同，但返回 |List|，包含匹配的行号和列号。
		|List| 的第一个元素是行号，而第二个元素是匹配所在的列位置的字
		节位置。如果没有匹配，返回 [0, 0]。
		例如: >
	:let [lnum, col] = searchpos('mypattern', 'n')

<		如果给出 'p' 标志位，返回值里有一个附加项目，包含匹配的子模式
		号 |search()-sub-match|。例如: >
	:let [lnum, col, submatch] = searchpos('\(\l\)\|\(\u\)', 'np')
<		此例中如果找到小写字母 |/\l| "submatch" 为 2，如果找到大写字母
		|/\u| 则为 3。


+-*/+-*/smagic c 带 'magic' 的 :substitute
						*:smagic* *:sm*
:[range]sm[agic] ...	和 ":substitute" 相同，但总使用 'magic'。
			{Vi 无此功能}

+-*/+-*/smartcase o 模式中有大写字母时不忽略大小写
			*'smartcase'* *'scs'* *'nosmartcase'* *'noscs'*
'smartcase' 'scs'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果搜索模式包含大写字符，不使用 'ignorecase' 选项。只有在输入搜索模式
	并且打开 'ignorecase' 选项时才会使用。用于 "/"、"?"、"n"、"N"、 ":g"
	和 ":s" 命令。不用于 "*"、"#"、"gd"、标签查找等。在 "*" 和 "#" 之后，
	可以通过 "/" 命令从历史里回忆搜索模式，然后按回车使用 'smartcase'。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/snomagic c 带 'nomagic' 的 :substitute
						*:snomagic* *:sno*
:[range]sno[magic] ...	和 ":substitute" 相同，但总使用 'nomagic'。
			{Vi 无此功能}

+-*/+-*/substitute c 查找和替代文本
4.2 替代						*:substitute*
							*:s* *:su*
:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]
			对 [range] 指定的行把 {pattern} 的匹配替代成
			{string}。
			关于 {pattern}，参见 |pattern|。
			{string} 可以是按字面意义的，也可以包含特殊字符。
			参见 |sub-replace-special|。
			如果不指定 [range] 和 [count]，仅在当前行进行替代。
			如果指定 [count]，在 [range] 最后一行开始的 [count]
			行进行替代。如果不指定 [range] ，则从当前行开始。
			另见 |cmdline-ranges|。
			关于 [flags]，参见 |:s_flags|。

+-*/shell _
+-*/+-*/bioskey o MS-DOS: 用 bios 调用取得字符输入
			*'bioskey'* *'biosk'* *'nobioskey'* *'nobiosk'*
'bioskey' 'biosk'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}  {仅适用于 MS-DOS}
	如果打开，调用 BIOS 得到键盘字符。这对检测 CTRL-C 更有效，但只适用于控
	制台模式。如果在通过窗口连接的终端上使用，复位此选项。
	另见 |'conskey'|。


+-*/+-*/conskey o 直接从控制台读入键击 (只限于 MS-DOS)
			*'conskey'* *'consk'* *'noconskey'* *'noconsk'*
'conskey' 'consk'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}  {仅适用于 MS-DOS}
	如果打开，使用直接的控制台输入/输出来取得键盘字符。多数情况下这应该没
	有问题。另见 |'bioskey'|。总共有三种可用的控制台输入方法:
	'conskey'   'bioskey'	    行动 ~
	   开	     开关均可	    直接控制台输入
	   关		开	    BIOS
	   关		关	    标准输入


+-*/+-*/mode c 显示或者改变屏幕模式
						*:mod* *:mode* *E359* *E362*
:mod[e] [mode]

+-*/+-*/restorescreen o Win32: 退出时恢复屏幕
			 *'restorescreen'* *'rs'* *'norestorescreen'* *'nors'*
'restorescreen' 'rs'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}  {仅适用于 Windows 95/NT 控制台版本}
	如果置位，屏幕内容在退出 Vim 后恢复。也适用于执行外部命令时。

	对于非 Windows 的 Vim: 你可以在 .vimrc 里置位和复位 't_ti' 和 't_te'
	选项。要禁止复原:
		set t_ti= t_te=
	要允许复原 (如果是 xterm):
		set t_ti=^[7^[[r^[[?47h t_te=^[[?47l^[8
	(其中 ^[ 是一个 <Esc>，输入 CTRL-V <Esc> 可以插入)


+-*/+-*/shell o 使用外部命令的 shell 程序名字
						*'shell'* *'sh'* *E91*
'shell' 'sh'		字符串	(缺省为 $SHELL 或 "sh"，
					MS-DOS 和 Win32: "command.com" 或
					"cmd.exe"，OS/2: "cmd")
			全局
	用于 ! 和 :! 命令的外壳名。如果改变此值，同时检查以下选项:
	'shelltype'、'shellpipe'、'shellslash'、'shellredir'、'shellquote'、
	'shellxquote' 和 'shellcmdflag'。
	可以给出命令所需的参数，比如 "csh -f"。
	|option-backslash| 说明如何包含空格和反斜杠。
	环境变量被扩展 |:set_env|。
	外壳的名字可以包含空格，你可能需要把它们放在引号里。比如: >
		:set shell=\"c:\program\ files\unix\sh.exe\"\ -f
<	注意 每个引号 (避免作为注释的开始) 和每个空格 (避免作为选项值的终止)
	之前的反斜杠。还要 注意 "-f" 不在引号里，因为它不是命令名本身的一部
	分。Vim 自动地 (神奇地) 识别作为路径分隔符的反斜杠。
	DOS 32 位版本 (DJGPP) 上，你可以设置 $DJSYSFLAGS 环境变量来改变外部命
	令的执行方式。见 DJGPP 的 libc.inf 文件。
	MS-Windows 上，如果执行文件以 ".com" 结尾，必须把它包含在内。这样，设
	置外壳为 "command.com" 或 "4dos.com" 没问题，但 "command" 和 "4dos" 就
	不能适用于所有命令 (比如，过滤命令)。
	因为未知的原因，使用 "4dos.com" 时，当前目录被改为 "C:\"。要避免这个问
	题，设置 'shell' 为: >
		:set shell=command.com\ /c\ 4dos
<	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/shell c 退到外壳程序
							*:sh* *:shell* *E371*
:sh[ell]		该命令启动一个外壳。外壳退出后 (执行完 "exit" 命令)，
			你会回到 Vim。外壳命令的名字来自 'shell' 选项。
							*E360*
			注意: 当 Vim 在 Amiga 上通过编译器的 QuickFix 模式时启
			动时，该命令不能使用。这是因为编译器把标准输入设为非交
			互模式。

+-*/+-*/shellcmdflag o 执行命令所使用的 shell 的参数
						*'shellcmdflag'* *'shcf'*
'shellcmdflag' 'shcf'	字符串	(缺省: "-c"，MS-DOS 和 Win32，如果 'shell' 不
					包含 "sh" 的话: "/c")
			全局
			{Vi 无此功能}
	执行 "!" 和 ":!" 命令时传递给外壳的参数；比如，"bash.exe -c ls" 或
	"command.com /c dir"。对于 MS-DOS 系列的系统，缺省的设置根据 'shell'
	的值而定，以减少用户自行设置此选项的需要。OS/2 不用此选项 (EMX 自己会
	发现应该怎么做)。
	|option-backslash| 说明如何包含空格和反斜杠。
	见 |dos-shell|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/shellquote o 括起 shell 命令的字符
						*'shellquote'* *'shq'*
'shellquote' 'shq'	字符串	(缺省: ""；MS-DOS 和 Win32，如果 'shell' 不包
				含 "sh" 的话: "\"")
			全局
			{Vi 无此功能}
	(一或多个) 引用字符，用来包围 "!" 和 ":"!" 命令里传递给外壳的命令。
	重定向在引用之外。要把重定向包含在内，见 'shellxquote'。可能没有必要同
	时设置这两个选项。
	缺省是一个空字符串。已知只有对 MS-DOS 系列的系统上的第三方外壳有用，比
	如 MKS Korn Shell 或 bash，那里本选项应是 "\""。缺省值会根据 'shell'
	的值调整，以减少用户自行设置该选项的需要。见 |dos-shell|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/shellredir o 把过滤命令的输出存到暂时文件的字符串
						*'shellredir'* *'srr'*
'shellredir' 'srr'	字符串	(缺省为 ">"，">&" 或 ">%s 2>&1")
			全局
			{Vi 无此功能}
	用于把过滤命令输出存到临时文件的字符串。另见 |:!|。
	|option-backslash| 说明如何包含空格和反斜杠。
	如有需要，临时文件名可以用 "%s" 表示 (如果选项值里没有 %s，该文件名自
	动添加在最后)。
	缺省为 ">"。Unix 上，如果初始化后，'shell' 选项是 "csh"、"tcsh" 或
	"zsh"，缺省值为 ">&"。如果 'shell' 选项为 "sh"、"ksh" 或 "bash"，缺省
	值则为 ">%s 2>&1"。这意味着标准错误 (stderr) 也被包含在内。
	Win32 上，进行 Unix 同样的检查，另外还检查 "cmd"，缺省是 ">%s 2>&1"。
	此外，检查相同但有 ".exe" 后缀的名字。
	此选项的初始化在读入 ".vimrc" 和其它初始化步骤之后完成，所以如果那里设
	置 'shell' 选项，'shellredir' 选项被自动更改，除非之前已经被显式地设置
	过。
	将来，管道可能用于过滤程序，而此选项可能会被废弃 (至少对 Unix 如此)。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/shellslash o shell 文件名使用正斜杠
			*'shellslash'* *'ssl'* *'noshellslash'* *'nossl'*
'shellslash' 'ssl'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能} {仅适用于 MSDOS、MS-Windows 和 OS/2}
	如果置位，扩展文件名时使用正斜杠。如果使用 Unix 风格的外壳代替
	command.com 或 cmd.exe，这会有用。你仍然可以输入反斜杠，但 Vim 会把它
	们换成正斜杠。
	注意 置位或复位本选项对已有的文件名没有影响，所以为了最佳的效果，本选
	项需要在打开任何文件之前使用。将来此行为或许会有改变。
	'shellslash' 只用于使用反斜杠作为路径分隔符的系统。要看是否如此: >
		if exists('+shellslash')
<

+-*/+-*/shelltemp o shell 命令是否使用临时文件
			*'shelltemp'* *'stmp'* *'noshelltemp'* *'nostmp'*
'shelltemp' 'stmp'	布尔型	(Vi 缺省关闭，Vim 缺省打开)
			全局
			{Vi 无此功能}
	如果打开，外壳命令使用临时文件。如果关闭，使用管道。
	如果不能使用管道，无论如何总使用临时文件。
	目前，只有 Unix 支持管道。你可以这样检查: >
		:if has("filterpipe")
<	使用管道的好处是没人能够读到临时文件，而 'shell' 命令不须支持重定向。
	临时文件的好处可以检测文件类型和编码。
	|FilterReadPre|、|FilterReadPost|、|FilterWritePre|、|FilterWritePost|
	自动命令事件在 'shelltemp' 关闭时不会激活。


+-*/+-*/shelltype o Amiga: 影响如何使用 shell
						*'shelltype'* *'st'*
'shelltype' 'st'	数值型	(缺省为 0)
			全局
			{Vi 无此功能} {仅适用于 Amiga}
	Amiga 上，此选项影响使用外壳的命令的工作方式。
	0 和 1: 总是用外壳
	2 和 3: 只用外壳过滤行
	4 和 5: 只用外壳执行 ':sh' 命令
	如果不使用外壳，命令被直接执行。

	0 和 2: 使用 "shell 'shellcmdflag' cmd" 启动外部命令
	1 和 3: 使用 "shell cmd" 启动外部命令
	(译者注: 4 和 5 应该也_分别_包含在上面两种情况里)


+-*/+-*/shellxquote o 类似于 'shellquote'，但包括重定向
						*'shellxquote'* *'sxq'*
'shellxquote' 'sxq'	字符串	(缺省: ""；
				Win32 如果 'shell' 没有包含 "sh" 的话: "\""
				Unix 如果使用 system() 的话: "\"")
			全局
			{Vi 无此功能}
	(一或多个) 引用字符，用来包围 "!" 和 ":"!" 命令里传递给外壳的命令。
	重定向包含在引用之内。要把重定向排除在外，见 'shellquote'。可能没有必
	要同时设置两个选项。
	缺省是一个空字符串。已知只有对 MS-DOS 系列的系统上的第三方外壳有用，比
	如 MKS Korn Shell 或 bash，那里本选项应是 "\""。缺省值会根据 'shell'
	的值调整，以减少用户自行设置该选项的需要。见 |dos-shell|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/silent c 安静地运行命令
						*:sil* *:silent*
:sil[ent][!] {command}	安静地执行命令 {command}。不显示正常的消息，也不会把它
			加进消息历史。
			如果有 [!]，同时跳过错误消息，检测到错误时，命令和映射
			也也不会被终止。但还是会相应设置 |v:errmsg|。
			如果没有 [!]，错误信息会使得其后的所有消息都被正常显
			示。
			|:redir| 开始的重定向会继续工作，但可能有些细微差异。
			命令输出仍然重定向，但屏幕上看不到。例如: >
			    :redir >/tmp/foobar
			    :silent g/Aap/p
			    :redir END
<			要安静地执行普通模式命令，用 |:normal| 命令。例如，要
			搜索字符串且不给出任何消息: >
			    :silent exe "normal /path\<CR>"
<			":silent!" 可以用来执行命令，不管该命令是否失败都继续
			执行。
			例如: >
			    :let v:errmsg = ""
			    :silent! /^begin
			    :if v:errmsg != ""
			    : ... 模式没找到
<			":silent" 还可以避免敲入回车 (hit-enter) 的提示。执行
			外部命令时，这可能会使屏幕显示混乱。这时，用 |CTRL-L|
			可以清理。
			":silent menu ..." 定义一个不会回显命令行命令的菜单。
			但该命令仍然产生消息。如果连这也不要，在命令本身前用
			":silent": ":silent menu .... :silent command"。

+-*/+-*/stop c 暂停编辑器并退回外壳
:sus[pend][!]	或			*:sus* *:suspend* *:st* *:stop*
:st[op][!]		暂停 Vim。
			如果没有给出 '!' 并且置位 'autowrite'，那么每个修改过
			且有文件名的缓冲区都被写回。如果给出 '!' 或
			'autowrite' 没有置位，修改过的缓冲区不会写回。
			迟些时候，不要忘记把 Vim 带回前台！

+-*/+-*/suspend c 等同于 "":stop
:sus[pend][!]	或			*:sus* *:suspend* *:st* *:stop*
:st[op][!]		暂停 Vim。
			如果没有给出 '!' 并且置位 'autowrite'，那么每个修改过
			且有文件名的缓冲区都被写回。如果给出 '!' 或
			'autowrite' 没有置位，修改过的缓冲区不会写回。
			迟些时候，不要忘记把 Vim 带回前台！

+-*/+-*/system f 取得一个 shell 命令的结果
system({expr} [, {input}])				*system()* *E677*
		得到外壳命令 {expr} 的输出结果。
		如果给出 {input}，该字符串被写到文件里，并传给外壳命令作为标准
		输入。字符串照原样写入，你需要自己注意使用合适的换行符。不使用
		管道。
		注意: |shellescape()| 可以转义命令参数里的特殊字符。{expr} 里
		的换行可能会使命令失败。'shellquote' 和 'shellxquote' 里的字符
		也可能会引起麻烦。
		这不是用来执行交互命令的。
		返回字符串。示例: >
		    :let files = system("ls " .  shellescape(expand('%:h')))

<		要使结果更独立于所用的系统，外壳输出的结果被过滤，Macintosh 的
		<CR> 被换成 <NL>，而 DOS 系列的系统上 <CR><NL> 也被换成 <NL>。
		使用若干选项，以下面的方法构造要执行的命令:
	'shell' 'shellcmdflag' 'shellxquote' {expr} 'shellredir' {tmp} 'shellxquote'
		({tmp} 是自动生成的一个文件名)。
		Unix 和 OS/2 上，{expr} 用大括号包围，以便支持连接的多条命令。

		以加工 ("cooked") 模式执行命令，这样 CTRL-C 可以用来中止命令
		(至少在 Unix 上是如此)。

		返回的错误代码可以在 |v:shell_error| 里找到。
		该函数不能运行于 |restricted-mode|。

		注意 上面提到的选项值如有错误，该函数就会失败。使用若干安全代
		理应用时也有报告说它会失败。
		不同于 ":!cmd"，没有自动对改变过的文件的检查。使用
		|:checktime| 来强制这种检查。



+-*/+-*/term o 终端名
						*'term'* *E529* *E530* *E531*
'term'			字符串	(缺省为 $TERM，如果失败:
				             GUI: "builtin_gui"
					   Amiga: "amiga"
					    BeOS: "beos-ansi"
					     Mac: "mac-ansi"
					    MiNT: "vt52"
				          MS-DOS: "pcterm"
					    OS/2: "os2ansi"
					    Unix: "ansi"
					     VMS: "ansi"
				          Win 32: "win32")
			全局
	终端的名字。用于选择终端控制字符。环境变量被扩展 |:set_env|。
	例如: >
		:set term=$TERM
<	见 |termcap|。


+-*/+-*/ttybuiltin o 在外部 termcap 之前先用内建的 termcap
			     *'ttybuiltin'* *'tbi'* *'nottybuiltin'* *'notbi'*
'ttybuiltin' 'tbi'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	如果打开，内建的 termcap 在外部的之前搜索。
	如果关闭，内建的 termcap 在外部的之后搜索。
	如果本选项被改变，你需要接着设置 'term' 选项，使之能够生效。例如: >
		:set notbi term=$TERM
<	另见 |termcap|。
	原理: 此选项的缺省值为 "打开"，因为内建的 termcap 项目通常更好 (许多系
	统的 xterm 项目都有问题...)。


+-*/+-*/ttyfast o 指示一个快速的终端连接
				     *'ttyfast'* *'tf'* *'nottyfast'* *'notf'*
'ttyfast' 'tf'		布尔型	(缺省关闭，如果 'term' 为 xterm、hpterm、
					sun-cmd、screen、rxvt、dtterm 或
					iris-ansi 则打开；在 DOS 控制台上运行
					Vim 时也打开)
			全局
			{Vi 无此功能}
	表明使用的是快速终端连接。重画时可以发送给屏幕多个字符，而不使用插入/
	删除行命令。有多个窗口和终端不支持滚动区域时，会提高重画的平滑度。同时
	打开需要回绕行的屏幕行的行尾的额外的字符写入。这有助于在 xterm 和其它
	终端上使用鼠标来进行复制/粘贴。


+-*/+-*/ttymouse o 鼠标产生代码的类型
						*'ttymouse'* *'ttym'*
'ttymouse' 'ttym'	字符串	(缺省取决于 'term')
			全局
			{Vi 无此功能}
			{仅适用于 Unix 和 VMS，不适用于 GUI；只有在编译时加入
			|+mouse| 才有效}
	鼠标代码能够识别的终端类型名。目前有以下合法的字符串:
							*xterm-mouse*
	   xterm	xterm 方式的鼠标处理。鼠标产生 "<Esc>[Mscr"，其中
			"scr" 是三个字节:
				"s"  = 按钮状态
				"c"  = 列号加 33
				"r"  = 行号加 33
			只有不超过 223 列才能工作！一个解决方法可见 "dec"。
	   xterm2	和 "xterm" 类似，但 xterm 报告鼠标拖动时的鼠标位置。这
			样更快也更准确。你的 xterm 必须在补丁号 88 / XFree
			3.3.3 或以上才可以。稍后，说明 Vim 的自动识别机制。
							*netterm-mouse*
	   netterm	NetTerm 鼠标处理。鼠标产生 "<Esc>}r,c<CR>"，其中
			"r,c" 是两个代表行和列的十进制数。
							*dec-mouse*
	   dec		DEC 终端处理。鼠标产生相当复杂的序列，以 "<Esc>[" 开
			始。
			也可用于 Xterm，如果它在 configure 时带上参数
			"--enable-dec-locator"。
							*jsbterm-mouse*
	   jsbterm	JSB 终端鼠标处理。
							*pterm-mouse*
	   pterm	QNX 终端鼠标处理。

	鼠标处理的支持必须在编译时打开 |+mouse_xterm| |+mouse_dec|
	|+mouse_netterm|。
	只有 "xterm"(2) 是总能识别的。如果编译时打开，总能识别 NetTerm 鼠标代
	码。DEC 终端的鼠标代码在编译时打开且 'ttymouse' 不为 "xterm" 时能识别
	(这是因为 xterm 和 dec 的鼠标代码有冲突)。
	如果 'term' 选项设为以 "xterm" 开始的名字并且 'ttymouse' 不已经是
	"xterm" 或者 "xterm2" 的话，本选项自动设为 "xterm"。提供本选项的主要目
	的是在终端名不以 "xterm" 开始但它能处理 xterm 鼠标代码时把本选项设为
	"xterm"。
	如果报告的 xterm 版本是 95 或更高，本值设为 "xterm2"。只有在编译时加入
	|+termresponse| 特性并且 |t_RV| 设为请求 xterm 版本号的转义序列以后，
	才会如此。否则，必须显式地设置 "xterm2"。如果你不想 'ttymouse' 被自动
	设为 "xterm2"，把 t_RV 置为空字符串: >
		:set t_RV=
<

+-*/+-*/ttyscroll o 滚动的最大行数
						*'ttyscroll'* *'tsl'*
'ttyscroll' 'tsl'	数值型	(缺省为 999)
			全局
	屏幕滚动的最大行数。如果有更多行需要滚动，重画窗口。对于滚动很慢但刷新
	不慢的终端，它应该设为较小的值，比如 3，以加快显示速度。


+-*/+-*/ttytype o 'term' 的别名
						*'ttytype'* *'tty'*
'ttytype' 'tty'		字符串	(缺省取决于 $TERM)
			全局
	'term' 的别名，见上。


+-*/+-*/warn o 当缓冲区改变时，对 shell 命令给出警告
						*'warn'* *'nowarn'*
'warn'			布尔型	(缺省打开)
			全局
	在已修改的缓冲区上使用外壳命令会给出警告信息。


+-*/+-*/weirdinvert o 用于有特殊反转方法的终端
		     *'weirdinvert'* *'wiv'* *'noweirdinvert'* *'nowiv'*
'weirdinvert' 'wiv'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	本选项和 't_xs' 终端选项的效果相同。
	为了和 4.x 版本后向兼容而提供本选项。
	置位 'weirdinvert' 的效果是使得 't_xs' 非空，反之亦然。如果运行 GUI，
	就没有任何效果。


+-*/syn _ 高亮
+-*/+-*/background o ""dark"" 或 ""light""，用于色彩的高亮
							*'background'* *'bg'*
'background' 'bg'	字符串	(缺省为 "dark" 或 "light")
			全局
			{Vi 无此功能}
	设为 "dark" 时，Vim 试图使用深色背景上看起来舒服的颜色。如果设为
	"light"，Vim 会试图使用在浅色背景上看起来舒服的颜色。其它的值都是非法
	的。Vim 试图根据你使用的终端确定其缺省值，但不见得总做的对。
	设置该选项不改变背景色，它告诉 Vim 背景颜色应该看起来怎么样。要改变背
	景色，见 |:hi-normal|。

	如果设置 'background'，Vim 会根据新值调整缺省的颜色组。但语法高亮使用
	的颜色不会改变。			*g:colors_name*
	已经载入色彩方案时 ("g:colors_name" 变量已设置)，设置 'background' 会
	重新载入色彩方案。如果色彩方案根据 'background' 调整，这不错。但如果颜
	色方案自己设置 'background'，实际效果可能就被撤销了。如果需要的话，先删
	除 "g:colors_name" 变量。

	如果这样复原 'background' 为其缺省值: >
		:set background&
<	Vim 会猜测其值。GUI 里应该没有问题，其它情况下 Vim 可能不一定能猜对。

	启动 GUI 时，'background' 的缺省值是 "light"。如果 .gvimrc 里没有设置
	该值，而 Vim 检测到背景实际上很深，'background' 会设为 "dark"。但这在
	.gvimrc 读入_之后_才发生 (因为窗口需要被打开才能发现实际的背景色)。要
	避免这一点，在 .gvimrc 里放上 ":gui" 命令以强迫打开 GUI 窗口。它应在使
	用 'background' 的值的命令之前 (比如，在 ":syntax on" 之前)。通常，该
	选项应在 .vimrc 文件里设置。可能和终端的名字有关。比如: >
		:if &term == "pcterm"
		:  set background=dark
		:endif
<	如果设置该选项，高亮组的缺省设置会发生改变。要进行其它设置，在设置
	'background' 选项_之后_才使用 ":highlight" 命令。
	该选项也在 "$VIMRUNTIME/syntax/syntax.vim" 文件里使用，用来选择语法高
	亮的颜色。在改变此选项后，你必须再次载入 syntax.vim 才能看到效果。这可
	以通过 ":syntax on" 完成。


+-*/+-*/clearmatches f 清除 |matchadd()| 和 |:match| 诸命令定义的所有
clearmatches()						*clearmatches()*
		清除之前 |matchadd()| 和 |:match| 命令定义的匹配。

							*col()*
+-*/+-*/colorcolumn o 高亮指定列
						*'colorcolumn'* *'cc'*
'colorcolumn' 'cc'	字符串	(缺省为 "")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	'colorcolumn' 是逗号分隔的屏幕列的列表，这些列会用 ColorColumn
	|hl-ColorColumn| 高亮。可用于对齐文本。会使屏幕刷新变慢。
	屏幕列可以是绝对值，也可以是 '+' 或 '-' 开头的数值，会从 'textwidth'
	加减该值。 >

		:set cc=+1  " 高亮 'textwidth' 之后的列
		:set cc=+1,+2,+3  " 高亮 'textwidth' 之后的三列
		:hi ColorColumn ctermbg=lightgrey guibg=lightgrey
<
	'textwidth' 为零时不使用带 '-' 和 '+' 的项目。
	最多高亮 256 列。


+-*/+-*/colorscheme c 载入特定的色彩方案
						*:colo* *:colorscheme* *E185*
:colo[rscheme]		输出当前激活的色彩方案名。基本上等同 >
				:echo g:colors_name
<			如果 g:colors_name 没有定义 :colo 会输出 "default"。如
			果编译时没有带 |+eval| 特性，输出 "unknown"。

+-*/+-*/concealcursor o 是否隐藏光标所在行的可隐藏文本
						*'concealcursor'* *'cocu'*
'concealcursor' 'cocu'	字符串 (缺省: "")
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+conceal| 特性才有效}
	设置也能隐藏光标所在行的文本的模式。
	如果当前模式在此处列出，光标行的隐藏行为和其它行一样。
	  n		普通模式
	  v		可视模式
	  i		插入模式
	  c		命令行编辑模式，用于 'incsearch'

	'v' 适用于可视区域的所有行，不局限于光标所在行。
	一个有用的值为 "nc"。可用于帮助文件。如果你只来回移动，文本会保持隐藏。
	但一旦你开始插入文本或选择一个可视区域，隐藏文本被显示，以便你看清你在
	干什么。
	记住光标位置并不总是它所显示的位置，例如，上下移动时，所在列可能改变。



+-*/+-*/conceallevel o 是否显示可隐藏文本
					*'conceallevel'* *'cole'*
'conceallevel' 'cole'	数值型 (缺省为 0)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+conceal| 特性才有效}
	指定如何显示使用 "conceal" 语法属性 |:syn-conceal| 的文本:

	值		效果 ~
	0		正常显示文本
	1		每处隐藏文本块被一个字符替代。如果语法项目没有定义定制
			的替代字符 (见 |:syn-cchar|)，使用 'listchars' 定义的
			字符 (缺省是空格)，
			使用 "Conceal" 高亮组高亮。
	2		完全不显示隐藏文本，除非它定义了自己的替换字符 (见
			|:syn-cchar|)。
	3		完全不显示隐藏文本。

	注意: 光标所在行的隐藏文本总是会被显示，以便你编辑和复制文本。但可用
	'concealcursor' 选项改变此行为。


+-*/+-*/cursorcolumn o 高亮光标所在屏幕列
			*'cursorcolumn'* *'cuc'* *'nocursorcolumn'* *'nocuc'*
'cursorcolumn' 'cuc'	布尔型 (缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	用 CursorColumn |hl-CursorColumn| 高亮光标所在的屏幕列。用于对齐文本。
	屏幕刷新会变慢。
	如果你只想为当前窗口高亮，可以使用这些自动命令: >
		au WinLeave * set nocursorline nocursorcolumn
		au WinEnter * set cursorline cursorcolumn
<


+-*/+-*/cursorline o 高亮光标所在屏幕行
			*'cursorline'* *'cul'* *'nocursorline'* *'nocul'*
'cursorline' 'cul'	布尔型 (缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	用 CursorLine |hl-CursorLine| 高亮光标所在的屏幕行。用于方便定位光标。
	屏幕刷新会变慢。
	激活可视模式时，为了容易看到选择的文本，不使用此高亮。



+-*/+-*/diff_hlID f 得到 diff 模式某个位置的高亮标示
diff_hlID({lnum}, {col})				*diff_hlID()*
		返回 diff 模式行 {lnum} 和列 {col} (字节位置) 所在的高亮 ID。
		如果当前行没有差异，返回零。
		{lnum} 的用法类似于 |getline()|。所以 "." 是当前行，"'m" 是位
		置标记 m，等等。
		最左列的 {col} 为 1，第一行的 {lnum} 为 1。
		高亮 ID 可以用于 |synIDattr()|，以得到高亮对应的语法信息。


+-*/+-*/getmatches f 得到 |matchadd()| 和 |:match| 诸命令定义的所有
getmatches()						*getmatches()*
		返回之前 |matchadd()| 和 |:match| 命令定义的所有匹配组成的列表
		|List|。 |getmatches()| 常和 |setmatches()| 组合使用，因为
		|setmatches()| 可以恢复 |getmatches()| 保存的匹配列表。
		示例: >
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:let m = getmatches()
			:call clearmatches()
			:echo getmatches()
<			[] >
			:call setmatches(m)
			:echo getmatches()
<			[{'group': 'MyGroup1', 'pattern': 'TODO',
			'priority': 10, 'id': 1}, {'group': 'MyGroup2',
			'pattern': 'FIXME', 'priority': 10, 'id': 2}] >
			:unlet m
<


+-*/+-*/highlight c 指定高亮方法
:hi[ghlight] {group-name}
			列出一个高亮组。
:hi[ghlight] clear	复位高亮设置为缺省值。删除所有用户增加的组的高亮属性。
			用当前的 'background' 的值来决定所使用的缺省颜色。
:hi[ghlight] clear {group-name}
:hi[ghlight] {group-name} NONE
			屏蔽一个高亮组的所有高亮设置。并_不_复原缺省的颜色。
:hi[ghlight] [default] {group-name} {key}={arg} ..
			增加高亮组，或者更改已有的组高亮设置。
term={attr-list}    start={term-list}	stop={term-list}	
cterm={attr-list}   ctermfg={color-nr}  ctermbg={color-nr}	 
gui={attr-list}		font={font-name}	guifg={color-name}	guibg={color-name}	guisp={color-name}	

有一些缺省的高亮组。'highlight' 选项缺省使用这些组。注意 高亮取决于
'background' 的值。你可以用 ":highlight" 命令看到当前的设置。
ColorColumn	用于 'colorcolumn' 设置的列
Conceal		代替隐藏文本的填充字符 (见 'conceallevel')
Cursor		光标所在的字符
CursorIM	类似于 Cursor，但用于 IME 模式 |CursorIM|
CursorColumn	置位 'cursorcolumn' 时，光标所在的屏幕列
CursorLine	置位 'cursorline' 时，光标所在的屏幕行
Directory	目录名 (还有列表里的其它特殊名字)
DiffAdd		diff 模式: 增加的行 |diff.txt|
DiffChange	diff 模式: 改变的行 |diff.txt|
DiffDelete	diff 模式: 删除的行 |diff.txt|
DiffText	diff 模式: 改变行里的改动文本 |diff.txt|
ErrorMsg	命令行上的错误信息
VertSplit	分离垂直分割窗口的列
Folded		用于关闭的折叠的行
FoldColumn	'foldcolumn'
SignColumn	显示 |signs| 的列
IncSearch	'incsearch' 高亮；也用于被 ":s///c" 替换的文本
LineNr		":number" 和 ":#" 命令与置位 'number' 或 'relativenumber' 选项
		时的行号，
MatchParen	如果光标所在或刚刚在它之前的字符是配对的括号一部分的话，它和它
		的配对。|pi_paren.txt|
ModeMsg		'showmode' 消息 (例如，"-- INSERT --")
MoreMsg		|more-prompt|
NonText		窗口尾部的 '~' 和 '@'，'showbreak' 的字符和其它在文本里实际不
		存在的字符 (例如，代替行尾放不下的双宽字符而显示的 ">")。
Normal		普通文本
Pmenu		弹出菜单: 普通项目。
PmenuSel	弹出菜单: 选中项目。
PmenuSbar	弹出菜单: 滚动条。
PmenuThumb	弹出菜单: 滚动条的拇指 (thumb)。
Question	|hit-enter| 提示和 yes/no 问题
Search		最近搜索模式的高亮 (见 'hlsearch')。也用于 quickfix 当前行的
		高亮和其它类似的要突出显示的项目。
SpecialKey	":map" 列出的 Meta 和特殊键，也包括文本里不可显示字符的显示和
		'listchars'。
		一般的: 和实际内容显示上有差异的文本。
SpellBad	拼写检查器不能识别的单词。|spell|
		它会和本来应该使用的高亮进行组合。
SpellCap	应该大写字母开头的单词。|spell|
		它会和本来应该使用的高亮进行组合。
SpellLocal	拼写检查器能识别但只在其它区域使用的单词。|spell|
		它会和本来应该使用的高亮进行组合。
SpellRare	拼写检查器能识别但很少使用的单词。|spell|
		它会和本来应该使用的高亮进行组合。
StatusLine	当前窗口的状态行
StatusLineNC	非当前窗口的状态行
		注意: 如果等于 "StatusLine"，Vim 会使用 "^^^" 指示当前窗口的状
		态行。
TabLine		标签页行，非活动标签页标签
TabLineFill	标签页行，没有标签的地方
TabLineSel	标签页行，活动标签页标签
Title		":set all"、":autocmd" 等输出的标题
Visual		可视模式的选择区
VisualNOS	Vim 是 "选择区的非拥有者" 时，可视模式的选择区。只有 X11 GUI
		的 |gui-x11| 和 |xterm-clipboard| 才提供此支持。
WarningMsg	警告消息
WildMenu	'wildmenu' 补全的当前匹配
+-*/+-*/highlight o 设置若干场合下的高亮模式
						*'highlight'* *'hl'*
'highlight' 'hl'	字符串	(缺省为 (单个字符串):
				     "8:SpecialKey,@:NonText,d:Directory,
				     e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,
				     M:ModeMsg,n:LineNr,r:Question,
				     s:StatusLine,S:StatusLineNC,c:VertSplit,
				     t:Title,v:Visual,w:WarningMsg,W:WildMenu,
				     f:Folded,F:FoldColumn,A:DiffAdd,
				     C:DiffChange,D:DiffDelete,T:DiffText,
				     >:SignColumn,B:SpellBad,P:SpellCap,
				     R:SpellRare,L:SpellLocal,-:Conceal,
				     +:Pmenu,=:PmenuSel,
				     x:PmenuSbar,X:PmenuThumb")
			全局
			{Vi 无此功能}
	本选项可以用来为若干场合设置高亮模式。它是逗号分隔的字符对的列表。每对
	字符中，第一个字符给出适用的场合，第二个字符设定该场合使用的模式。这些
	场合是:
	|hl-SpecialKey|	 8  ":map" 列出的 Meta 和特殊键
	|hl-NonText|	 @  窗口末尾的 '~' 和 '@' 和 'showbreak' 里的字符
	|hl-Directory|	 d  CTRL-D 列出的目录和列表里其它特殊的东西
	|hl-ErrorMsg|	 e  错误信息
			 h  (已废弃，可以忽略)
	|hl-IncSearch|	 i  'incsearch' 高亮
	|hl-Search|	 l  最近搜索模式高亮 (见 'hlsearch')
	|hl-MoreMsg|	 m  |more-prompt|
	|hl-ModeMsg|	 M  模式 (例如，"-- INSERT --")
	|hl-LineNr|	 n  ":number" 和 ":#" 命令的行号，也用于 'number' 和
			    'relativenumber' 选项置位时的行号。
	|hl-Question|	 r  |hit-enter| 提示和 yes/no 问题
	|hl-StatusLine|	 s  当前窗口的状态行 |status-line|
	|hl-StatusLineNC| S  非当前窗口的状态行
	|hl-Title|	 t  ":set all"、":autocmd" 等输出的标题。
	|hl-VertSplit|	 c  用来分隔垂直分割窗口的列
	|hl-Visual|	 v  可视模式
	|hl-VisualNOS|	 V  Vim 不是 "选择区拥有者" 时的可视模式。只限于 X11
			    GUI 的 |gui-x11| 和 |xterm-clipboard|。
	|hl-WarningMsg|	 w  警告消息
	|hl-WildMenu|	 W  'wildmenu' 显示的通配符匹配
	|hl-Folded|	 f  关闭的折叠所用的行
	|hl-FoldColumn|	 F  'foldcolumn'
	|hl-DiffAdd|	 A  diff 模式增加的行
	|hl-DiffChange|	 C  diff 模式改变的行
	|hl-DiffDelete|	 D  diff 模式删除的行
	|hl-DiffText|	 T  diff 模式插入的文本
	|hl-SignColumn|	 >  |signs| 所用的列
	|hl-SpellBad|	 B  拼写错误的单词 |spell|
	|hl-SpellCap|	 P  应该大写开头的单词 |spell|
	|hl-SpellRare|	 R  偏僻词 |spell|
	|hl-SpellLocal|	 L  来自其它区域的单词 |spell|
	|hl-Conceal|	 -  用于隐藏字符的填充字符 (见 'conceallevel')
	|hl-Pmenu|       +  弹出菜单正常行
	|hl-PmenuSel|    =  弹出菜单选中行
	|hl-PmenuSbar|   x  弹出菜单滚动条
	|hl-PmenuThumb|  X  弹出菜单滚动条拇指 (thumb)

	显示模式是:
		r	反转		(termcap 项目 "mr" 和 "me")
		i	斜体		(termcap 项目 "ZH" 和 "ZR")
		b	粗体		(termcap 项目 "md" 和 "me")
		s	突出		(termcap 项目 "so" 和 "se")
		u	下划线		(termcap 项目 "us" 和 "ue")
		c	下曲线		(termcap 项目 "Cs" 和 "Ce")
		n	没有高亮
		-	没有高亮
		:	使用高亮组
	没有包含在内的场合使用缺省值。
	如果你想改变显示模式时所做的事，见 |dos-colors| 里的例子。
	如果使用 ':' 显示模式，后面必须跟一个高亮组的名字。高亮组可以用来定义
	任何高亮的类型，包括使用颜色。|:highlight| 说明如何定义之。缺省为每个
	场合定义一个不同的高亮组。
	|highlight-default| 说明缺省的高亮组。


+-*/+-*/hlID f 取得高亮组标示
hlID({name})	返回数值，即名为 {name} 的高亮组的 ID。如果该高亮组不存在，返
		回零。
		可用于提取高亮组的信息。比如，要得到 "Comment" 组的背景颜色: >
	:echo synIDattr(synIDtrans(hlID("Comment")), "bg")
<							*highlightID()*
		已废弃的名字: highlightID()。


+-*/+-*/hlexists f 检查高亮组是否存在
hlexists({name})					*hlexists()*
		返回数值。只要名为 {name} 的高亮组用某种方法定义过，返回非零。
		不一定要为该组定义过高亮属性。一些语法项目可能已经使用该组。
							*highlight_exists()*
		已废弃的名字: highlight_exists()。

							*hlID()*
+-*/+-*/match c 定义要高亮显示的匹配的模式
							*:mat* *:match*
:mat[ch] {group} /{pattern}/
		定义一个在当前窗口高亮显示的模式。它会以 {group} 高亮。例: >
			:highlight MyGroup ctermbg=green guibg=green
			:match MyGroup /TODO/
<		除了 // 以外，任何字符都可以用来标识一个 {pattern} 的开始和结
		束。要当心某些特殊的字符，例如 '"' 和 '|'。

+-*/+-*/matchadd f 定义要高亮的模式 (一个 ""匹配"")
matchadd({group}, {pattern}[, {priority}[, {id}]])
		定义模式 (一个 "匹配")， 在当前窗口用高亮组 {group} 高亮。返回
		标识号 (ID)，|matchdelete()| 可用该 ID 来删除匹配。

		可选的 {priority} 参数指定匹配的优先级。高优先级的匹配的高亮会
		否决低优先级匹配的高亮。优先级用整数指定 (负整数也无不可)。如
		果未指定 {priority} 参数，缺省优先级为 10。'hlsearch' 的优先级
		为零，这样所有正优先级的匹配都可以否决它。语法高亮 (见
		'syntax') 采用不同的机制，无论选择的优先级如何，匹配总会否决语
		法的高亮。

		可选的 {id} 参数请求特定的匹配 ID。如果指定的 ID 已用，报错，
		并不加入该匹配。ID 用正整数指定 (不含零)。ID 1、2 和 3 分别为
		|:match|、|:2match| 和 |:3match| 命令保留。如果 {id} 未指定，
		|matchadd()| 自动选择一个可用的 ID。

		匹配的数目不限，|:match| 诸命令则有此局限。

		示例: >
			:highlight MyGroup ctermbg=green guibg=green
			:let m = matchadd("MyGroup", "TODO")
<		要删除该模式: >
			:call matchdelete(m)

<		用 |getmatches()| 可以得到 |matchadd()| 和 |:match| 定义的匹配
		列表。|clearmatches()| 可一次删除所有的匹配。


+-*/+-*/matcharg f 得到 |:match| 参数的相关信息
matcharg({nr})							*matcharg()*
		选择 {nr} 号匹配的项目，它们分别用 |:match|、|:2match| 或
		|:3match| 命令设置。
		返回两个项目的 |List|:
			使用的高亮组名
			使用的模式。
		如果 {nr} 不是 1、2 或 3，返回空 |List|。
		如果没有匹配的项目，返回 ['', '']。
		这用来保存和恢复 |:match|。
		用 |:match| 命令高亮的匹配限于三个。|matchadd()| 无此限制。


+-*/+-*/matchdelete f 删除 |matchadd()| 或 |:match| 诸命令定义的匹配
matchdelete({id})			       *matchdelete()* *E802* *E803*
		删除之前用 |matchadd()| 或 |:match| 诸命令定义的 ID 为 {id} 的
		匹配。如果成功，返回 0，不然返回 -1。示例见 |matchadd()|。
		|clearmatches()| 可一次删除所有的匹配。


+-*/+-*/ownsyntax c 为本窗口设置新的局部语法高亮
16. 窗口局部语法				*:ownsyntax*

+-*/+-*/redrawtime o 'hlsearch' 和 |:match| 高亮的超时
						*'redrawtime'* *'rdt'*
'redrawtime' 'rdt'	数值型	(缺省为 2000)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+reltime| 特性才有效}
	重画屏幕以毫秒计的时间。应用于 'hlsearch' 和 |:match| 高亮的模式搜索。
	如果重画需时超过这么多的毫秒数，不再继续高亮匹配。用于避免 Vim 在使用
	非常复杂的模式时挂起。


+-*/+-*/setmatches f 恢复 |getmatches()| 保存的匹配列表
setmatches({list})					*setmatches()*
		恢复 |getmatches()| 保存的匹配列表。如果成功，返回 0，否则返回
		-1。原有的所有匹配都被清除。示例见 |getmatches()|。

							*setpos()*
+-*/+-*/synID f 取得某位置的语法标示
synID({lnum}, {col}, {trans})				*synID()*
		返回数值，即当前窗口 {lnum} 行 {col} 列所在的语法 ID。
		语法 ID  可以用在 |synIDattr()| 和 |synIDtrans()|，以得到文本
		的语法信息。
		最左列的 {col} 为 1。第一行的 {lnum} 为 1。适用 'synmaxcol' 的
		值，如果行比它更长，就返回零。
		如果 {trans} 非零，透明的项目被简约为它们实际显露的项目。这可
		以用于你想知道实际使用的颜色的情形。如果 {trans} 为零，返回透
		明的项目本身。这可用于想知道实际有效的语法项目的情形 (比如，在
		括号内部)。
		警告: 本函数可能很慢。最佳速度可以通过正向遍历文件获得。

		例如 (回显光标所在的语法项目的名字): >
			:echo synIDattr(synID(line("."), col("."), 1), "name")
<


+-*/+-*/synIDattr f 取得某语法标示的特定属性
synIDattr({synID}, {what} [, {mode}])			*synIDattr()*
		返回字符串，syntax ID {synID} 的 {what} 属性。可用于得到语法项
		目的相关信息。
		{mode} 可以是 "gui"、"cterm" 或 "term"，从而得到的是该模式下的
		属性。如果忽略 {mode} 或者指定了非法的值，使用当前激活的高亮方
		式的属性 (GUI、cterm 或 term)。
		使用 synIDtrans() 来跟随链接的高亮组。
		{what}		结果 ~
		"name"		语法项目的名字
		"fg"		前景色 (GUI: 用于设置颜色的色彩名，cterm: 色彩
				号，以字符串形式出现，term: 空字符串)
		"bg"		背景色 (细节同 "fg")
		"font"		字体名 (只适用于 GUI) |highlight-font|
		"sp"		特殊颜色 (细节同 "fg") |highlight-guisp|
		"fg#"		类似于 "fg"，但只适用于 GUI，而且 GUI 使用的名
				字形如 "#RRGGBB"。
		"bg#"		"bg"，细节同 "fg#"
		"sp#"		"sp"，细节同 "fg#"
		"bold"		"1" 如果粗体
		"italic"	"1" 如果斜体
		"reverse"	"1" 如果反显
		"inverse"	"1" 如果反显 (= reverse)
		"standout"	"1" 如果突出
		"underline"	"1" 如果下划线
		"undercurl"	"1" 如果下曲线

		示例 (回显光标所在的语法项目的颜色): >
	:echo synIDattr(synIDtrans(synID(line("."), col("."), 1)), "fg")
<

+-*/+-*/synIDtrans f 取得翻译后的语法标示
synIDtrans({synID})					*synIDtrans()*
		返回数值，即 {synID} 经过翻译的语法 ID。这是用于高亮字符的语法
		组的 ID。":highlight link" 给出的高亮组被跟随，以找到实际使用
		的组。


+-*/+-*/synmaxcol o 寻找语法项目的最大列数
						*'synmaxcol'* *'smc'*
'synmaxcol' 'smc'	数值型	(缺省为 3000)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	搜索语法项目的最大列数。长行里超过此列数的文本不再高亮，后续行也不一定
	能正确高亮。因为语法状态被清除。
	有助于避免单个长行的 XML 文件的重画非常缓慢的问题。
	设为零取消此限制。


+-*/+-*/syntax c 语法高亮
定 义 关 键 字						*:syn-keyword*
:sy[ntax] keyword {group-name} [{options}] {keyword} .. [{options}]
定 义 匹 配						*:syn-match*
:sy[ntax] match {group-name} [{options}] [excludenl] {pattern} [{options}]
定 义 区 域 		*:syn-region* *:syn-start* *:syn-skip* *:syn-end*
:sy[ntax] region {group-name} [{options}]
		[matchgroup={group-name}]
		[keepend]
		[extend]
		[excludenl]
		start={start_pattern} ..
		[skip={skip_pattern}]
		end={end_pattern} ..
		[{options}]

:sy[ntax] case [match | ignore]
	要求其后的 ":syntax" 命令在本设定为 "match" 时必须匹配大小写，本设定为
	"ignore" 时则可以忽略大小写。注意，它不影响之前的项目，而只影响其后直
	到下一个 ":syntax case" 命令为止的所有项目。

+-*/+-*/syntax o 读入当前缓冲区的语法
						*'syntax'* *'syn'*
'syntax' 'syn'		字符串	(缺省为空)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	如果设置此选项，载入该名字对应的语法，除了 ":syntax off" 用来关闭语法
	高亮以外。
	否则，此选项并不总是反映当前的语法 (b:current_syntax 变量才是)。
	对于不能自动识别语法的文件而言，在模式行里设置此选项是最有用的。比如对
	于 IDL 文件:
		/* vim: set syntax=idl : */ ~
	如果选项值里有句号，它分隔两个文件类型名字。例如:
		/* vim: set syntax=c.doxygen : */ ~
	先使用 "c" 语法，再使用 "doxygen" 语法。注意 第二个语法须准备好作为附
	加部分被载入，否则它会被跳过。句号可以多于一个。
	要关闭当前文件的语法高亮，用: >
		:set syntax=OFF
<	要根据当前的 'filetype' 选项的值打开语法高亮: >
		:set syntax=ON
<	设置 'syntax' 选项的实际效果是激活以该值为参数的 Syntax 自动命令事件。
	不管 'cpoptions' 里是否包含 's' 或 'S' 标志位，本选项不会复制到别的缓
	冲区。
	只能使用普通的文件名字符。"/\*?[|<>" 都不合法。


+-*/+-*/spell _ 拼写
+-*/+-*/+-*/mkspell c 生成 .spl 拼写文件
							*:mksp* *:mkspell*
:mksp[ell][!] [-ascii] {outname} {inname} ...
			从单词列表生成 Vim 的拼写文件。例如: >
		:mkspell /tmp/nl nl_NL.words
<								*E751*
			如果 {outname} 以 ".spl" 结尾，它被用作文件名。否则，
			它指定诸如 "en" 这样的语言名，不带区域名。要写入的文件
			名是 "{outname}.{encoding}.spl"，其中 {encoding} 是
			'encoding' 选项的值。

+-*/+-*/+-*/mkspellmem o 在 |:mkspell| 压缩树前可用的内存
						*'mkspellmem'* *'msm'*
'mkspellmem' 'msm'	字符串	(缺省 "460000,2000,500")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	|:mkspell| 的参数。调节何时开始压缩单词树。如果单词很多，压缩可能很
	慢，但为了不耗尽内存，还是有必要的。每个单词需要的内存取决于单词间的相
	似程度，这就是为什么此调节非常复杂的原因。

	有三个数值，以逗号分隔:
		{start},{inc},{added}

	多数语言下，不压缩的单词树能放进内存。{start} 给出进行任何压缩前可以使
	用的千字节计的内存量。应该比 Vim 可用的内存量要稍小一些。

	超出 {start} 限制时，{inc} 参数指定千字节计在下一次压缩进行之前要分配
	的内存量。数值越小意味着在加入较少的单词后就要进行压缩，从而会变慢。数
	值越大意味着需要分配更多内存。

	压缩完成后，可以在忽略 {inc} 限制之前加入 {added} 乘以 1024 个单词，如
	果需要额外的内存，进行压缩。数值越小意味着到达 {inc} 限制的机率越小，
	使用更少的内存，但速度也更慢。

	这些数值有重要意义的语言包括意大利语和匈牙利语，缺省值在你有 512 兆字
	节的内存比较适合。如果你有 1G 字节，可以用: >
		:set mkspellmem=900000,3000,800
<	如果你的内存不足 512 兆字节，|:mkspell| 可能对某些语言会失败，不管
	'mkspellmem' 如何设置。


+-*/+-*/+-*/soundfold f 返回 ""发音相似"" 的单词等价形式
soundfold({word})
		返回 {word} 按发音折叠的等价形式。使用当前窗口的 'spelllang'
		中第一个支持按发音折叠的语言。 'spell' 必须置位。如果不能按发
		音折叠，按原样返回 {word}。
		可用来提供拼写建议。注意 此方法可能很慢。

							*spellbadword()*
+-*/+-*/+-*/spell o 打开拼写检查
						*'spell'* *'nospell'*
'spell'			布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	如果打开，进行拼写检查。见 |spell|。
	用 'spelllang' 指定使用的语言。


+-*/+-*/+-*/spellbadword f 定位光标所在或之后的错误拼写的单词
spellbadword([{sentence}])
		没有参数: 返回光标所在或之后的拼写错误的单词。光标移动到这个坏
		词的开始处。如果光标行上没有坏词，返回空字符串，不移动光标。

		有参数: 返回 {sentence} 里第一个拼写错误的单词。如果没有拼写错
		误，返回空字符串。

		返回值是两个项目的列表:
		- 错误拼写的单词，或空字符串。
		- 拼写错误的类型:
			"bad"		拼写错误
			"rare"		偏僻词
			"local"		只在其它区域里合法的单词
			"caps"		单词应该大写开头
		例如: >
			echo spellbadword("the quik brown fox")
<			['quik', 'bad'] ~

		使用当前窗口的拼写信息。'spell' 选项必须置位，也用到
		'spelllang' 的值。

							*spellsuggest()*
+-*/+-*/+-*/spellcapcheck o 定位句子尾部的模式
						*'spellcapcheck'* *'spc'*
'spellcapcheck' 'spc'	字符串	(缺省为 "[.?!]\_[\])'" \t]\+")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	定位句子结束位置的模式。检查匹配文本之后的下个单词是否以大写字母开头。
	如果不是，用 SpellCap 高亮 |hl-SpellCap| (除非该词同时包含拼写错误)。
	如果不希望有这项检查，置本选项为空。
	只有置位 'spell' 时才使用。
	小心特殊字符，|option-backslash| 说明如何包含空格和反斜杠。
	要根据语言自动设置此选项，见 |set-spc-auto|。


+-*/+-*/+-*/spelldump c 分割窗口并用正确的单词填充
							*:spelldump* *:spelld*
:spelld[ump]		打开新窗口，用当前所有的合法单词填充。不包含复合词。
			注意: 对某些语言结果可能很大，甚至会使 Vim 溢出内存。

+-*/+-*/+-*/spellfile o |zg| 和 |zw| 保存单词的文件
						*'spellfile'* *'spf'*
'spellfile' 'spf'	字符串	(缺省为空)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	单词列表文件名，此文件用于 |zg| 和 |zw| 命令加入单词。它必须以
	".{encoding}.add" 结尾。路径是必要的，否则该文件就放到当前目录。
								*E765*
	它也可以是逗号分隔的名字列表。|zg| 和 |zw| 命令前的计数用来指定需要的
	名字。这可用于，比方说，分别指定个人单词列表和项目单词列表文件。
	如果此选项在加入单词时为空，Vim 会为你进行如下设置: 使用第一个可写的
	'runtimepath' 目录；如果那里还没有 "spell" 目录，先建立之；然后使用
	'spelllang' 里的出现的第一个语言名作为文件名，忽略区域部分。
	生成的 ".spl" 文件将用于拼写检查，它不需要在 'spelllang' 里出现。
	通常所有区域使用同一个文件，如果你想加入区域名也可以。但要记住，只有
	'spellfile' 设置为该名字时才会使用区域名。使用 'spelllang' 项目的缺省
	方法只会寻找不带区域名的文件。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/+-*/spellgood c 增加拼写的好词
							*:spe* *:spellgood*
:[count]spe[llgood] {word}
			把 {word} 作为一个好词加入到 'spellfile'，类似 |zg|。
			如果没有计数，使用第一个名字项目，计数为 2 使用第二个
			项目，等等。

+-*/+-*/+-*/spellinfo c 显示载入的拼写文件的信息
							*:spellinfo* *:spelli*
:spelli[nfo]		显示当前缓冲区使用的拼写文件的信息。

+-*/+-*/+-*/spelllang o 拼写检查使用的语言
						*'spelllang'* *'spl'*
'spelllang' 'spl'	字符串	(缺省为 "en")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	逗号分隔的单词列表名字的列表。打开 'spell' 选项时，为这些语言进行拼写
	检查。例如: >
		set spelllang=en_us,nl,medical
<	意味着识别美国英语、荷兰语和医疗用语。高亮不能识别的单词。
	单词列表名不能包括逗号或句号。建议使用连字符来分隔两字母的语言名和规格
	说明。这样，"en-rare" 代表罕见的英语单词。
	区域名必须出现在名字的最后，它的形式是 "_xx"，其中 "xx" 是两字母小写的
	区域名。你可以使用多于一个区域，一一列出便可: "en_us,en_ca" 支持美国和
	加拿大英语，但不支持澳大利亚、新西兰或英国专有的单词。
							*E757*
	一个特例是可以直接给出一个 .spl 文件名。删除名字中第一个 "_xx" 部分，
	把删除部分用作区域名 (_xx 是下划线和两个字母，它后面要跟一个非字母)，
	主要为测试用。你必须确保使用正确的编码，Vim 不做此检查。
	设置 'encoding' 时，会重新载入单词列表。因而，最好在设置 'encoding' 之
	后设置 'spelllang'，避免重复载入文件。
	如何找到相关的拼写文件的解释可见: |spell-load|。

	如果激活 |spellfile.vim| 插件而你使用 'runtimepath' 里找不到 .spl 的语
	言名，该插件会询问你是否要下载此文件。

	成功设置此选项后，Vim 会执行 'runtimepath' 的 "spell/LANG.vim" 文件。
	其中 "LANG" 是 'spelllang' 第一个逗号、句号或下划线之前的值。
	另见 |set-spc-auto|。



+-*/+-*/+-*/spellrepall c | 那样，但替换所有的坏词
					*:spellr* *:spellrepall* *E752* *E753*
:spellr[epall]		在当前窗口重复 |z=| 进行的替换，即把所有的匹配用替换过
			的那个单词替换。

+-*/+-*/+-*/spellsuggest f 返回建议的拼写校正列表
spellsuggest({word} [, {max} [, {capital}]])
		返回 |List|，包含替代 {word} 的拼写建议。
		如果给出 {max}，返回的建议不超过此数目。否则，返回不超过 25 个
		建议。

		如果给出 {capital} 参数且非零，只给出大写开头的拼写建议。
		'spellcapcheck' 匹配后再使用此功能。

		{word} 可以是后跟其它文本的错误拼写单词。这样可以对两个被分开
		的单词进行连接。建议里也包含附加文本，以便你替换整行。

		{word} 也可以是个好词。返回和它类似的单词。建议里不包含 {word}
		自身，但可能会出现其大写开头的形式。

		使用当前窗口的拼写信息。'spell' 选项必须置位，也用到
		'spelllang' 和 'spellsuggest' 的值。



+-*/+-*/+-*/spellsuggest o 提供拼写校正建议的方法
						*'spellsuggest'* *'sps'*
'spellsuggest' 'sps'	字符串	(缺省为 "best")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+syntax| 特性才有效}
	拼写检查使用的方法。用于 |z=| 命令和 |spellsuggest()| 函数。它是逗号分
	隔的项目列表:

	best		内部方法，最适用于英语。搜寻需要的改动的方式类似于
			"fast"，还用到少许基于发音相近的计分机制，以改进排列的
			顺序。

	double		内部方法，使用两个方法并混合其结果。第一个方法是
			"fast"，另一个是计算建议单词和坏词发音相近程度。只能用
			于能按发音折叠的语言。可能较慢，且结果不一定更好。

	fast		内部方法，只检查简单的改动: 字符插入/删除/交换。对简单
			的拼写错误效果不错。

	{number}	|z=| 列出的最大建议数目。不用于 |spellsuggest()|。建议
			数目永远不会比 'lines' 的值减 2 更多。

	file:{filename} 读入文件 {filename}，必须包含斜杠分隔的两列。第一列包
			含坏词，第二列包含建议的好词。
			例如:
				theribal/terrible ~
			用于没有出现在内部方法提供的建议列表顶部的常见错误。
			忽略没有斜杠的行，这可用于注释。
			此文件用于所有语言。

	expr:{expr}	计算表达式 {expr}。使用函数可以避免空格的麻烦。|v:val|
			是拼写错误的单词。该表达式必须返回列表的列表，每个项目
			包含建议和评分两项。
			例如:
				[['the', 33], ['that', 44]]
			设置 'verbose' 并用 |z=| 可以看到内部方法使用的评分。
			分数越小越好。
			如果你暂时从 'spellsuggest' 里排除 "expr:" 部分，也可
			以调用 |spellsuggest()|。
			安静地忽略错误，除非你设置 'verbose' 选项为非零值。

	只能使用 "best"、"double" 或 "fast" 中的一个。其它项目可以出现多次，任
	何顺序都可以。例如: >
		:set sps=file:~/.vim/sugg,best,expr:MySuggest()
<
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。



+-*/+-*/+-*/spellundo c 删除好词或坏词
:[count]spellu[ndo] {word}				*:spellu* *:spellundo*
			类似于 |zuw|，[count] 的使用同 |:spellgood|。

+-*/+-*/+-*/spellwrong c 增加拼写错误
							*:spellw* *:spellwrong*
:[count]spellw[rong] {word}
			把 {word} 作为一个坏 (错误: wrong) 词加入到
			'spellfile'，类似 |zw|。如果没有计数，使用第一个名字项
			目，计数为 2 使用第二个项目，等等。

+-*/sys _ 系统设置
+-*/+-*/autochdir o 根据当前窗口的文件切换目录
			*'autochdir'* *'acd'* *'noautochdir'* *'noacd'*
'autochdir' 'acd'	布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入此特性才有效，用 exists("+autochdir")
			可以检查}
	如果打开，Vim 会在你打开文件、切换缓冲区、删除缓冲区或者打开/关闭窗口
	时改变当前工作目录的值。具体来说，就是打开或者选择的文件所在的目录。
	提供该选项的目的是和 Sun ONE Studio 4 Enterprise Edition 发行的 Vim 后
	向兼容。
	注意: 打开次选项会使得某些插件无法工作。


+-*/+-*/compatible o 尽可能做到与 Vi 兼容
			*'compatible'* *'cp'* *'nocompatible'* *'nocp'*
'compatible' 'cp'	布尔型	(缺省打开，如果找到 |vimrc| 或 |gvimrc| 文件
								则为关闭)
			全局
			{Vi 无此功能}
	本选项的效果是使得 Vim 或者更兼容 Vi，或者以更有用的方式工作。
	这是一个特殊的选项，因为它的置位与复位影响到其他的设置。非 常 小 心:
	置位或者复位本选项会产生很多意想不到的效果: 映射以不同的方式进行解释，
	撤销的行为也有所不同，不一而足。如果你在 vimrc 文件里设置此选项，最好
	放在相当靠前的位置。
	缺省打开本选项，而各种选项使用 Vi 的缺省。本缺省值是为那些希望像 Vi 那
	样使用 Vim 的人准备的，他们可能都不 (想) 知道 'compatible' 选项。
	如果 Vim 启动时找到 |vimrc| 或 |gvimrc| 文件，关闭本选项，而没有修改的
	选项都设置为 Vim 的缺省。这意味着如果存在 |vimrc| 或 |gvimrc| 文件，
	Vim 使用 Vim 的缺省，否则使用 Vi 的缺省。(注意: 这不适用于系统范围的
	vimrc 或 gvimrc 文件，也不适用 -u 参数给定的文件)。另见
	|compatible-default| 和 |posix-compliance|。
	你也可以用 "-C" 参数置位此选项，或用 "-N" 复位。见 |-C| 和 |-N|。
	关闭本选项使得有不同 Vi 和 Vim 缺省的选项使用 Vim 的缺省值。见下面 '+'
	标注的选项。其它选项没有影响。
	一旦打开此选项，若干其它选项会被置位或复位，使得 Vim 尽可能的和 Vi 兼
	容。见下表。这可以用来回复到 Vi 兼容的编辑状态。
	另见 'cpoptions'。

	选项		+ 设置值	效果	~

	'allowrevins'	  关闭		没有 CTRL-_ 命令
	'backupcopy'	  Unix: "yes"	备份文件由复制产生
			  其它: "auto"  复制或者换名产生备份文件
	'backspace'	  ""		普通的退格
	'backup'	  关闭		没有备份文件
	'cindent'	  关闭		不待开 C 代码的缩进
	'cedit'		+ ""		没有打开 |cmdwin| 的键
	'cpoptions'	+ (所有标志位)	Vi 兼容的标志位
	'cscopetag'	  关闭		":tag" 不使用 cscope
	'cscopetagorder'  0		见 |cscopetagorder|
	'cscopeverbose'	  关闭		见 |cscopeverbose|
	'digraph'	  关闭		没有二合字母
	'esckeys'	+ 关闭		插入模式不使用 <Esc> 开始键码的键
	'expandtab'	  关闭		制表不扩展为空格
	'fileformats'	+ ""		没有自动的文件格式检测
			  "dos,unix"	除了 DOS、Windows 或 OS/2 外
	'formatoptions'	+ "vt"		Vi 兼容的排版选项
	'gdefault'	  关闭		":s" 没有缺省的 'g' 标志位
	'history'	+ 0		没有命令行历史
	'hkmap'		  关闭		没有希伯来语键盘映射
	'hkmapp'	  关闭		没有根据读音的希伯来语键盘映射
	'hlsearch'	  关闭		没有搜索匹配的高亮
	'incsearch'	  关闭		没有增量搜索
	'indentexpr'	  ""		没有基于表达式的缩进
	'insertmode'	  关闭		不以插入模式启动
	'iskeyword'	+ "@,48-57,_"	关键字包含字母数字和 '_'
	'joinspaces'	  打开		句号后插入两个空格
	'modeline'	+ 关闭		没有模式行
	'more'		+ 关闭		列表不暂停
	'revins'	  关闭		没有反向插入
	'ruler'		  关闭		没有标尺
	'scrolljump'	  1		滚动不跳跃
	'scrolloff'	  0		没有滚动偏移
	'shiftround'	  关闭		缩进不取整到 shiftwidth 的倍数
	'shortmess'	+ ""		不缩短信息
	'showcmd'	+ 关闭		不显示命令字符
	'showmode'	+ 关闭		不显示当前模式
	'smartcase'	  关闭		没有忽略大小写的自动切换
	'smartindent'	  关闭		没有智能缩进
	'smarttab'	  关闭		没有智能制表大小
	'softtabstop'	  0		制表总是使用 'tabstop' 个位置
	'startofline'	  打开		一些命令到行首
	'tagrelative'	+ 关闭		标签文件名不是相对的
	'textauto'	+ 关闭		没有自动文本模式检测
	'textwidth'	  0		没有自动行回绕
	'tildeop'	  关闭		波浪符不是操作符
	'ttimeout'	  关闭		没有终端超时
	'whichwrap'	+ ""		左右移动不回绕
	'wildchar'	+ CTRL-E	只有在当前值为 <Tab> 时，使用 CTRL-E
					用于命令行补全
	'writebackup'	  打开或关闭	取决于 |+writebackup| 特性


+-*/+-*/cpoptions o 设定 Vi-兼容的行为
						*'cpoptions'* *'cpo'*
'cpoptions' 'cpo'	字符串	(Vim 缺省: "aABceFs"，
				 Vi 缺省:  所有的标志位)
			全局
			{Vi 无此功能}
	单字符标志位的序列。每个字符的存在指示一种 vi 兼容的行为。可用于改变常
	见或被认为是更好的 vi 不兼容的行为。
	'cpoptions' 代表兼容性选项 "(compatible-options)"。
	为了可读性起见，可以加入逗号。
	建议使用 ":set" 的 "+=" 和 "-=" 特性，这可以避免未来版本增加新的标志位
	时出现的问题 |add-option-flags|。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。
	注意: 如果应该使用 Vi 的缺省值且 $VIM_POSIX 环境变量存在时，本选项设为
	POSIX 的缺省值 |posix|。这意味着 Vim 尽量符合 POSIX 规范的要求。

	       包含	行为	~
								*cpo-a*
		a	如果包含，带文件名参数的 ":read" 命令会为当前窗口设置
			轮换文件名。
								*cpo-A*
		A	如果包含，带文件名参数的 ":write" 命令会为当前窗口设置
			轮换文件名。
								*cpo-b*
		b	":map" 命令里识别 "\|" 为 map 命令的结束。'\' 被包含在
			映射里，'|' 之后的文本被解释为别的命令。使用 CTRL-V
			代替反斜杠使 '|' 也包含在映射里。适用于所有的映射、缩
			写、菜单和自动命令。
			另见 |map_bar|。
								*cpo-B*
		B	映射、缩写和菜单命令的 "to" 部分里反斜杠没有特殊含义。
			删除本标志位使得反斜杠的效果类似于于 CTRL-V。例如，命
			令 ":map X \<Esc>" 使得 X 被映射为:
				包含 'B' 时:	"\^["	 (^[ 是真正的 <Esc>)
				排除 'B' 时:	"<Esc>"  (5 个字符)
				(两种情况下都假定 '<' 标志位被排除)
								*cpo-c*
		c	搜索从任何光标所在的匹配的结束处继续，但不超过下一行的
			开始处。如果没有此标志位，搜索从光标位置之后的一个字符
			开始。使用 'c'，"abababababab" 重复用 "/abab" 模式时只
			有三个匹配，没有 'c' 的话有五个。
								*cpo-C*
		C	不串接反斜杠开始的被 source 的行。见
			|line-continuation|。
								*cpo-d*
		d	'tags' 选项使用 "./" 不意味着使用相对于当前文件的标签
			文件，而是当前目录下的标签文件。
								*cpo-D*
		D	带有字符参数的普通模式命令不使用 CTRL-K 输入二合字母，
			比如 |r|、|f| 和 |t|。
								*cpo-e*
		e	用 ":@r" 执行寄存器时，总是在最后一行加入 <CR>，即使寄
			存器不是面向行的也如此。如果本标志位不存在、寄存器非面
			向行且末行不以 <CR> 结尾的话，那么末行仍留在命令行上，
			在按 <CR> 之前可以继续编辑。
								*cpo-E*
		E	在空区域上使用 "y"、"d"、"c"、"g~"、"gu" 或 "gU" 是个
			错误。这些操作符至少需要操作一个字符。比如: "y0" 在第
			一列会失败。
								*cpo-f*
		f	如果包含并且当前缓冲区还没有文件名，带文件名参数的
			":read" 命令会为当前缓冲区设置文件名。
								*cpo-F*
		F	如果包含并且当前缓冲区还没有文件名，带文件名参数的
			":write" 命令会为当前缓冲区设置文件名。另见 |cpo-P|。
								*cpo-g*
		g	没有参数的 ":edit" 会转到第一行。
								*cpo-H*
		H	如果在只有空白的行使用 "I"，在最后一个空白前插入。没有
			此标志位，在最后一个空白后插入。
								*cpo-i*
		i	如果包含，读入时被中断的文件会使其状态成为已修改。
								*cpo-I*
		I	'autoindent' 插入缩进后上下移动光标不删除缩进。
								*cpo-j*
		j	连接行时，只有在 '.' 之后加入两个空格，'!' 或 '?' 之后
			不会。另见 'joinspaces'。
								*cpo-J*
		J	|sentence| 必须在 '.'，'!' 或 '?' 有两个空格才算。
			<Tab> 不识别为空白。
								*cpo-k*
		k	映射、缩写和菜单命令的 "to" 部分不识别原始键盘代码。比
			如，如果 <Key> 发送 ^[OA (其中的 ^[ 是 <Esc>)，命令
			":map X ^[OA" 会使得 X 被映射为:
				包含 'k' 时:	"^[OA"	 (3 个字符)
				排除 'k' 时:	"<Key>"  (单个键码)
			另见下面的 '<' 标志位。
								*cpo-K*
		K	如果映射只完成键码的一部分，不等待其完成。这会使映射
			<F1><F1> 在只读入第二个 <F1> 的一部分时无法工作。不
			过，这意味着用 <F1><Esc> 就可以中止该映射。
								*cpo-l*
		l	搜索模式里的 [] 范围内的反斜杠按本义出现，只有 "\]"、
			"\^"、"\-" 和 "\\" 是特别的。见 |/[]|
			   包含 'l' 时: "/[ \t]"  找到 <Space>、'\' 和 't'
			   排除 'l' 时: "/[ \t]"  找到 <Space> 和 <Tab>
			另见 |cpo-\|。
								*cpo-L*
		L	如果置位 'list' 选项，'wrapmargin'、'textwidth'、
			'softtabstop' 和虚拟替换模式 (见 |gR|) 把 <Tab> 看成两
			个字符，和 <Tab> 的普通行为不同。
								*cpo-m*
		m	如果包含，showmatch 总会等到半秒。如果不包含，
			showmatch 等待半秒或者到有字符输入为止。|'showmatch'|
								*cpo-M*
		M	如果排除，"%" 匹配会考虑反斜杠。所以 "( \( )" 和
			"\( ( \)" 里，外层的括号会匹配。如果包含，"%" 忽略反斜
			杠，这是 Vi 兼容行为。
								*cpo-n*
		n	如果包含，'number' 和 'relativenumber' 所用的列也用于
			文本的回绕行。
								*cpo-o*
		o	不记住搜索命令的行偏移并将它用于下一个搜索。
								*cpo-O*
		O	如果文件被覆盖，即使开始编辑时该文件还不存在，也不会抱
			怨。这项措施保护你不会意外地覆盖别人建立的文件。Vi 并
			不会为此抱怨。
								*cpo-p*
		p	Vi 兼容的 Lisp 缩进。如果不包含，使用稍好一些的算法。
								*cpo-P*
		P	如果包含，当当前缓冲区还没有文件名并且同时包含 'F' 标
			志位 |cpo-F| 时，附加到文件后的 ":write" 命令会设置当
			前缓冲区的文件名。
								*cpo-q*
		q	连接多行时，把光标留在连接两行时应该在的位置。
								*cpo-r*
		r	重复 ("." 命令) 使用 "/" 来重复搜索命令，而不一定使用
			实际用过的搜索字符串。
								*cpo-R*
		R	删除过滤行的位置标记。没有该标志位，标记会被保存，就像
			用了 |:keepmarks| 那样。
								*cpo-s*
		s	第一次进入缓冲区时，设置缓冲区选项。这和 Vim 3.0 版本
			的行为相同，现在这也是缺省。如果不存在，选项在缓冲区建
			立时设置。
								*cpo-S*
		S	每次进入缓冲区都设置缓冲区选项 (除了 'readonly'、
			'fileformat'、'filetype' 和 'syntax' 以外)。这是 (最)
			符合 Vi 兼容性的设定。
			这些选项将被设为当前缓冲区的值。如果你改变选项并切换到
			别的缓冲区，该值会被复制。这实际意味着，缓冲区选项全局
			于所有缓冲区。

			's'    'S'     缓冲区选项的复制在 ~
			否     否      建立缓冲区时
			是     否      第一次进入缓冲区时 (缺省)
			均可   是      每次进入缓冲区时 (vi 兼容)
								*cpo-t*
		t	"n" 命令记住标签命令的搜索模式。否则，Vim 只把该模式
			放到搜索模式的历史里，但不改变最近使用的搜索模式。
								*cpo-u*
		u	撤销的行为和 Vi 兼容。见 |undo-two-ways|。
								*cpo-v*
		v	插入模式里，退格删除的字符在屏幕上保持可见。没有本标志
			位，该字符从屏幕上立即删除。有了本标志位，新输入的文本
			覆盖屏幕上退格经过的字符。
								*cpo-w*
		w	在空白字符上使用 "cw" 只改变一个字符，而不是所有到下一
			个单词之前的空白。
								*cpo-W*
		W	不覆盖只读文件。如果不提供，":w!" 在可能的情况下覆盖只
			读文件。
								*cpo-x*
		x	命令行上输入 <Esc> 执行该命令行。
			Vim 的缺省行为是放弃命令行。因为 <Esc> 通常的含义是中
			止命令。|c_<Esc>|
								*cpo-X*
		X	使用计数时，"R" 只删除一次替换的文本。用带计数的 "."
			来重复 "R" 也是如此。
								*cpo-y*
		y	抽出 (yank) 命令可以用 "." 重复。
								*cpo-Z*
		Z	置位 'readonly' 选项时，使用 "w!" 不复位 'readonly'。
								*cpo-!*
		!	重复过滤命令时，使用最后使用的外部命令，不管它是什么。
			否则，使用最近的 -过滤- 命令。
								*cpo-$*
		$	对一行进行修改 (change) 时，不重显该行，但在修改文本的
			尾部放上 '$'。被修改的文本会被新输入的文本覆盖。如果你
			输入任何把光标移开插入点的命令，该行被重显。
								*cpo-%*
		%	"%" 命令执行 Vi 兼容的匹配行为。
			不识别 "#if"、"#endif" 等。
			不识别 "/*" 和 "*/"。
			单引号和双引号里的括号也被计算在内，这使得包含括号的字
			符串常数会影响匹配。比如，在 "if (strcmp("foo(", s))"
			这样的行里，第一个括号不匹配最后一个。如果不包含本标志
			位，单引号和双引号里的括号被特殊处理。如果匹配引号之外
			的括号，引号之内的所有内容被忽略。如果匹配引号之内的括
			号，会找到它的匹配 (如果有的话)。这对 C 程序很管用。
			此标志位还用于其它特性，例如 C 缩进。
								*cpo--*
		-	如果包含，到首行之上或末行之下的垂直移动的命令会失败。
			如果不包含，光标移到首行或末行，除非本来已经在该行上。
			适用于命令 "-"、"k"、CTRL-P、"+"、"j"、CTRL-N、CTRL-J
			和 ":1234"。
								*cpo-+*
		+	如果包含，":write file" 命令会复位缓冲区的 'modified'
			标志位，即使缓冲区本身可能和对应的文件不同。
								*cpo-star*
		*	":*" 和 ":@" 相同。如果不包含，":*" 是 ":'<,'>" 的别
			名，选择可视区域。
								*cpo-<*
		<	在映射、缩写和菜单命令的 "to" 部分不识别 |<>| 形式的特
			别键码。比如，命令 ":map X <Tab>" 使得 X 被映射为:
				包含 '<' 时:	"<Tab>"  (5 个字符)
				排除 '<' 时:	"^I"	 (^I 是真正的 <Tab>)
			另见上面的 'k' 标志位。
								*cpo->*
		>	附加到寄存器时，在附加文本之前加上换行符。

	POSIX 标志位。Vi 缺省值里没有，除非启动时设置 $VIM_POSIX。 |posix|

	       包含	行为	~
								*cpo-#*
		#	"D"、"o" 和 "O" 之前的计数没有效果。
								*cpo-&*
		&	使用 ":preserve" 时，正常退出但缓冲区仍然载入时保持交
			换文件。退出时测试此标志位。
								*cpo-\*
		\	搜索模式里的 [] 范围内的反斜杠按本义出现，只有 "\]" 是
			特别的。见 |/[]|
			   包含 '\' 时: "/[ \-]"  找到 <Space>、'\' 和 '-'
			   排除 '\' 时: "/[ \-]"  找到 <Space> 和 '-'
			另见 |cpo-l|。
								*cpo-/*
		/	使用 "%" 作为 |:s| 命令的替代字符串时，使用最近的替代
			字符串。|:s%|
								*cpo-{*
		{	|{| 和 |}| 命令也停在行首的 "{" 字符上。
								*cpo-.*
		.	":chdir" 和 ":cd" 命令在当前缓冲区被修改时失败，除非指
			定 !。Vim 并不需要这样，因为它记住打开文件的完整路径。
								*cpo-bar*
		|	$LINES 和 $COLUMNS 环境变量的值否决通过系统特定的函数
			得到的终端大小的值。



+-*/+-*/debug o 设为 ""msg"" 可以看到所有的错误消息
						*'debug'*
'debug'			字符串	(缺省为 "")
			全局
			{Vi 无此功能}
	可以使用这些值:		
	msg	别的情况下会忽略的错误信息此时都会给出。
	throw	别的情况下会忽略的错误信息此时都会给出，同时抛出例外并设置
		|v:errmsg|。
	beep	别的情况下会给出铃声的消息此时都会给出。
	这些值可以合并，用逗号分隔。
	"msg" 和 "throw" 可用于调试 'foldexpr'、'formatexpr' 或 'indentexpr'。


+-*/+-*/directory o 交换文件所用的目录名列表
						*'directory'* *'dir'*
'directory' 'dir'	字符串	(Amiga 的缺省为: ".,t:"，
				 MS-DOS 和 Win32: ".,c:\tmp,c:\temp"
				 Unix: ".,~/tmp,/var/tmp,/tmp")
			全局
	逗号分隔的交换文件的目录名列表。
	- 交换文件会在第一个可能的目录里建立。
	- 空意味着不会建立交换文件 (不能恢复！)。
	- 目录 "." 意味着把交换文件放在和被编辑文件相同的目录里。Unix 上，文件
	  名字前面会附加句号，使得目录列表里不出现该文件。MS-Windows 上，置位
	  "hidden" 属性并在可能的情况下附加句号。
	- "./" (或 MS-DOS 等环境的 ".\") 开始的目录意味着把交换文件放在被编辑
	  文件所在的相对位置。开头的 "." 用被编辑文件的路径名替换。
	- Unix 和 Win32 上，如果目录名以两个路径分隔符 "//" 或 "\\" 结束，交换
	  文件会使用文件的完整路径，其中的路径分隔符被百分号 '%' 替换。这样可
	  以保证保存目录里文件名的唯一性。
	  Win32 上，如果后跟分隔用的逗号，必须使用 "//"，因为 "\\" 会将逗号包
	  含到文件名里。
	- 逗号之后的空格被忽略，其它的空格视为目录名的一部分。要在目录命令开头
	  包含空格，在它之前加入反斜杠。
	- 要在目录名包含逗号，在它之前加入反斜杠。
	- 目录名可以用 ':' 或 '/' 结尾。
	- 环境变量被扩展 |:set_env|。
	- 小心使用 '\' 字符，在空格前输入一个，真正的反斜杠前要输入两个 (见
	  |option-backslash|)。例如: >
	    :set dir=c:\\tmp,\ dir\\,with\\,commas,\\\ dir\ with\ spaces
<	- 为了和 Vim 3.0 版本后向兼容，本选项开头的 '>' 被删除。
	建议列表里的第一个是 "."。这意味着编辑相同文件两次会得到警告。Unix 上
	不鼓励使用 "/tmp": 系统崩溃时交换文件会丢失。
	重启时，通常不会清除 "/var/tmp"，这样它比 "/tmp" 安全一些。但可能那里
	文件太多，而你的交换文件会迷失于其中。所以，建议先尝试你自己主目录下面
	的 "tmp" 目录。
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减目录。这可以避免未来版本使
	用其它缺省值出现的问题。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。
	{Vi: 放置临时文件的目录，缺省为 "/tmp"}


+-*/+-*/errorbells o 有错误信息时响铃
			*'errorbells'* *'eb'* *'noerrorbells'* *'noeb'*
'errorbells' 'eb'	布尔型	(缺省关闭)
			全局
	错误信息响铃 (鸣叫或屏幕闪烁)。只有对错误信息有意义。很多没有消息的错
	误也会使用该响铃 (比如，普通模式里按 <Esc>)。'visualbell' 说明如何设置
	响铃的行为: 鸣叫、屏幕闪烁或什么都不做。


+-*/+-*/eventignore o 忽略的自动命令事件
						*'eventignore'* *'ei'*
'eventignore' 'ei'	字符串	(缺省为 "")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+autocmd| 特性才有效}
	自动命令事件名的列表，它们将被忽略。
	如果设为 "all" 或者其中一个项目是 "all"，忽略所有的自动命令事件，自动
	命令将不会执行。
	否则，此为逗号分隔的事件名列表。例如: >
	    :set ei=WinEnter,WinLeave
<

+-*/+-*/exit c 等同于 "":xit
							*:exi* *:exit*
:[range]exi[t][!] [++opt] [file]
			同 :xit。

+-*/+-*/exrc o 在当前目录里读入 .vimrc 和 .exrc
					*'exrc'* *'ex'* *'noexrc'* *'noex'*
'exrc' 'ex'		布尔型 (缺省关闭)
			全局
			{Vi 无此功能}
	允许读入当前目录的 .vimrc，.exrc 和 .gvimrc。如果打开此选项，你需要考
	虑同时置位 'secure' 选项 (见 |initialization|)。使用本地的 .exrc、
	.vimrc 或 .gvimrc 是潜在的安全威胁，小心使用！另见 |.vimrc| 和
	|gui-init|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/foreground f 将一个 Vim 窗口移至前台
foreground()	把 Vim 窗口带到前台。用于从客户发送到 Vim 服务器的时候。
		|remote_send()|
		在 Win32 系统上，可能不行，操作系统并不总能允许窗口把自己带到
		前台。这时应使用 |remote_foreground()|。
		{仅当使用 Win32、Athena、Motif 和 GTK GUI 版本和 Win32 控制台
		版本时才有效}



+-*/+-*/has f 检查 Vim 是否支持某特性
has({feature})	返回数值，如果支持特性 {feature} 则为 1，不然为零。
		{feature} 参数是字符串。见下面的 |feature-list|。
		另见 |exists()|。



+-*/+-*/helpfile o 主帮助文件的完整路径名
						*'helpfile'* *'hf'*
'helpfile' 'hf'		字符串	(缺省为 (MSDOS)  "$VIMRUNTIME\doc\help.txt"
					 (其它) "$VIMRUNTIME/doc/help.txt")
			全局
			{Vi 无此功能}
	主帮助文件名。所有发布的帮助文件都应该放在一个目录里。另外，也使用所有
	'runtimepath' 里的 "doc" 目录。
	环境变量被扩展 |:set_env|。例如: "$VIMRUNTIME/doc/help.txt"。如果没有
	设置 $VIMRUNTIME，也会尝试 $VIM。另见 |$VIMRUNTIME|。关于如何包含空格
	和反斜杠，见 |option-backslash|。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/history o 记住的命令行的行数
						*'history'* *'hi'*
'history' 'hi'		数值型	(Vim 缺省: 20，Vi 缺省: 0)
			全局
			{Vi 无此功能}
	":" 命令的历史和最近的搜索模式的历史会被记住。本选项决定每个历史分别记
	住多少项 (见 |cmdline-editing|)。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/insertmode o 开始编辑文件时进入插入模式
			*'insertmode'* *'im'* *'noinsertmode'* *'noim'*
'insertmode' 'im'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	改变 Vim 的工作方式，使得插入模式是缺省模式。Vim 因而可以作为无模式的
	编辑器来使用，用于 |evim|。
	下面的插入模式命令会有用:
	- 使用光标键移动。
	- 使用 CTRL-O 执行一个单个普通模式的命令 |i_CTRL-O|)。如果这是映射，执
	  行时假设 'insertmode' 是关闭的。普通模式保持激活，直到映射结束为止。
	- 使用 CTRL-L 执行一系列普通模式，然后用 <Esc> 返回插入模式。注意
	  CTRL-L 向左移动光标，和没有置位 'insertmode' 时 <Esc> 所做的类似。
	  |i_CTRL-L|

	置位 'insertmode' 时，以下项目被改变:
	- 开始编辑文件时，Vim 进入插入模式。
	- 插入模式里的 <Esc> 是空操作，会响铃。
	- 普通模式里的 <Esc> 会使得 Vim 退回到插入模式。
	- 插入模式里的 CTRL-L 是一个命令，不会被插入。
	- 插入模式里的 CTRL-Z 暂停 Vim，见 |CTRL-Z|。	*i_CTRL-Z*
	不过，如果在映射里使用 <Esc>，它的行为和没有置位 'insertmode' 一样。这
	样，无论 'insertmode' 置位与否，都可以使用相同的映射。
	|:normal| 执行命令时，不使用 'insertmode'。

	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/intro c 显示介绍文字
							*:intro*
如果 Vim 启动的时候没有给出文件名，它会显示一段介绍文字 (为了帮助那些不知道
Vim 是什么的人)。一旦因为任何原因显示重画，它就被删除了。要再次看到这段文字，
使用 ":intro" 命令 (如果空间不够，你只会看到部分内容)。
   要避免启动时的介绍文字，在 'shortmess' 里加上 'I' 标志位。

+-*/+-*/loadplugins o 启动时调入插件脚本
			*'lpl'* *'nolpl'* *'loadplugins'* *'noloadplugins'*
'loadplugins' 'lpl'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	如果打开，启动时载入插件脚本 |load-plugins|。
	你可以在 |vimrc| 文件里复位本选项，禁止载入插件。
	注意 "-u NONE" 和 "--noplugin" 命令行参数复位本选项。|-u| |--noplugin|


+-*/+-*/loadview c 从文件里为当前窗口载入视图
							*:lo* *:loadview*
:lo[adview] [nr]	为当前文件载入视图。如果没有给出 [nr]，":mkview" 保存
			的视图被恢复。如果指定 [nr]，":mkview [nr]" 保存的视图
			被恢复。

+-*/+-*/maxmem o 单个缓冲区可用的最大内存 (以千字节计)
						*'maxmem'* *'mm'*
'maxmem' 'mm'		数值型	(缺省在 256 和 5120 之间 (依赖于系统) 或者可用
				内存的一半)
			全局
			{Vi 无此功能}
	单个缓冲区可用的内存的上限 (以千字节计)。如果到达此限度，再分配一个缓
	冲区额外的内存会释放其它内存。最大可用值大约为 2000000，此值表示不再有
	限制。另见 'maxmemtot'。


+-*/+-*/maxmempattern o 模式匹配使用的最大内存 (以千字节计)
						*'maxmempattern'* *'mmp'*
'maxmempattern' 'mmp'	数值型	(缺省为 1000)
			全局
			{Vi 无此功能}
	用于模式搜索的最大内存量 (以千字节计)。最大值大约为 2000000，此值表示
	不再有限制。
							*E363*
	如果 Vim 到达此限额，给出错误信息，其行为基本上和按 CTRL-C 类似。
	到达此限额通常意味着该模式效率非常低或者太过复杂。在很长的行上，用模式
	"\(.\)*" 可能就会发生此情况。".*" 就好很多。
	Vim 可能在到达 'maxmempattern' 限制之前就用完内存。


+-*/+-*/maxmemtot o 所有缓冲区可用的最大内存 (以千字节计)
						*'maxmemtot'* *'mmt'*
'maxmemtot' 'mmt'	数值型	(缺省在 2048 和 10240 之间 (依赖于系统) 或者可
				用内存的一半)
			全局
			{Vi 无此功能}
	所有缓冲区可用的内存以千字节计的上限。最大可用值大约为 2000000，此值表
	示不再有限制。在 64 位机器里可能可以用更高的值。嗨，你真的需要超过 2G
	字节进行文本编辑吗？另见 'maxmem'。


+-*/+-*/mkexrc c 写入当前映射和设置到文件
							*:mk* *:mkexrc*
:mk[exrc] [file]	写入当前的键盘映射和修改过的选项到 [file] 里 (缺省是当
			前目录下的 ".exrc" )，除非它已经存在。{Vi 无此功能}

+-*/+-*/mksession c 写入会话信息到文件
							*:mks* *:mksession*
:mks[ession][!] [file]	写入一个 Vim 脚本，该脚本能够恢复当前的编辑会话。
			如果包含 [!]，已有的文件会被覆盖。如果不提供 [file]，
			使用 "Session.vim"。

+-*/+-*/mkview c 写入当前窗口的视图到文件
							*:mkvie* *:mkview*
:mkvie[w][!] [file]	写入一个 Vim 脚本，该脚本能够恢复当前的窗口内容。
			如果包含 [!]，已有的文件会被覆盖。如果不提供 [file] 或
                        者它是从 1 到 9 的数字，则生成一个名字并在前面加上
			'viewdir' 的值。如果 'viewdir' 的最后一个目录名不存
			在，则顺便也建立该目录。
			如果该文件已存在，这时它总会被覆盖。使用 |:loadview|
			来重新载入该视图。
			如果 [file] 是文件名 (不考虑 'viewdir')，则编辑该文件
			的命令加入到生成的文件里。

+-*/+-*/mkvimrc c 写入当前映射和设置到文件
							*:mkv* *:mkvimrc*
:mkv[imrc][!] [file]	和 ":mkexrc" 类似，但是缺省值是当前目录下的 ".vimrc"。
			同时，也把 ":version" 写入文件里。{Vi 无此功能}

+-*/+-*/oldfiles c 列出 viminfo 文件中包含位置标记的文件
						*:ol* *:oldfiles*
:ol[dfiles]		列出 viminfo 文件中存储位置标记的文件。该列表在启动时
			读入，其后只有 ":rviminfo!" 能改变它。另见
			|v:oldfiles|。
			其中的编号可用于 |c_#<|。
			{Vi 无此功能，仅当编译时加入 |+eval| 特性才有效}

+-*/+-*/opendevice o MS-Windows 上允许读/写设备
			    *'opendevice'* *'odev'* *'noopendevice'* *'noodev'*
'opendevice' 'odev'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅限于 MS-DOS、MS-Windows 和 OS/2}
	允许从设备中读写。这可能会使 Vim 在一个可以打开但不能实际完成 I/O 的设
	备上死机。因此缺省关闭此选项。
	注意 在 MS-Windows 上编辑 "aux.h"、"lpt1.txt" 诸如此类也相当于对设备进
	行编辑。



+-*/+-*/qall c 退出 Vim
							*:qa* *:qall*
:qa[ll]		退出 Vim，除非存在修改过的缓冲区。(可以使用 ":bmod" 跳转
		到下一个修改过的缓冲区)。如果置位了 'autowriteall'，所有
		被修改的缓冲区将被保存，一如调用了 |:wqall|。{Vi 无此功能}

+-*/+-*/quit c 退出当前窗口 (如果只有一窗口，则退出 Vim)
							*:q* *:quit*
:q[uit]			退出当前窗口。如果是最后的一个，退出 Vim。如果已经有
			修改而且 Vim 拒绝放弃 |abandon| 当前的缓冲区，或者
			如果参数列表的最后一个文件还没有被编辑，该操作失败。
			如果有其它标签页，并且退出的是当前标签页的最后一个窗
			口，关闭当前标签页 |tab-page|。

+-*/+-*/quitall c 退出 Vim
							*:quita* *:quitall*
:quita[ll][!]	等同于 ":qall"。{Vi 无此功能}

+-*/+-*/remote_expr f 在 Vim 服务器内对一个表达式求值
remote_expr({server}, {string} [, {idvar}])
		发送 {string} 到 {server}。该发送的字符串是一个表达式，而返回
		的是远端执行的结果。这个结果必然是字符串或 |List|。|List| 被转
		换成字符串，转换方法是把项目用换行符连接起来 (末项之后没有)，
		就像用 join(expr, "\n") 那样。
		如果给出 {idvar}，将 {serverid} 保存在以它命令的变量里，此后的
		remote_read() 需要使用此值。
		另见 |clientserver| |RemoteReply|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		注意: 任何错误会在本地产生错误信息，但返回的结果只是一个空字符
		串。
		例如: >
			:echo remote_expr("gvim", "2+2")
			:echo remote_expr("gvim1", "b:current_syntax")
<


+-*/+-*/remote_foreground f 将一个 Vim 服务器窗口移至前台
remote_foreground({server})				*remote_foreground()*
		把名为 {server} 的 Vim 服务器带到前台。
		这类似于: >
			remote_expr({server}, "foreground()")
<		Win32 系统除外。那里，客户端完成实际的工作。因为操作系统不
		总能允许服务器把自己带到前台。
		注意: 如果窗口最小化，并不恢复之，foreground() 会这么做。
		该函数在沙盘里不可用 |sandbox|。
		{仅可用在 Win32、Athena、Motif 和 GTK 的 GUI 版本和 Win32 的控
		制台版本}



+-*/+-*/remote_peek f 检查一个服务器是否已经应答
remote_peek({serverid} [, {retvar}])		*remote_peek()*
		如果 {serverid} 有可用的字符串，返回正数。如果指定了
		{retvar}，复制任何应答字符串到 {retvar} 指定的变量。{retvar}
		必须是一个用来指定变量名的字符串。
		如果没有可用的应答，返回 0。
		如果出错，返回 -1。
		另见 |clientserver|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		示例: >
			:let repl = ""
			:echo "PEEK: ".remote_peek(id, "repl").": ".repl


+-*/+-*/remote_read f 从一个服务器读取应答
remote_read({serverid})				*remote_read()*
		返回从 {serverid} 发送的存在时间最长的应答，并删除之。该调用会
		等待直到有应答为止。
		另见 |clientserver|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		例如: >
			:echo remote_read(id)
<
							*remote_send()* *E241*
+-*/+-*/remote_send f 向 Vim 服务器发送字符命令
remote_send({server}, {string} [, {idvar}])
		发送 {string} 到 {server}。发送的字符串是输入键的序列。函数立
		即返回。Vim 的服务器端不对键进行映射 |:map|。
		如果给出 {idvar}，将 {serverid} 保存在以它命令的变量里，此后的
		remote_read() 需要使用此值。
		另见 |clientserver| |RemoteReply|。
		该函数在沙盘里不可用 |sandbox|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		注意: 任何错误会在服务器端报告，从而影响那里的显示。
		例如: >
		:echo remote_send("gvim", ":DropAndReply ".file, "serverid").
		 \ remote_read(serverid)

		:autocmd NONE RemoteReply *
		 \ echo remote_read(expand("<amatch>"))
		:echo remote_send("gvim", ":sleep 10 | echo ".
		 \ 'server2client(expand("<client>"), "HELLO")<CR>')
<

+-*/+-*/runtimepath o 用于运行时文件的目录列表
				*'runtimepath'* *'rtp'* *vimfiles*
'runtimepath' 'rtp'	字符串	(缺省:
					Unix: "$HOME/.vim,
						$VIM/vimfiles,
						$VIMRUNTIME,
						$VIM/vimfiles/after,
						$HOME/.vim/after"
					Amiga: "home:vimfiles,
						$VIM/vimfiles,
						$VIMRUNTIME,
						$VIM/vimfiles/after,
						home:vimfiles/after"
					PC、OS/2: "$HOME/vimfiles,
						$VIM/vimfiles,
						$VIMRUNTIME,
						$VIM/vimfiles/after,
						$HOME/vimfiles/after"
					Macintosh: "$VIM:vimfiles,
						$VIMRUNTIME,
						$VIM:vimfiles:after"
					RISC-OS: "Choices:vimfiles,
						$VIMRUNTIME,
						Choices:vimfiles/after"
					VMS: "sys$login:vimfiles,
						$VIM/vimfiles,
						$VIMRUNTIME,
						$VIM/vimfiles/after,
						sys$login:vimfiles/after")
			全局
			{Vi 无此功能}
	搜索运行时文件所用的目录:
	  filetype.vim	根据文件名决定文件类型 |new-filetype|
	  scripts.vim	根据文件内容决定文件类型 |new-filetype-scripts|
	  autoload/	自动载入的脚本 |autoload-functions|
	  colors/	色彩方案文件 |:colorscheme|
	  compiler/	编辑器文件 |:compiler|
	  doc/		文档 |write-local-help|
	  ftplugin/	文件类型插件 |write-filetype-plugin|
	  indent/	缩进脚本 |indent-expression|
	  keymap/	键盘映射表文件 |mbyte-keymap|
	  lang/		菜单翻译 |:menutrans|
	  menu.vim	GUI 菜单 |menu.vim|
	  plugin/	插件脚本 |write-plugin|
	  print/	打印所需的文件 |postscript-print-encoding|
	  spell/	拼写检查文件 |spell|
	  syntax/	语法文件 |mysyntaxfile|
	  tutor/	vimtutor 所需的文件 |tutor|

	还有其它用 |:runtime| 命令搜索的文件。

	多数系统上，设置的缺省值搜索五个位置:
	1. 你的主目录，里面有你的个人偏好。
	2. 系统范围的 Vim 目录，系统管理员的设置。
	3. $VIMRUNTIME 里，Vim 发布的文件。
							*after-directory*
	4. 系统范围 Vim 目录的 "after" 目录。为了系统管理员能够修改发布的缺省
	   值或增加设置 (很少用到)。
	5. 你的主目录下的 "after" 目录。为了你能够修改发布或者系统范围的设置或
	   增加个人偏好 (很少用到)。

	注意，和 'path' 不同，这里不允许 "**" 等通配符。普通的通配符是可以的，
	但这样做显著地减慢运行时文件的搜索速度。为效率着想，尽可能少使用项目并
	避免通配符。
	见 |:runtime|。
	例如: >
		:set runtimepath=~/vimruntime,/mygroup/vim,$VIMRUNTIME
<	先使用目录 "~/vimruntime" (包含你的个人 Vim 运行时文件)，然后是
	"/mygroup/vim" (在组间共享)，最后是 "$VIMRUNTIME" (发布的运行时文件)。
	为使用发布的运行时文件，你可能总是要在某处包含 $VIMRUNTIME。你可以在
	$VIMRUNTIME 之前放置目录，以定位替换发布的运行时文件的文件。你也可以在
	$VIMRUNTIME 之后放置目录，以定位改进发布的运行时文件的文件。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/rviminfo c 读取 viminfo 文件
						   *:rv* *:rviminfo* *E195*
:rv[iminfo][!] [file]	读入 viminfo 文件 [file] (缺省: 见上)。
			如果给出 [!]，那么任何已经给出的信息 (寄存器、位置标
			记、|v:oldfiles|，等等) 都会被覆盖。{Vi 无此功能}

+-*/+-*/secure o 在当前目录下以安全模式读入 .vimrc
						*'secure'* *'nosecure'* *E523*
'secure'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果打开，当前目录下的 ".vimrc" 和 ".exrc" 不允许使用 ":autocmd"、外壳
	和写入命令，映射命令被显示。只有你确信不会有问题，或者 'exrc' 选项被关
	闭，才可以关闭此选项。Unix 上，只有在 ".vimrc" 或 ".exrc" 不为你所拥有
	时才用到此选项。如果系统允许用户使用 "chown"，这仍然可能有危险。最好在
	你的 ~/.vimrc 的最后给 'secure' 置位。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/server2client f 向一个服务器客户发送应答
server2client( {clientid}, {string})			*server2client()*
		发送应答字符串到 {clientid}。最近刚发送过字符串的 {clientid}
		可以通过 expand("<client>") 得到。
		{仅当在编译时加入 |+clientserver| 特性才有效}
		备注:
		该 id 应在接受下一个命令前保存。也就是，在接收命令返回之前 (译
		者注: 似应为 "之后") 和任何等待输入的命令之前。
		另见 |clientserver|。
		示例: >
			:echo server2client(expand("<client>"), "HELLO")
<

+-*/+-*/serverlist f 返回服务器列表
serverlist()					*serverlist()*
		返回可用的服务器名字列表，每行一个。如果没有服务器或者该信息
		无法得到，返回空字符串。另见 |clientserver|。
		{仅当编译时加入 |+clientserver| 特性才有效}
		示例: >
			:echo serverlist()
<

+-*/+-*/sessionoptions o :mksession 的选项
						*'sessionoptions'* *'ssop'*
'sessionoptions' 'ssop'	字符串	(缺省: "blank,buffers,curdir,folds,
					       help,options,tabpages,winsize")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+mksession| 特性才有效}
	改变 |:mksession| 命令的效果。这是逗号分隔的单词列表。每个单词允许保存
	和恢复某种设置:
	   单词		保存和恢复 ~
	   blank	空窗口
	   buffers	隐藏和卸载的缓冲区，不光是那些在窗口里的
	   curdir	当前目录
	   folds	手动建立的折叠、打开/关闭的折叠和局部折叠选项
	   globals	大写字母开头且包含至少一个小写字母的全局变量。只保存字
			符串和数值类型。
	   help		帮助窗口
	   localoptions	局部于窗口或缓冲区的选项和映射 (不是局部选项的全局值)
	   options	所有的选项和映射 (也包括局部选项的全局值)
	   resize	Vim 窗口的大小: 'lines' 和 'columns'
	   sesdir	会话文件所在的目录会成为当前目录 (用于通过网络访问别的
			系统的项目)
	   slash	文件名里的反斜杠被替换成正斜杠
	   tabpages	所有标签页；如果不包含，只恢复当前标签页。这样你可以为
	   		每个标签页分别保存一个会话
	   unix		使用 Unix 换行格式 (单个 <NL>)，即使在 Windows 或 DOS
			上也是如此
	   winpos	整个 Vim 窗口的位置
	   winsize	窗口大小

	不要同时包含 "curdir" 和 "sesdir"。
	如果既没有包含 "curdir" 也没有包含 "sesdir"，使用绝对路径保存文件名。
	"slash" 和 "unix" 可用于 Windows 系统中，如果要和 Unix 共享会话文件的
	话。Unix 版本的 Vim 不能执行 dos 格式的脚本，但是 Windows 版本的 Vim
	可以执行 unix 版本的脚本。


+-*/+-*/tildeop o 波浪命令 ""~"" 以操作符方式工作
			     *'tildeop'* *'top'* *'notildeop'* *'notop'*
'tildeop' 'top'		布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果打开: 波浪符命令 "~" 的行为类似于操作符。
	注意: 如果置位 'compatible'，该选项被复位。


+-*/+-*/timeout o 映射和键盘代码等待超时
				*'timeout'* *'to'* *'notimeout'* *'noto'*
'timeout' 'to'		布尔型 (缺省打开)
			全局

+-*/+-*/timeoutlen o 超时时间 (以毫秒计)
						*'timeoutlen'* *'tm'*
'timeoutlen' 'tm'	数值型	(缺省为 1000)
			全局
			{仅有部分 Vi 版本支持}

+-*/+-*/ttimeoutlen o 键盘代码超时时间 (以毫秒计)
						*'ttimeoutlen'* *'ttm'*
'ttimeoutlen' 'ttm'	数值型	(缺省为 -1)
			全局
			{Vi 无此功能}
	毫秒计的等待键码或者映射的键序列完成的时间。也用于 CTRL-\ CTRL-N 和
	CTRL-\ CTRL-G 命令的一部分已经输入的场合。
	通常只使用 'timeoutlen'，而 'ttimeoutlen' 设为 -1 就可以。如果希望为键
	码使用不同的超时的值，设置 'ttimeoutlen' 为非负数。

		ttimeoutlen	映射延迟	   键码延迟	~
		   < 0		'timeoutlen'	   'timeoutlen'
		  >= 0		'timeoutlen'	   'ttimeoutlen'

	只有 'timeout' 和 'ttimeout' 选项要求时，超时才会发生。可用的设置 >
		:set timeout timeoutlen=3000 ttimeoutlen=100
<	(映射上的超时在三秒以后发生，键码上的超时在十分之一秒后发生)。


+-*/+-*/undodir o 保存撤销文件的位置
						*'undodir'* *'udir'*
'undodir' 'udir'	字符串	(缺省 ".")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+persistent_undo| 特性才有效}
	撤销文件使用的目录名列表，以逗号分隔。
	所用格式的详情见 |'backupdir'|。
	"." 代表文件所在的目录。此时，"file.txt" 对应的撤销文件名是
	".file.txt.un~"。
	如使用其他目录，撤销文件名是被编辑文件的完整路径，但路径分隔符以 "%"
	代替。
	写入时: 使用第一个存在的目录。因为 "." 总是可用， "." 之后的目录不会用
	来写入。
	读入时，查找所有的项目来寻找对应的撤销文件。使用第一个找到的撤销文件。
	如果该文件不可读，报错，但不再继续查找。
	见 |undo-persistence|。


+-*/+-*/undofile o 把撤销信息写入一个文件里
						*'undofile'* *'udf'*
'undofile' 'udf'	布尔型	(缺省关闭)
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+persistent_undo| 特性才有效}
	打开时，Vim 在把缓冲区写入文件时，自动保存撤销历史到撤销文件。读入文件
	到缓冲区时，自动恢复撤销历史。
	撤销文件写入的目录由 'undodir' 指定。
	关于此功能，可详见 |undo-persistence|。
	如果 'undoreload' 导致重载前为了可撤销而保存缓冲区，不读入撤销文件。
	警 告: 这是很新的功能，小心使用！


+-*/+-*/unsilent c 非安静模式执行命令
						*:uns* *:unsilent*
:uns[ilent] {command}	非安静模式执行命令 {command}。仅当在用了 |:silent| 之
			后才有意义。
			用此命令可以在用了 |:silent| 之后还是可以给出消息。下
			例中，|:silent| 用于避免读入文件时给出消息，而
			|:unsilent| 用于列出每个文件的第一行。 >
    		:silent argdo unsilent echo expand('%') . ": " . getline(1)
<

+-*/+-*/updatecount o 刷新交换文件所需的字符数
						*'updatecount'* *'uc'*
'updatecount' 'uc'	数值型	(缺省: 200)
			全局
			{Vi 无此功能}
	输入这么多个字符以后，把交换文件写入磁盘。如果为零，连交换文件都不会建
	立 (见灾难恢复的章节 |crash-recovery|)。以 "-n" 选项启动 Vim 会把
	'updatecount' 设为零，见 |startup|。在只读模式编辑时，该选项初始化为
	10000。
	交换文件可以用 |'swapfile'| 为每个缓冲区分别关闭。
	如果 'updatecount' 从零改设为非零，所有置位 'swapfile' 的缓冲区会建立
	交换文件。如果 'updatecount' 改设为零，已有的交换文件不会删除。
	另见 |'swapsync'|。
	对于 |'buftype'| 为 "nofile" 或 "nowrite" 的缓冲区，本选项没有作用。


+-*/+-*/updatetime o 刷新交换文件所需的毫秒数
						*'updatetime'* *'ut'*
'updatetime' 'ut'	数值型	(缺省为 4000)
			全局
			{Vi 无此功能}
	如果过了这么多毫秒数以后还没有任何输入，把交换文件写入磁盘 (见
	|crash-recovery|)。也用于 |CursorHold| 自动命令事件。


+-*/+-*/verbose o 给出详细信息
						*'verbose'* *'vbs'*
'verbose' 'vbs'		数值型	(缺省为 0)
			全局
			{Vi 无此功能，但有些版本会有布尔型的 verbose 选项}
	如果大于零，Vim 给出目前进行操作的相关消息。
	目前，给出以下消息:
	>= 1	viminfo 文件何时进行读写。
	>= 2	文件何时被 ":source"。
	>= 5	每个被搜索的标签文件和头文件。
	>= 8	执行的自动命令组所操作的文件。
	>= 9	每个执行的自动命令。
	>= 12	每个执行的函数。
	>= 13	何时例外被抛出、捕获、结束处理或者放弃。
	>= 14	任何在 ":finally" 子句里暂停的部分。
	>= 15	每个执行的 Ex 命令 (截短到 200 个字符)。

	本选项可以用 "-V" 参数设置。见 |-V|。
	|:verbose| 命令也可以设置此选项。

	如果设置了 'verbosefile' 选项，不显示 verbose 消息。


+-*/+-*/verbose c 执行命令，过程中设置 'verbose'
						*:verb* *:verbose*
:[count]verb[ose] {command}
			执行命令 {command}，执行期间 'verbose' 设为 [count]。
			如果忽略 [count]，缺省为 1。":0verbose" 可以用来设置
			'verbose' 为零。

+-*/+-*/verbosefile o 消息写入的文件
						*'verbosefile'* *'vfile'*
'verbosefile' 'vfile'	字符串	(缺省为空)
			全局
			{Vi 无此功能}
	如果非空，写入所有消息到此文件。如果文件已存在，附加消息于其后。
	Vim 退出或 'verbosefile' 被清空时，结束文件的写入。写入要通过缓冲，因
	此不一定能马上看得到写入的内容。
	设置 'verbosefile' 为新值就像先把它清空然后再设置一样。
	和 |:redir| 的区别是，在设置 'verbosefile' 时不再显示 verbose 消息。


+-*/+-*/version c 显示版本号和其它信息
							*:ve* *:version*
:ve[rsion]		显示编辑器的版本号。如果编译器能解释 "__DATE__"，也显
			示编译的日期。不然，显示固定的发布日期。
			然后，显示 Vim 编译时所带特性的信息。如果某特性之前有
			'+'，该特性被包含。如果之前有 '-'，该特性没有包含。要
			改变编译时带的特性，修改 feature.h 并重新编译 Vim。
			要在表达式里确定是否包含某特性，参见 |has()|。
			以下是特性的总览。
			第一列显示包含该特性的最小版本。
			   T	tiny (微小)
			   S	small (小)
			   N	normal (普通)
			   B	big (大)
			   H	huge (巨大)
			   m	手动设定或者依赖于其他特性
			 (无)	依赖于系统
			这样，如果一个特性标记为 "N"，它包含在 Vim 的 normal、
			big 和 huge 版本里。

+-*/+-*/viewdir o :mkview 存储文件的所在目录
						*'viewdir'* *'vdir'*
'viewdir' 'vdir'	字符串	(Amiga、MS-DOS、OS/2 和 Win32 的缺省:
						 "$VIM/vimfiles/view"，
				 Unix: "~/.vim/view"，
				 Macintosh: "$VIM:vimfiles:view"
				 VMS: "sys$login:vimfiles/view"
				 RiscOS: "Choices:vimfiles/view")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+mksession| 特性才有效}
	储存 |:mkview| 文件的目录名。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/viewoptions o 指定 :mkview 保存的内容
						*'viewoptions'* *'vop'*
'viewoptions' 'vop'	字符串	(缺省: "folds,options,cursor")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+mksession| 特性才有效}
	修改 |:mkview| 命令的效果。本选项是逗号分隔的单词列表。每个单词允许保
	存和恢复某种设置:
	   单词		保存和恢复 ~
	   cursor	文件和窗口的光标位置
	   folds	手动建立的折叠、打开/关闭的折叠和局部折叠选项
	   options	局部于窗口或缓冲区的选项和映射 (不是局部选项的全局值)
	   slash	文件名的反斜杠被替换成正斜杠
	   unix		使用 Unix 换行格式 (单个 <NL>)，即使在 Windows 或 DOS
			上也是如此

	"slash" 和 "unix" 可在 Windows 上使用，使得生成的视图文件可以和 Unix
	的共享。Unix 版本的 Vim 不能执行 dos 格式的脚本，但 Windows 版本的 Vim
	却可以执行 unix 格式的脚本。


+-*/+-*/viminfo o 启动和退出时使用 .viminfo 文件
				*'viminfo'* *'vi'* *E526* *E527* *E528*
'viminfo' 'vi'		字符串	(Vi 缺省: ""，Vim MS-DOS、Windows 和 OS/2 的缺
				   省: '100,<50,s10,h,rA:,rB:，
				   Amiga: '100,<50,s10,h,rdf0:,rdf1:,rdf2:
				   其它: '100,<50,s10,h)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+viminfo| 特性才有效}
	如果非空，初始化时读入 viminfo 文件，退出 Vim 时写回 (见
	|viminfo-file|)。
	该字符串应该是逗号分隔的参数，每个参数由单个字符组成，标识特定的参数
	名，后面跟着标识该参数的值的一个数值或字符串。如果某个字符没有列出，则
	使用该参数的缺省值。下表是能识别的字符和它们值对应的效果。
	字符	值	~
	!	如果包含，保存和恢复大写字母开头，并且不包含小写字母的全局变
		量。这样，保存 "KEEPTHIS" 和 "K_L_M"，但不保存 "KeepThis" 和
		"_K_L_M"。只保存字符串和数值类型。
	"	每个寄存器最大保存的行数。'<' 项目的旧名，缺点是你需要在 " 之
		前加上反斜杠，不然它被识别为注释的开始！
	%	如果包含，保存和恢复缓冲区列表。如果 Vim 启动时指定文件名参
		数，缓冲区列表不予恢复。如果 Vim 启动时没有指定文件名参数，缓
		冲区列表从 viminfo 文件里恢复。没有文件名的缓冲区和帮助文件的
		缓冲区不会写入 viminfo 文件。
		如果后跟数值，该数值指定保存的缓冲区的最大个数。如果没有此数，
		保存所有的缓冲区。
	'	编辑过的文件的最大数目，为它们记住位置标记。如果 'viminfo' 非
		空，必须包含本参数。
		包含本项目意味着 |jumplist| 和 |changelist| 也保存在 viminfo
		文件里。
	/	保存的搜索模式历史的最大项目数目。如果非零，那么也保存前次搜索
		和替代模式。如果不包含，使用 'history' 的值。
	:	保存的命令行历史的最大项目数目。如果不包含，使用 'history' 的
		值。
	<	每个寄存器最大保存的行数。如果为零，不保存寄存器。如果不包含，
		所有的行都被保存。'"' 是本项目的旧名。
		另见下面的 's' 项目: 千字节指定的限制。
	@	保存的输入行历史的最大项目数目。如果不包含，使用 'history' 的
		值。
	c	如果包含，把 viminfo 里的文本从写入时使用的 'encoding' 转换为
		当前的 'encoding'。见 |viminfo-encoding|。
	f	是否保存文件位置标记。如果为零，不保存文件位置标记 ('0 到 '9，
		'A 到 'Z)。如果不存在或者非零，它们都被保存。'0 记住光标的当
		前位置 (退出或者执行 ":wviminfo" 时)。
	h	载入 viminfo 文件时，关闭 'hlsearch' 的效果。如果不包含，取决
		于在最近的搜索命令之后是否使用过 ":nohlsearch"。
	n	viminfo 文件的名字。该名字必须立即跟随在 'n' 之后，而且这必须
		是最后一个参数！如果启动 Vim 时指定 "-i" 参数，那个文件名覆盖
		'viminfo' 在这里给出的。环境变量在文件打开时被扩展，而不是设置
		选项时。
	r	可移动的媒介。参数是字符串 (直到下一个 ',' 为止)，本参数可以多
		次给出。每个参数指定路径的开始部分，符合者不保存位置标记。这被
		用于避免可移动的媒介。MS-DOS 上你可以用 "ra:,rb:"，Amiga 则可
		用 "rdf0:,rdf1:,rdf2:"。你也可用于指定临时文件的路径，比如
		Unix 上: "r/tmp"。大小写忽略。每个 'r' 参数的最大长度是 50 个
		字符。
	s	每个项目千字节计的最大长度。如果为零，不保存寄存器。目前，只适
		用于寄存器。缺省的 "s10" 会忽略包含超过 10 千字节文本的寄存器。
		另见上面的 '<' 项目: 行数限制。

	例如: >
	    :set viminfo='50,<1000,s100,:0,n~/vim/viminfo
<
	'50		记住最近 50 个你编辑的文件的位置标记。
	<1000		记住寄存器的内容 (每个不超过 1000 行)。
	s100		跳过超过 100 千字节文本的寄存器。
	:0		不保存命令行历史。
	n~/vim/viminfo	使用的文件名是 "~/vim/viminfo"。
	no /		因为没有指定 '/'，使用缺省。也就是，保存所有的搜索历
			史和前次搜索和替代模式。
	no %		不保存也不读入缓冲区列表。
	no h		恢复 'hlsearch' 高亮。

	'viminfo' 从空值改设为非空值以后，你可以用 |:rviminfo| 读入文件的内
	容，但这不是自动进行的。

	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/visualbell o 使用可视铃声而不是响铃
			*'visualbell'* *'vb'* *'novisualbell'* *'novb'* *beep*
'visualbell' 'vb'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	使用可视响铃代替鸣叫。显示可视响铃的终端代码由 't_vb' 给出。如果既不想
	要响铃也不想要闪烁，使用 ":set vb t_vb="。
	注意: GUI 启动时，'t_vb' 复位为缺省值。你可能想在 |gvimrc| 里再次设置
	之。
	在 GUI 里，'t_vb' 缺省为 "<Esc>|f"，反转显示 20 毫秒。如果你想使用别的
	时间，可设 "<Esc>|40f"，其中 40 是毫秒计的时间。
	在 Amiga 上没有用，你总会得到屏幕闪烁。
	另见 'errorbells'。


+-*/+-*/write o 允许写入文件
						   *'write'* *'nowrite'*
'write'			布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	允许写入文件。如果不置位，不允许写入文件。可以用来设置只读但允许在里面
	修改文本的模式。可以用命令行参数 |-m| 或 |-M| 复位。仍然可以过滤文本，
	即使这需要写入临时文件。


+-*/+-*/wviminfo c 写入 viminfo 文件
					*:wv* *:wviminfo* *E137* *E138* *E574*
:wv[iminfo][!] [file]	写到 viminfo 文件 [file] (缺省: 见上)。
			该文件的信息先被读入，以合并原有和新的信息。如果使用
			[!]，旧的信息不会先读取，而是只写入系统自己内部的信
			息。如果 'viminfo' 为空，会写入不超过 100 个文件的位置
			标记。
			如果你得到错误 "E138: Can't write viminfo file"，检查
			有没有旧的临时文件没删除 (比如 ~/.viminf*) 还有你是否
			可以写入 .viminfo 文件所在的目录。
			{Vi 无此功能}

+-*/+-*/xall c 等同于 "":wqall
:wqa[ll] [++opt]				*:wqa* *:wqall* *:xa* *:xall*
:xa[ll]		保存所有修改过的缓冲区并退出 Vim。如果其中有无名的、只读的、
		或者其他原因写入失败的缓冲区，Vim 不会退出。{Vi 无此功能}

+-*/tag _ tags
+-*/+-*/helptags c 为一个目录产生帮助标签
					*:helpt* *:helptags*
				*E154* *E150* *E151* *E152* *E153* *E670*
:helpt[ags] [++t] {dir}
			为目录 {dir} 生成帮助标签文件 tags。它扫描该目录中所有
			的 "*.txt" 和 "*.??x" 文件中帮助标签定义。标签定义出现
			在星号之间。"*.??x" 文件是经过翻译的文件。它们相应产生
			"tags-??" 文件，参见 |help-translated|。所生成的标签文
			件经过排序。
			如果其中有重复项，会给出错误信息。
			直接覆盖已有的标签文件，不会有提示。
			可选的 "++t" 参数强制加入 "help-tags" 标签。如果 {dir}
			等于 $VIMRUNTIME/doc，也会这样做。
			例如，要重建运行时目录的帮助标签 (需要有相应写权限): >
				:helptags $VIMRUNTIME/doc
<			{Vi 无此功能}

+-*/+-*/ijump c 跳转到标识符的定义
							*:ij* *:ijump*
:[range]ij[ump][!] [count] [/]pattern[/]
			类似于 "[ CTRL-I"  和 "] CTRL-I"，但在 [range] 行范围
			搜索 (缺省: 整个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/ilist c 列出匹配标识符的行
							*:il* *:ilist*
:[range]il[ist][!] [/]pattern[/]
			类似于 "[I" 和 "]I"，但在 [range] 行范围搜索 (缺省:
			整个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/isearch c 列出匹配标识符的一行
							*:is* *:isearch*
:[range]is[earch][!] [count] [/]pattern[/]
			类似于 "[i" 和 "]i"，但在 [range] 行范围搜索 (缺省: 整
			个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/isplit c 分割窗口，并跳转到标识符的定义
							*:isp* *:isplit*
:[range]isp[lit][!] [count] [/]pattern[/]
			类似于 "CTRL-W i"  和 "CTRL-W i"，但在 [range] 行范围
			搜索 (缺省: 整个文件)。
			关于 [/] 和 [!] 见 |:search-args|。{Vi 无此功能}

+-*/+-*/ltag c 跳转到标签，并把匹配的标签加到位置列表上
							*:lt* *:ltag*
:lt[ag][!] [ident]	跳转到标签 [ident] 上并在当前窗口的新位置列表中加入匹
			配的标签。
			[ident] 可以是正规表达式，见 |tag-regexp|。如果
			[ident] 没有给出，使用标签栈上最后的标签名。查找标签行
			的搜索模式会加上 "\V" 前缀，转义所有的特殊字符 (very
			nomagic)。显示匹配标签的位置列表独立于标签栈。 [!] 见
			|tag-!|。
			{Vi 无此功能}

+-*/+-*/pop c 跳转到标签栈较旧的项目上
						*:po* *:pop* *E555* *E556*
:[count]po[p][!]	跳到标签栈上第 [count] 个较早的项目 (缺省为 1)。
			[!] 见 |tag-!|。{Vi 无此功能}

+-*/+-*/ptNext c 在预览窗口 |:tNext|
							*:ptN* *:ptNext*
:[count]ptN[ext][!]	等价于 ":ptprevious"。
			{Vi 无此功能}

+-*/+-*/ptfirst c 在预览窗口 |:trewind|
							*:ptf* *:ptfirst*
:[count]ptf[irst][!]	等价于 ":ptrewind"。
			{Vi 无此功能}

+-*/+-*/ptjump c 在预览窗口 |:tjump| 和显示标签
							*:ptj* *:ptjump*
:ptj[ump][!] [ident]	":tjump[!] [ident]" 并在预览窗口显示新的标签。详情见
			|:ptag|。
			{Vi 无此功能}

+-*/+-*/ptlast c 在预览窗口 |:tlast|
							*:ptl* *:ptlast*
:ptl[ast][!]		在预览窗口中见 ":tlast"。见 |:ptag|。
			{Vi 无此功能}

+-*/+-*/ptnext c 在预览窗口 |:tnext|
							*:ptn* *:ptnext*
:[count]ptn[ext][!]	在预览窗口里 ":tnext"。见 |:ptag|。
			{Vi 无此功能}

+-*/+-*/ptprevious c 在预览窗口 |:tprevious|
							*:ptp* *:ptprevious*
:[count]ptp[revious][!]	在预览窗口里 ":tprevious"。见 |:ptag|。
			{Vi 无此功能}

+-*/+-*/ptrewind c 在预览窗口 |:trewind|
							*:ptr* *:ptrewind*
:[count]ptr[ewind][!]	在预览窗口中 ":trewind"。见 |:ptag|。
			{Vi 无此功能}

+-*/+-*/ptselect c 在预览窗口 |:tselect| 和显示标签
							*:pts* *:ptselect*
:pts[elect][!] [ident]	":tselect[!] [ident]" 并在预览窗口显示新的标签。详情见
			|:ptag|。
			{Vi 无此功能}

+-*/+-*/stag c 分割窗口并跳转到标签上
							*:sta* *:stag*
:sta[g][!] [tagname]
		执行 ":tag[!] [tagname]" 并且分割窗口打开新的标签。参见
		|:tag|。

+-*/+-*/stjump c 执行 "":tjump"" 并分割窗口
							*:stj* *:stjump*
:stj[ump][!] [ident]	":tjump[!] [ident]" 并分割窗口以显示选择的标签。
			{Vi 无此功能}

+-*/+-*/stselect c 执行 "":tselect"" 并分割窗口
							*:sts* *:stselect*
:sts[elect][!] [ident]	":tselect[!] [ident]" 并分割窗口以显示选择的标签。
			{Vi 无此功能}

+-*/+-*/tNext c 跳转到上一个匹配的标签
							*:tN* *:tNext*
:[count]tN[ext][!]	和 ":tprevious" 相同。{Vi 无此功能}

+-*/+-*/tag c 跳转到标签上
						*:ta* *:tag* *E426* *E429*
:[count]ta[g][!] {ident}
			根据 tags 文件的信息，跳转到 {ident} 的定义上。
			把 {ident} 放在堆栈上。[!] 见 |tag-!|。
			{ident} 可以是个正规表达式。见 |tag-regexp|。
			如果有 {ident} 的多个匹配，则跳转到它们中的第 [count]
			个。如果 [count] 被省略，则跳转到第一个。要跳转到其它
			匹配的标签，参见 |tag-matchlist|。

+-*/+-*/tagbsearch o 标签文件里用二分法查找
			*'tagbsearch'* *'tbs'* *'notagbsearch'* *'notbs'*
'tagbsearch' 'tbs'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	查找标签时 (比如 |:ta| 命令)，Vim 可以在标签文件里使用二分法查找或者线
	性查找。二分法查找使标签的查找过程会快得多，但如果标签文件没有进行适当
	的排序，线性查找会找到更多的标签。
	Vim 通常假设你的标签文件已经排序，或者明确指示说它们没有排序。只有不符
	合这些情况，才需要关闭 'tagbsearch' 选项。

	如果打开 'tagbsearch'，先在标签文件里使用二分法查找。在特定场合下，Vim
	会为特定文件代之以线性查找，或在使用线性查找重试所有的文件。如果关闭
	'tagbsearch'，只使用线性查找。

	如果 Vim 发现文件开头的行里指示该文件没有排序，总是对该文件进行线性查
	找: >
   !_TAG_FILE_SORTED	0	/一些注释/
<	['0' 之前和之后的空白必须是单个 <Tab>]

	如果二分法查找进行完毕但在所有 'tags' 列出的文件中找不到匹配，而且
	'ignorecase' 置位或者使用的是模式而不是普通的标签名，用线性查找重试。
	没有排序的标签文件里的标签和大小写不同的匹配，只有在重试里才能找到。

	如果标签文件指示它按大小写合并排序并且置位 'ignorecase'，可以避免两次
	线性查找。在 "!_TAG_FILE_SORTED" 行中使用值 '2'。标签文件可以用多数
	unix 系统上存在的 "sort" 程序的 -f 选项完成大小写合并的排序，类似于下
	面的命令: "sort -f -o tags tags"。对于 "Exuberant ctags" 5.x 或更高的
	版本 (至少 5.5)，--sort=foldcase 选项也可用于此目的。注意 要使之工作，
	大小写必须都被合并到大写字母上。

	如果 'tagbsearch' 关闭，标签查找慢得多，但找不到完整的匹配比找到完整匹
	配的更慢。没有排序的标签文件里的标签只能在 'tagbsearch' 关闭时找到。
	如果标签文件没有排序，或者排序方法不正确 (不按照 ASCII 字节值排序) ，
	'tagbsearch' 必须关闭，或至少上面给出的行应该包含在标签文件里。
	本选项不影响查找所有匹配标签的命令 (例如，命令行补全和 ":help")。
	{Vi: 有的版本总是使用二分法查找}


+-*/+-*/tagfiles f 得到标签文件的列表
tagfiles()	返回 |List|，当前缓冲区用于搜索的标签文件名。这是 'tags' 选项
		扩展后的内容。



+-*/+-*/taglength o 标签里的有效字符数
						*'taglength'* *'tl'*
'taglength' 'tl'	数值型	(缺省为 0)
			全局
	如果非零，每个标签的有效字符不超过此数目。


+-*/+-*/taglist f 得到匹配标签的列表
taglist({expr})							*taglist()*
		返回匹配正规表达式 {expr} 的标签列表。每个列表项目是一个至少包
		含以下项目的字典:
			name		标签名。
			filename	标签定义的文件名。它或者相对于当前目
					录，或者包含完整路径。
			cmd		用于在文件里定位标签的 Ex 命令。
			kind		标签类型。该项目的值取决于特定于语言的
					类型值。只在 Exuberant ctags 或 hdrtag
					生成的标签文件里存在。
			static		特定于文件的标签。详见 |static-tag|。
		可能还有一些其它项目，取决于标签文件的内容: access、
		implementation、inherits 和 signature。这些字段的信息参见
		ctags 文档。C 代码里可能出现字段 "struct"、"class" 和 "enum"，
		它们给出标签所在的实体的名字。

		ex 命令 'cmd' 可以是 ex 搜索模式、行号或者行号后跟字节位置。

		如果没有匹配的标签，返回空列表。

		要得到标签的准确匹配，{expr} 里必须使用 '^' 和 '$'。 关于标签
		搜索正规表达式模式的详情见 |tag-regexp|。

		|'tags'| 提供 Vim 如何定位标签文件的信息。|tags-file-format|
		说明不同的 ctags 工具生成的标签文件的格式。


+-*/+-*/tagrelative o 标签文件里的文件名是相对路径
			*'tagrelative'* *'tr'* *'notagrelative'* *'notr'*
'tagrelative' 'tr'	布尔型	(Vim 缺省: 打开，Vi 缺省: 关闭)
			全局
			{Vi 无此功能}
	如果打开并使用别的目录下的标签文件，那个标签文件的文件名相对于标签文件
	所在的目录。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/tags o 标签命令使用的文件名列表
						*'tags'* *'tag'* *E433*
'tags' 'tag'		字符串	(缺省为 "./tags,tags"，如果编译时加入
				|+emacs_tags|: "./tags,./TAGS,tags,TAGS")
			全局或局部于缓冲区 |global-local|
	标签命令所用的多个文件名，空格或逗号分隔。要在文件名里包含空格或逗号，
	在它们之前加上反斜杠 (|option-backslash| 说明如何包含空格和反斜杠)。
	如果文件名以 "./" 开始，'.' 被替换为当前文件的路径。但只在 'cpoptions'
	里没有包含 'd' 标志位时才会如此。环境变量被扩展 |:set_env|。另见
	|tags-option|。
	可以用 "*"、"**" 和其它通配符来搜索目录树下的标签文件。见
	|file-searching|。例如，"/lib/**/tags" 会找到 "/lib" 下面所有名为
	"tags" 的文件。文件名本身不能包含通配符，会按原样使用。例如
	"/lib/**/tags?" 会找到名为 "tags?" 的文件 {仅当编译时加入
	|+path_extra| 特性才有效}
	可以用 |tagfiles()| 函数来得到实际使用的文件名列表。
	如果 Vim 编译时加入 |+emacs_tags| 特性，也支持 Emacs 风格的标签文件。
	它们被自动识别。缺省值这时变成 "./tags,./TAGS,tags,TAGS"，除非大小写被
	忽略 (MS-Windows)。|emacs-tags|
	建议使用 |:set+=| 和 |:set-=| 来从列表里加减文件名。这可以避免未来版本
	使用其它缺省值出现的问题。
	{Vi: 缺省是 "tags /usr/lib/tags"}


+-*/+-*/tags c 显示标签栈的内容
							*:tags*
:tags			显示标签栈的内容。激活的项目以 '>' 标明。{Vi 无此功能}

+-*/+-*/tagstack o 把标签推入标签栈
				*'tagstack'* *'tgst'* *'notagstack'* *'notgst'*
'tagstack' 'tgst'	布尔型	(缺省打开)
			全局
			{仅有部分 Vi 版本支持}
	如果打开，正常使用 |tagstack|。如果关闭，带参数的 ":tag" 或 ":tselect"
	命令不会把标签推入标签栈中。后续的不带参数的 ":tag"、":pop" 命令或者其
	它使用的标签栈的命令会使用没有改动过的标签栈，但会改变活动项目的指针。
	复位本选项，可在映射里使用 ":tag" 命令而不期望它去改变标签栈。


+-*/+-*/tfirst c 转到第一个匹配的标签
							*:tf* *:tfirst*
:[count]tf[irst][!]	和 ":trewind" 相同。{Vi 无此功能}

+-*/+-*/tjump c 类似于 "":tselect""，只有一个匹配时直接跳转之
							*:tj* *:tjump*
:tj[ump][!] [ident]	类似于 ":tselect"，但如果只有一个匹配，直接跳转之。
			{Vi 无此功能}

+-*/+-*/tlast c 跳转到最后一个匹配的标签
							*:tl* *:tlast*
:tl[ast][!]		跳到最后匹配的标签。[!] 见 |tag-!|。{Vi 无此功能}

+-*/+-*/tnext c 跳转到下一个匹配的标签
							*:tn* *:tnext*
:[count]tn[ext][!]	跳转到向下 [count] 个匹配的标签 (缺省为 1)。[!] 见
			|tag-!|。{Vi 无此功能}

+-*/+-*/tprevious c 跳转到上一个匹配的标签
							*:tp* *:tprevious*
:[count]tp[revious][!]	跳转到向上 [count] 个匹配的标签 (缺省为 1)。[!] 见
			|tag-!|。{Vi 无此功能}

+-*/+-*/trewind c 跳转到第一个匹配的标签
							*:tr* *:trewind*
:[count]tr[ewind][!]	跳转到第一个匹配的标签。如果给出 [count]，跳到第
			[count] 个匹配的标签。[!] 见 |tag-!|。{Vi 无此功能}

+-*/+-*/tselect c 列出匹配的标签并从中选择一个
							*:ts* *:tselect*
:ts[elect][!] [ident]	根据 tags 文件的信息，列出匹配 [ident] 的标签。
			如果 [ident] 没有给出，使用标签栈上最后的标签名。
			第一列的 '>' 指示列表的当前位置 (如果有的话)。
			[ident] 可以是正规表达式模式，见 |tag-regexp|。
			列表使用的优先级顺序见 |tag-priority|。
			{Vi 无此功能}
			示例输出:

+-*/viml _ vim脚本
+-*/+-*/augroup c 选择要用的自动命令组
							*:aug* *:augroup*
:aug[roup] {name}		定义其后的 ":autocmd" 命令使用的自动命令组名。
				名字 "end" 或者 "END" 选择缺省组。

+-*/+-*/autocmd c 输入或者显示自动命令
							*:au* *:autocmd*
:au[tocmd] [group] {event} {pat} [nested] {cmd}
把 {cmd} 加到 Vim 在匹配 {pat} 模式的文件执行 {event}事件时自动执行的命令列表。
Vim 总把 {cmd} 加到已有的自动命令之后，这样保证自动命令的执行顺序与其定义的顺序相同。
特殊模式 <buffer> 或 <buffer=N> 定义局部于缓冲区的自动命令.
自动命令缺省不会嵌套。如果你在自动命令里用 ":e" 或者 ":w"，Vim 不会执行这些命
令相应的 BufRead 和 BufWrite 自动命令。如果你需要这么做，在需要嵌套的命令的定
义里加上 "nested" 标志位。例如: >
  :autocmd FileChangedShell *.c nested e!
为了防止递归循环，嵌套限定为 10 层。
这里， {pat} 模式的解释和文件名里的模式大致相同:
	*	匹配任何字符序列
	?	匹配任何单个字符
	\?	匹配 '?'
	.	匹配 '.'
	~	匹配 '~'
	,	分隔模式
	\,	匹配 ','
	{ }	类似于 |pattern| 里的 \( \)
	,	在 { } 里: 类似于 |pattern| 里的 \|
	\	类似于 |pattern| 里的特殊含义
	[ch]	匹配 'c' 或 'h'
	[^ch]   匹配除了 'c' 和 'h' 的任何字符
注意 ":autocmd" 的参数里的特殊字符 (例如，"%"、"<cword>") 在定义时不会被扩展，
而是在事件发生并执行 {cmd} 的时候才进行。唯一的例外是 "<sfile>" 在定义时扩展。
例如:
>
	:au BufNewFile,BufRead *.html so <sfile>:h/html.vim

这里 Vim 把 <sfile> 扩展为该行所在的文件名。

如果你的 .vimrc 被执行两次，自动命令就会出现两次。在 .vimrc 文件里定义自动命令
之前置入以下命令就可以避免这个问题: >

	:autocmd!	" 删除当前组里_所有_的自动命令。

如果你不想删除所有的自动命令，可以用变量来确保 Vim 只定义自动命令一次: >

	:if !exists("autocommands_loaded")
	:  let autocommands_loaded = 1
	:  au ...
	:endif


+-*/+-*/breakadd c 增加调试器断点
							*:breaka* *:breakadd*
:breaka[dd] func [lnum] {name}
		在函数上设置断点。例如: >
			:breakadd func Explore
<		它不会检查函数名的合法性。这样，断点可以在函数定义之前设置。

+-*/+-*/breakdel c 删除调试器断点
						*:breakd* *:breakdel* *E161*
:breakd[el] {nr}
		删除断点 {nr}。用 |:breaklist| 可以看到每个断点的编号 {nr}。

+-*/+-*/breaklist c 列出调试器断点
							*:breakl* *:breaklist*
:breakl[ist]
		列出所有的断点。

+-*/+-*/changenr f 返回最近的改变号
changenr()						*changenr()*
		返回最近改变的编号。这和 |:undolist| 显示的编号相同，可用于
		|:undo| 命令。
		如果发生了改变，返回的是此改变的编号。在重做以后，返回的是重做
		的改变的编号。在撤销以后，返回撤销的改变的编号减一。


+-*/+-*/confirm c 需要确认时，提示用户
							*:confirm* *:conf*
:conf[irm] {command}	执行 {command}，如果有操作需要确认，显示对话框。可用于
			":q"、":qa" 和 ":w" 命令 (后者用于超越只读的设定)。

+-*/+-*/debug c 在调试模式执行命令
								*:debug*
2. 执行命令前加上 ":debug" 前缀。这样，调试只对这个命令进行。这对调试某一个特
   定的脚本和用户函数，或者 autocommands 用到的脚本和函数有用。例如: >
	:debug edit test.txt.gz

+-*/+-*/debuggreedy c 从正常的输入那里读取调试模式命令
						*:debugg* *:debuggreedy*
:debugg[reedy]
		从正常的输入流而不是直接从用户输入里读取调试模式命令。这只对测
		试脚本有用。例如: >
		  echo 'q^Mq' | vim -e -s -c debuggreedy -c 'breakadd file script.vim' -S script.vim

+-*/+-*/doautoall c 在所有载入的缓冲区上应用自动命令
						*:doautoa* *:doautoall*
:doautoa[ll] [group] {event} [fname]
			类似于 ":doautocmd"，但对每个已载入的缓冲区应用自动命
			令。注意 [fname] 用于选择自动命令，而不是其应用的缓冲
			区。
			要小心: 不要用这个命令执行删除缓冲区、切换到别的缓冲区
			或者修改缓冲区内容的自动命令；否则结果不可预测。该命令
			是设计用来执行类似于设置选项、修改高亮等任务的自动命令
			的。

+-*/+-*/doautocmd c 在当前缓冲区应用自动命令
					*:do* *:doau* *:doautocmd* *E217*
:do[autocmd] [group] {event} [fname]
			应用匹配 [fname] (缺省是当前文件名) 和针对当前缓冲区的
			{event} 事件的自动命令。如果当前文件不匹配正确的模式，
			修改完设置，或者想手动执行某一特定的事件的自动命令的时
			候，都可以使用该命令。
			自动命令中也可以使用，这样你可以用基于一个扩展名的自动
			命令来应用于另一个扩展名。例如: >
				:au Bufenter *.cpp so ~/.vimrc_cpp
				:au Bufenter *.cpp doau BufEnter x.c
<			要小心避免死循环，参见 |autocmd-nested|。

+-*/+-*/echo c 回显表达式结果
							*:ec* *:echo*
:ec[ho] {expr1} ..	回显每个 {expr1}，以空格分隔。第一个 {expr1} 开启一个
			新行。另见 |:comment|。
			使用 "\n" 来开启新行。使用 "\r" 把光标移到第一列。
			使用 |:echohl| 命令的高亮设置。
			后面不能跟注释。
			示例: >
		:echo "'shell' 的值是 " &shell
<							*:echo-redraw*
			后来的重画可能使消息再次消失。因为 Vim 常常会推迟重画
			直到整个命令序列执行完为止，这个问题会频繁出现。要避免
			":echo" 之前的命令引起它之后的重画 (通常，重画被延迟到
			有输入的时候才进行)，使用 |:redraw| 命令强制重画。例
			如: >
		:new | redraw | echo "这里有一个新窗口"
<
							*:echon*
:echon {expr1} ..	回显每个 {expr1}，不附加其它字符。另见 |:comment|。
			使用 |:echohl| 命令的高亮设置。
			后面不能跟注释。
			例如: >
				:echon "'shell' 的值是 " &shell
<
			注意 两者的区别: ":echo" 是一个 Vim 命令，而 ":!echo"
			是一个外部的外壳命令: >
		:!echo %		--> filename
<			":!" 的参数被扩展，见 |:_%|。 >
		:!echo "%"		--> filename or "filename"
<			和前例类似，你是否会看到双引号取决于你的 'shell'。 >
		:echo %			--> nothing
<			'%' 不是一个表达式合法的字符。 >
		:echo "%"		--> %
<			只会回显 '%' 字符。 >
		:echo expand("%")	--> filename
<			调用 expand() 函数来扩展 '%'。

+-*/+-*/echoerr c 类似于 :echo，如同错误一样显示和使用历史
							*:echoe* *:echoerr*
:echoe[rr] {expr1} ..	回显表达式的结果，将其作为一个错误消息，并把该消息保
			存在 |message-history| 里。如果用在脚本或函数里，会加
			入行号。
			参数之间加入空格，和 |:echo| 类似。如果在 try 条件句里
			使用，该消息会抛出一个错误例外 (见 |try-echoerr|)。
			示例: >
		:echoerr "This script just failed!"
<			如果你只想要使用 |:echohl| 高亮的消息。
			要得到铃声: >
		:exe "normal \<Esc>"
<
							*:exe* *:execute*
:exe[cute] {expr1} ..	计算 {expr1}，返回的字符串作为 Ex 命令执行。
			多个参数用空格连接。如果不想有额外的空格，使用 "." 操
			作符来连接字符串使之成为一个参数。
			{expr1} 用作被处理的命令，命令行编辑的键不会被识别。
			后面不能跟注释。
			示例: >
		:execute "buffer" nextbuf
		:execute "normal" count . "w"
<
			":execute" 可以用来把命令附加到不能接受 '|' 的命令后
			面。比如: >
		:execute '!ls' | echo "theend"

+-*/+-*/echohl c 为 echo 等命令设置高亮
							*:echoh* *:echohl*
:echoh[l] {name}	让其后的 |:echo|、|:echon| 和 |:echomsg| 命令使用高亮
			组 {name}。也可用于 |input()| 的提示。示例: >
		:echohl WarningMsg | echo "Don't panic!" | echohl None
<			不要忘记把组设回 "None"。不然其后的 echo 都会被高亮。

+-*/+-*/echomsg c 等同于 :echo，在历史里放置消息
							*:echom* *:echomsg*
:echom[sg] {expr1} ..	回显表达式的结果，将其作为一个真正的消息，并把该消息保
			存在 |message-history| 里。
			参数之间加入空格，和 |:echo| 类似。但不可显示的字符只
			是回显而不会被解释。
			这里的分析过程和 |:echo| 略有不同，而更像 |:execute|。
			所有的表达式都先经计算后进行连接，然后再进行回显。
			表达式必须返回数值或字符串，返回字典和列表会出错。
			使用 |:echohl| 命令的高亮设置。
			示例: >
		:echomsg "It's a Zizzer Zazzer Zuzz, as you can plainly see."
<			|:echo-redraw| 说明如何避免屏幕重画时消息的消失问题。
							*:echoe* *:echoerr*
:echoe[rr] {expr1} ..	回显表达式的结果，将其作为一个错误消息，并把该消息保
			存在 |message-history| 里。如果用在脚本或函数里，会加
			入行号。
			参数之间加入空格，和 |:echo| 类似。如果在 try 条件句里
			使用，该消息会抛出一个错误例外 (见 |try-echoerr|)。
			示例: >
		:echoerr "This script just failed!"
<			如果你只想要使用 |:echohl| 高亮的消息。
			要得到铃声: >
		:exe "normal \<Esc>"
<
							*:exe* *:execute*
:exe[cute] {expr1} ..	计算 {expr1}，返回的字符串作为 Ex 命令执行。
			多个参数用空格连接。如果不想有额外的空格，使用 "." 操
			作符来连接字符串使之成为一个参数。
			{expr1} 用作被处理的命令，命令行编辑的键不会被识别。
			后面不能跟注释。
			示例: >
		:execute "buffer" nextbuf
		:execute "normal" count . "w"
<
			":execute" 可以用来把命令附加到不能接受 '|' 的命令后
			面。比如: >
		:execute '!ls' | echo "theend"

+-*/+-*/echon c 等同于 :echo，但不留 <EOL>
							*:echon*
:echon {expr1} ..	回显每个 {expr1}，不附加其它字符。另见 |:comment|。
			使用 |:echohl| 命令的高亮设置。
			后面不能跟注释。
			例如: >
				:echon "'shell' 的值是 " &shell
<
			注意 两者的区别: ":echo" 是一个 Vim 命令，而 ":!echo"
			是一个外部的外壳命令: >
		:!echo %		--> filename
<			":!" 的参数被扩展，见 |:_%|。 >
		:!echo "%"		--> filename or "filename"
<			和前例类似，你是否会看到双引号取决于你的 'shell'。 >
		:echo %			--> nothing
<			'%' 不是一个表达式合法的字符。 >
		:echo "%"		--> %
<			只会回显 '%' 字符。 >
		:echo expand("%")	--> filename
<			调用 expand() 函数来扩展 '%'。

+-*/+-*/eventhandler f 检查是否在一个事件处理程序内
eventhandler()						*eventhandler()*
		如果在事件处理中则返回 1。此时，Vim 在等待用户输入一个字符的时
		候被中断，比如，在 Vim 上拖放了一个文件。这也意味着此时不能使
		用交互的命令。如果不是，返回零。


+-*/+-*/execute c 执行表达式的结果产生的字符串
							*:exe* *:execute*
:exe[cute] {expr1} ..	计算 {expr1}，返回的字符串作为 Ex 命令执行。
			多个参数用空格连接。如果不想有额外的空格，使用 "." 操
			作符来连接字符串使之成为一个参数。
			{expr1} 用作被处理的命令，命令行编辑的键不会被识别。
			后面不能跟注释。
			示例: >
		:execute "buffer" nextbuf
		:execute "normal" count . "w"
<
			":execute" 可以用来把命令附加到不能接受 '|' 的命令后
			面。比如: >
		:execute '!ls' | echo "theend"

+-*/+-*/exists f 检查变量，函数等是否存在
exists({expr})	返回数值，如果 {expr} 被定义，返回非零，不然返回零。{expr} 参
		数是字符串，可以使用以下选择之一:
			&option-name	Vim 选项 (只检查是否存在，而不是是否工
					作)
			+option-name	能工作的 Vim 选项。
			$ENVNAME	环境变量 (也可以通过和空字符串比较完
					成)
			*funcname	内建函数 (见 |functions|) 或者用户定义
					的函数 (见 |user-functions|)。
			varname		内部变量 (见 |internal-variables|)。也
					适用于 |curly-braces-names|、
					|Dictionary| 项目、|List| 项目等等。
					小心计算索引时可能会因为非法的表达式产
					生错误信息。例如: >
					   :let l = [1, 2, 3]
					   :echo exists("l[5]")
<					   0 >
					   :echo exists("l[xx]")
<					   E121: Undefined variable: xx
					   0

			:cmdname	Ex 命令: 内建命令、用户命令或者命令修
					饰符 |:command|。
					返回:
					1  匹配命令的开始
					2  完整匹配命令
					3  匹配多个用户命令
					要检查命令是否支持，检查返回值是否为
					2。
			:2match		|:2match| 命令。
			:3match		|:3match| 命令。
			#event		符合此事件的自动命令
			#event#pattern	符合此事件和此模式的自动命令 (模式按本
					义出现，和自动命令的模式逐字符比较)
			#group		存在自动命令组
			#group#event	在该组里定义并符合此事件的自动命令。
			#group#event#pattern
					为该组定义、符合事件和模式的自动命令。
			##event		支持此事件的自动命令。
		要检查某特性是否支持，用 |has()|。

		例如: >
			exists("&shortname")
			exists("$HOSTNAME")
			exists("*strftime")
			exists("*s:MyFunc")
			exists("bufcount")
			exists(":Make")
			exists("#CursorHold")
			exists("#BufReadPre#*.gz")
			exists("#filetypeindent")
			exists("#filetypeindent#FileType")
			exists("#filetypeindent#FileType#*")
			exists("##ColorScheme")
<		符号 (&/$/*/#) 和名字之间不能有空格。
		名字之后不能有附加字符，虽然现在有一些情况下会忽略这些字符，但
		将来的检查可能更严格。所以不要依赖此行为！
		可以通过的例子: >
			exists(":make")
<		_不_能通过的例子: >
			exists(":make install")

<		注意 参数必须是字符串，不是变量的名字本身。例如: >
			exists(bufcount)
<		不检查 "bufcount" 变量是否存在，而是提取 "bufcount" 的值，并检
		查其 (根据此处的语法) 是否存在。


+-*/+-*/getpid f 得到 Vim 的进程号
getpid()	返回数值，即 Vim 进程的进程号。Unix 和 MS-Windows 上这是个唯一
		的数值，直到 Vim 退出为止。MS-DOS 上该值总为零。

							*getpos()*
+-*/+-*/lazyredraw o 执行宏时不重画
			*'lazyredraw'* *'lz'* *'nolazyredraw'* *'nolz'*
'lazyredraw' 'lz'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
	如果置位本选项，执行宏、寄存器和其它不通过输入的命令时屏幕不会重画。另
	外，窗口标题的刷新也被推迟。要强迫刷新，使用 |:redraw|。


+-*/+-*/libcall f 调用一个外部库函数
libcall({libname}, {funcname}, {argument})
		在运行库 {libname} 里调用函数 {funcname} 并给出单个参数
		{argument}。
		这可以用于调用库里的函数，尤其是 Vim 里用到的那些。因为只能使
		用单个参数，所以可以调用的标准库函数相当有限。
		结果是函数返回的字符串。如果函数返回 NULL，在 Vim 里会以空字符
		串 "" 出现。
		如果函数返回数值，请使用 |libcallnr()|！
		如果 {argument} 是数值，它以 int 类型传给函数；如果 {argument}
		是字符串，它以 null 结尾的字符串类型传入。
		在 |restricted-mode| 里，该函数不能运行。

		libcall() 允许你写自己的 Vim '插件' 扩展，而无须重新编译程序。
		它并_不_是用来调用系统函数的一个方法！如果你试图这么做，Vim 很
		有可能会崩溃。

		Win32 上，你写的函数必须在 DLL 里提供，而且必须使用普通的 C 调
		用惯例 (_不是_ Windows 系统 DLL 使用的 Pascal 惯例)。函数必须
		只能接受单个参数，或者是字符指针，或者是长整数，而且必须返回字
		符指针或者 NULL。返回的字符指针必须指向在函数返回之后仍然指向
		合法的内存 (比如 DLL 的静态区域)。如果指向分配的区域，那么内存
		会发生泄漏。在函数里使用静态缓冲区应该可以，在 DLL 卸载时会被
		释放。

		警 告: 如果函数返回不合法的指针，Vim 会崩溃！如果函数返回数值
		也会发生同样的问题，因为 Vim 把它当作指针看待。
		Win32 系统上，{libname} 必须是不带 ".DLL" 后缀的 DLL 文件名。
		只有 DLL 不在常见的位置的时候，才需要指定完整的路径名。
		Unix 上: 如果编译你自己的插件，记住目标代码必须生成位置无关代
		码 ('PIC')。
		{仅当使用 Win32 和一些 Unix 版本且带有 |+libcall| 特性时才有
		效}
		例如: >
			:echo libcall("libc.so", "getenv", "HOME")
<
							*libcallnr()*
+-*/+-*/libcallnr f 同上，但返回一个数值
libcallnr({libname}, {funcname}, {argument})
		和 |libcall()| 类似，但函数返回 int，而不是字符串。
		{仅当使用 Win32 和一些 Unix 版本且带有 |+libcall| 特性时才有
		效}
		例如: >
			:echo libcallnr("/usr/lib/libc.so", "getpid", "")
			:call libcallnr("libc.so", "printf", "Hello World!\n")
			:call libcallnr("libc.so", "sleep", 10)
<
							*line()*
+-*/+-*/maxfuncdepth o 用户函数的最大递归深度
						*'maxfuncdepth'* *'mfd'*
'maxfuncdepth' 'mfd'	数值型	(缺省为 100)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+eval| 特性才有效}
	用户函数的最大函数调用层数。通常用于捕获无限递归。如果使用需要更多深度
	的递归函数，把 'maxfuncdepth' 设大一点。不过这意味着需要更多内存，从而
	需要冒内存不足的风险。另见 |:function|。


+-*/+-*/maxmapdepth o 映射的最大递归深度
						*'maxmapdepth'* *'mmd'* *E223*
'maxmapdepth' 'mmd'	数值型	(缺省为 1000)
			全局
			{Vi 无此功能}
	最大次数的映射次数，在此期间必须使用一个字符。通常用于捕获无限映射。比
	如 ":map x y" 又 ":map y x"。它仍然不能捕获 ":map g wg"，因为在下一个
	映射完成之前，已经使用了 'w'。另见 |key-mapping|。


+-*/+-*/noautocmd c 跟随的命令不激活自动命令
							*:noautocmd* *:noa*
要为单个命令屏蔽自动命令，使用 ":noautocmd" 命令修饰符。它会在下一个命令的执行
期间把 'eventignore' 设为 "all"。例如: >

+-*/+-*/normal c 执行普通模式的命令
:norm[al][!] {commands}					*:norm* *:normal*
			执行若干普通模式命令 {commands}。这使得在命令行上执行
			普通模式命令成为可能。{commands} 的执行就像从键盘输入
			那样。撤销命令会撤销所有的命令。
			如果发生错误，结束执行。
			如果给出 [!]，不使用映射。
			{commands} 必须是完整的命令。如果 {commands} 没有完整
			给出一个命令，未完成的最后那个命令会被终止，如同键入了
			<Esc> 或 <C-C> 一样。":normal" 还在工作的时候，显示不
			会被刷新。这意味着插入命令也必须完整 (要开始插入模式，
			见 |:startinsert|)。":" 命令也必须完整。而且你不能用
			"Q" 或 "gQ" 启动 Ex 模式。
			{commands} 不能以空格开始，如果要，前面加个计数 1
			(一)。"1 " 就是一个空格。
			{commands} 里忽略 'insertmode' 选项。
			该命令后面不能跟其他命令。因为任何 '|' 都被认为是命令
			的一部分。
			该命令可以递归使用，但是深度不能超过 'maxmapdepth'。
			如果一个不可重新映射的映射 |:noremap| 调用该命令，它的
			参数就因而还是有可能被重新映射。
			一个替代的方法是 |:execute|，它可以用表达式作为参数。
			这样就可使用可显示字符来代表特殊字符。
			例如: >
				:exe "normal \<c-w>\<c-w>"
<			{Vi 当然无此功能}
			{仅当编译时加入 |+ex_extra| 特性才可用}

+-*/+-*/profdel c 停止剖视 (profile) 函数或脚本
:profd[el] ...						*:profd* *:profdel*
		停止对指定参数的刨视，|:breakdel| 说明其中的参数。

+-*/+-*/profile c 剖视 (profile) 函数或脚本
:prof[ile] start {fname}			*:prof* *:profile* *E750*
		启动刨视，退出时把结果写到 {fname} 文件。如果 {fname} 已存在，
		安静地覆盖它。变量 |v:profiling| 设为一。

+-*/+-*/redir c 重定向消息到文件或者寄存器
							*:redi* *:redir*
:redi[r][!] > {file}	重定向消息到文件 {file}。将命令的输出消息写到该文件，
			直到重定向结束。消息也同时显示在屏幕上。如果有 [!]，覆
			盖已存在的文件。如果没有但文件 {file} 存在，该命令会失
			败。
			一次只能激活一个 ":redir"。也就是，调用 ":redir" 开始
			重定向到新的目标之前，任何已激活的重定向都会被关闭。
			如果不想在屏幕上显示消息或者命令的回显，在函数里调用命
			令，以 ":silent call Function()" 方式调用该函数。
			一个替代方案是使用 'verbosefile' 选项，它也可以和
			":redir" 组合使用。
			{Vi 无此功能}

+-*/+-*/redraw c 强迫显示的重画
							*:redr* *:redraw*
:redr[aw][!]		立即重画屏幕。如果有 !，先清屏。
			这对在执行脚本或函数的中间要刷新屏幕，或者在置位了
			'lazyredraw' 而执行映射的过程中间都有用。

+-*/+-*/redrawstatus c 强迫状态行的重画
						*:redraws* *:redrawstatus*
:redraws[tatus][!]	重画当前窗口的状态行。如果有 !，重画所有的状态行。它适
			用于 'statusline' 包含有不能自动更新项目的时候。

+-*/+-*/runtime c 执行 'runtimepath' 里的 vim 脚本
							*:ru* *:runtime*
:ru[ntime][!] {file} ..
			从 'runtimepath' 指定的目录里查找 {file}。从匹配的文件
			里读取 Ex 命令。如果没有匹配的文件，不报错。例如: >
				:runtime syntax/c.vim

+-*/+-*/scriptencoding c 执行过的 Vim 脚本使用的编码
:scripte[ncoding] [encoding]		*:scripte* *:scriptencoding* *E167*
			指定脚本使用的字符编码。后续以 [encoding] 编码的脚本行
			会被转换成 'encoding' 选项所指定的编码，如果两者不同的
			话。如: >
				scriptencoding iso-8859-5
				scriptencoding cp932
<
			如果 [encoding] 为空，则不作任何转换。这可以用来避免对
			一些行进行转换: >
				scriptencoding euc-jp
				... 被转换的行 ...
				scriptencoding
				... 不被转换的行 ...

+-*/+-*/scriptnames c 列出所有执行过的 Vim 脚本的名字
						*:scrip* *:scriptnames*
:scrip[tnames]		列出所有执行过的脚本名字，以它们初次执行之顺序排列。排
			列的次序号码被用作相应的脚本 ID |<SID>|。
			{Vi 无此功能} {仅当编译时加入 |+eval| 特性才有功能}

+-*/+-*/sleep c 几秒内不作任何事
[N]gs							*gs* *:sl* *:sleep*
:[N]sl[eep] [N]	[m]	停止 (睡眠) [N] 秒。如果有 [m]，停止 [N] 毫秒。"gs" 前
			的计数总是表示秒数。缺省值是 1 秒。 >
			     :sleep	     "睡眠一秒
			     :5sleep	     "睡眠五秒
			     :sleep 100m     "睡眠一百毫秒
			     10gs	     "睡眠十秒
<			可以被 CTRL-C (MS-DOS 上的 CTRL-Break) 中断。
			"gs" 代表 "goto sleep"。
			睡眠时如果在可见位置的话，光标定位于文本处。
			{Vi 无此功能}

+-*/+-*/source c 从文件里读取 Vim 或 Ex 命令
					*:so* *:source* *load-vim-script*
:so[urce] {file}	从 {file} 里读取 Ex 命令，即 ":" 开头的命令，并执行。
			激活 |SourcePre| 自动命令。

+-*/+-*/writedelay o 每个字符延迟 (以毫秒计) (用于调试)
						*'writedelay'* *'wd'*
'writedelay' 'wd'	数值型	(缺省为 0)
			全局
			{Vi 无此功能}
	等待每个字符发送到屏幕的微秒数。如果非零，字符被一个一个地发送到终端。
	不适用于 MS-DOS pcterm。此选项为调试所设。


+-*/+-*/input _ 输入
+-*/+-*/+-*/feedkeys f 把字符放到预输入队列中
feedkeys({string} [, {mode}])				*feedkeys()*
		将 {string} 里的字符放在队列里等候处理，就像它们来自映射或者用
		户输入一样。它们加在预输入 (typeahead) 缓冲区的尾端，所以如果
		仍然在执行映射，这些字符出现在映射内容之后。
		该函数不会等待 {string} 包含的键处理完毕。
		{string} 如果要包含特殊键，可以使用双引号和 "\..." 记法
		|expr-quote|。例如，feedkeys("\<CR>") 会模拟 <Enter> 键击。但
		feedkeys('\<CR>') 却实际压入五个字符。
		如果不给出 {mode}，这些键会经过重映射。
		{mode} 是字符串，包含以下字符标志位:
		'm'	对键重映射。缺省。
		'n'	不对键重映射。
		't'	像用户输入那样处理键；如果不包含，像来自映射一样处理。
			这会影响撤销、打开折叠等行为。
		返回值总为 0。


+-*/+-*/+-*/getchar f 从用户那里取得一个字符输入
getchar([expr])						*getchar()*
		从用户或输入流中提取单个字符。
		如果忽略 [expr]，等待直到有字符输入为止。
		如果 [expr] 为 0，只有在有字符可用时才取得字符，否则返回零。
		如果 [expr] 为 1，只检查是否有字符可用，并不消耗该字符。如果没
				  有字符，返回零。

		如果没有 {expr} 或者 {expr} 为零，返回整个字符或者特殊键。如果
		是 8 位字符，以数值形式返回。用 nr2char() 把它转化成字符串。否
		则返回经过编码的字符构成的字符串。如果是特殊键，返回一串字节，
		以 0x80 (十进制: 128) 开始。它和字符串 "\<Key>" 等值，例如
		"\<Left>"。如果用带修饰符 (Shift，Control， Alt) 的字符而字符
		本身不包含该修饰符时，返回值也用字符串类型。

		如果 {expr} 为 1，只返回第一个字节。如果是单字节字符，返回的就
		是该字符自身的数值形式。用 nr2char() 把它转化为字符串。

		用户点击鼠标时，返回鼠标事件。所在的位置可以在 |v:mouse_col|、
		|v:mouse_lnum| 和 |v:mouse_win| 里找到。下例用通常的处理方法定
		位鼠标: >
			let c = getchar()
		  	if c == "\<LeftMouse>" && v:mouse_win > 0
			  exe v:mouse_win . "wincmd w"
			  exe v:mouse_lnum
			  exe "normal " . v:mouse_col . "|"
			endif
<
		There is no prompt, you will somehow have to make clear to the
		user that a character has to be typed.
		There is no mapping for the character.
		Key codes are replaced, thus when the user presses the <Del>
		key you get the code for the <Del> key, not the raw character
		sequence.  Examples: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		This example redefines "f" to ignore case: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction

		这里没有提示，你需要想办法告诉用户，需要输入一个字符。
		字符不通过映射。
		键码被替换。因而，用户输入 <Del> 键时，你得到 <Del> 的键码，而
		不是原始的字符序列。比如: >
			getchar() == "\<Del>"
			getchar() == "\<S-Left>"
<		下例重新定义 "f"，使它忽略大小写: >
			:nmap f :call FindChar()<CR>
			:function FindChar()
			:  let c = nr2char(getchar())
			:  while col('.') < col('$') - 1
			:    normal l
			:    if getline('.')[col('.') - 1] ==? c
			:      break
			:    endif
			:  endwhile
			:endfunction


+-*/+-*/+-*/getcharmod f 取得最近键入字符的修饰符
getcharmod()						*getcharmod()*
		返回数值，反映最近用 getchar() 或其它方式输入字符的修饰符状
		态。这些值可以相加:
			2	Shift
			4	Control
			8	Alt (Meta)
			16	鼠标双击
			32	鼠标三击
			64	鼠标四击
			128	仅限于 Macintosh: command
		只有没有包含字符本身的修饰符被返回。因而，Shift-a 产生没有修饰
		符的 "A"。


+-*/+-*/+-*/input f 从用户那里取得一行输入
input({prompt} [, {text} [, {completion}]])		*input()*
		返回字符串，即用户在命令行上的输入内容，可以为任何值。参数
		{prompt} 或者是一个提示字符串，或者是一个空白字符串 (没有提
		示)。'\n' 可以在提示里使用，以开始新行。
		该提示使用 |:echohl| 设置的高亮。
		输入方法和命令行相似，也使用相同的编辑命令和映射。但 input()
		输入的行使用另外的历史。
		示例: >
			:if input("咖啡还是啤酒？") == "啤酒"
			:  echo "干杯！"
			:endif
<
		如果给出可选的 {text} 参数，它被用作缺省的回答，就像是用户输入
		的那样。例如: >
			:let color = input("Color? ", "white")

<		可选的 {completion} 参数指定输入支持的补全类型。如果不给出，不
		使用补全。支持的补全类型和用户定义命令用 "-complete=" 参数能给
		出的类型相同。详情见 |:command-completion|。例如: >
			let fname = input("File: ", "", "file")
<
		注意: 在只能运行于 GUI 模式的版本里 (比如 Win32 GUI)，此函数不
		能在启动文件里使用。
		注意: input() 在映射里调用时，它会消耗该映射余下的字符，因为映
		射的处理就像那些字符被键盘输入一样。在 input() 前使用
		|inputsave()| 然后在 input() 输入之后 |inputrestore()| 可以避
		免这一点。另一个方法是避免在映射的后面提供任何字符，比如，使用
		|:execute| 或 |:normal|。

		使用映射的例子: >
			:nmap \x :call GetFoo()<CR>:exe "/" . Foo<CR>
			:function GetFoo()
			:  call inputsave()
			:  let g:Foo = input("enter search pattern: ")
			:  call inputrestore()
			:endfunction


+-*/+-*/+-*/inputdialog f 从用户那里取得一行输入，使用对话框
inputdialog({prompt} [, {text} [, {cancelreturn}]])		*inputdialog()*
		类似于 |input()|，但如果运行 GUI 且支持文本对话框，弹出一个对
		话框窗口来输入文本。
		例如: >
			:let n = inputdialog("value for shiftwidth", &sw)
			:if n != ""
			:  let &sw = n
			:endif
<		如果对话框被取消，返回 {cancelreturn}。如果忽略，返回空字符
		串。
		输入 <Enter> 和按 OK 按钮相同。按 <Esc> 和按 Cancel 按钮相同。
		备注: 不支持命令行补全。


+-*/+-*/+-*/inputlist f 让用户从列表里选择一个项目
inputlist({textlist})					*inputlist()*
		{textlist} 必须是字符串的 |List|。显示此 |List|，每个字符串一
		行。用户得到提示要输入一个数值，返回此值。
		用户也可以用鼠标点击项目来进行选择。第一个字符串返回 0。在第一
		个项目之上点击返回负数。在提示行上点击返回 {textlist} 的长度加
		一。
		确保 {textlist} 不超过 'lines' 个项目，否则无法使用。建议把项
		目编号放在每个字符串的开始处，并在第一项上加上提示。例如: >
			let color = inputlist(['Select color:', '1. red',
				\ '2. green', '3. blue'])


+-*/+-*/+-*/inputrestore f 恢复预输入 (译注：参阅 input())
inputrestore()						*inputrestore()*
		恢复前一个 |inputsave()| 保存的预输入。应该和 |inputsave()| 调
		用的次数相同，不过调用更多次也无妨。
		如果没有可以恢复的，返回 1，不然返回 0。


+-*/+-*/+-*/inputsave f 保存和清除预输入 (typeahead)
inputsave()						*inputsave()*
		保存预输入 (也包括映射的) 并清除之，使得下一个提示能从用户得到
		输入。在提示之后应该跟上配套的 inputrestore()。可以多次使用，
		此时应该有同样多次的 inputrestore() 调用。
		如果内存不足，返回 1，不然返回 0。


+-*/+-*/+-*/inputsecret f 从用户那里取得一行输入，不回显
inputsecret({prompt} [, {text}])			*inputsecret()*
		该函数和 |input()| 函数类似，但有两个例外:
		a) 用户的应答显示为一串星号 ("*")，从而输入可以保密，还有
		b) 用户的应答不会记录在输入 |history| 栈中。
		返回字符串，即用户在命令行上根据提示输入的应答。
		备注: 不支持命令行补全。


+-*/+-*/list _ 列表
+-*/+-*/+-*/add f 在列表后附加项目
add({list}, {expr})					*add()*
		在 |List| {list} 最后附加项目 {expr}。返回新产生的 |List|。例
		如: >
			:let alist = add([1, 2, 3], item)
			:call add(mylist, "woodstock")
<		注意 如果 {expr} 是 |List|，它被作为单个项目附加进去。
		|extend()| 可以用来连接 |List|。
		|insert()| 可以用来把一个项目加到其它的位置上。


+-*/+-*/+-*/call f 调用函数，参数以列表形式提供
call({func}, {arglist} [, {dict}])			*call()* *E699*
		调用函数 {func}，使用 |List| {arglist} 项目作为参数。
		{func} 可以是 |Funcref| 或函数名。
		a:firstline 和 a:lastline 设为当前行。
		返回调用的函数的结果。
		{dict} 用于为函数指定 "dict" 属性。其目的是设置局部变量
		"self"。|Dictionary-function|


+-*/+-*/+-*/copy f 建立列表的浅备份
copy({expr})	构造 {expr} 的备份。对数值和字符串而言，这和直接使用 {expr}
		并无不同。
		如果 {expr} 是 |List|，建立一个浅备份。这意味着，原来的 |List|
		可以被改变，而不会影响新建的备份。反之亦然。不过，其中的项目只
		有一份，所以修改项目同时修改两个 |List| 的内容。另见
		|deepcopy()|。


+-*/+-*/+-*/count f 计算列表里某值的出现次数
count({comp}, {expr} [, {ic} [, {start}]])			*count()*
		返回 |List| 或 |Dictionary| {comp} 里值为 {expr} 的项目出现的
		次数。
		如果给出 {start}，从该索引指定的项目开始。{start} 只能用于
		|List|。
		如果给出 {ic} 并且非零，忽略大小写。


							*cscope_connection()*
+-*/+-*/+-*/deepcopy f 建立列表的完整备份
deepcopy({expr}[, {noref}])				*deepcopy()* *E698*
		构造 {expr} 的备份。对数值和字符串而言，这和直接使用 {expr}
		并无不同。
		如果 {expr} 是 |List|，建立一个完整的备份。这意味着，原来的
		|List| 可以被改变，而不会影响新建的备份。反之亦然。如果某个项
		目是 |List|，递归地建立它的备份。这样，备份里项目的修改也不会
		影响到原来 |List| 的内容。
		如果省略 {noref} 或为零，包含的 |List| 或 |Dictionary| 只复制
		一次。所有指向它的引用指向此一备份。如果 {noref} 设为 1，每次
		|List| 或 |Dictionary| 的出现会导致建立一个新的备份。这意味着
		循环引用会使得 deepcopy() 失败。
								*E724*
		嵌套可达 100 层。如果有指向较高层的引用，{noref} 为 1 的深备份
		会失败。
		另见 |copy()|。


+-*/+-*/+-*/empty f 检查列表是否为空
empty({expr})						*empty()*
		如果 {expr} 为空，返回数值 1，否则返回 0。
		|List| 或 |Dictionary| 没有项目时为空。数值的值为零时为空。
		如果 |List| 很大，这比把长度和零比较要快得多。


+-*/+-*/+-*/extend f 在列表后附加另一个列表
extend({expr1}, {expr2} [, {expr3}])			*extend()*
		{expr1} 和 {expr2} 必须都是 |List| 或者都是 |Dictionary|。

		如果都是 |List|: 把 {expr2} 附加到 {expr1} 之后。
		如果给出 {expr3}，把 {expr2} 里的项目加到 {expr1} 的第 {expr3}
		个项目之前。如果 {expr3} 为零，插在第一个项目之前。如果
		{expr3} 等于 len({expr1})，那么 {expr2} 会附加在最后。
		例如: >
			:echo sort(extend(mylist, [7, 5]))
			:call extend(mylist, [2, 3], 1)
<		如果 {expr1} 和 {expr2} 是同一个列表，复制的项目数等于列表原来
		的长度。例如，如果 {expr} 为 1，则复制列表首值 N 次 (N 是列表
		原来的长度)。
		用 |add()| 把一个项目加入列表。要连接两个列表成为一个新列表，
		用 + 操作符: >
			:let newlist = [1, 2, 3] + [4, 5]
<
		如果都是 |Dictionary|: 把 {expr2} 里的所有项目加入 {expr1}。
		如果 {expr1} 和 {expr2} 包含相同的键，那么 {expr3} 决定应该怎
		么做:
		{expr3} = "keep": 保持 {expr1} 的值
		{expr3} = "force": 使用 {expr2} 的值
		{expr3} = "error": 给出错误信息				*E737*
		如果省略 {expr3}，假设使用 "force"。

		只要 {expr2} 非空，{expr1} 就被改变。如果需要，给 {expr1} 先做
		个备份。
		{expr2} 保持不变。
		返回 {expr1}。



+-*/+-*/+-*/filter f 删除列表的选定项目
filter({expr}, {string})					*filter()*
		{expr} 必须是 |List| 或者 |Dictionary|。
		对 {expr} 里的每个项目计算 {string}，如果结果为零，从该 |List|
		或 |Dictionary| 里删除该项目。
		{string} 计算时，|v:val| 包含当前项目的值。
		|Dictionary| 中 |v:key| 也包含当前项目的键。
		例如: >
			:call filter(mylist, 'v:val !~ "OLD"')
<		删除所有出现 "OLD" 的项目。 >
			:call filter(mydict, 'v:key >= 8')
<		删除所有键小于 8 的值。 >
			:call filter(var, 0)
<		删除所有的值，从而清除该 |List| 或 |Dictionary|。



+-*/+-*/+-*/get f 得到项目，错误的键不报错
get({list}, {idx} [, {default}])			*get()*
		获取 |List| {list} 的第 {idx} 个项目。如果不存在此项目，返回
		{default}。如果省略 {default}，返回零。
get({dict}, {key} [, {default}])
		获取 |Dictionary| {dict} 键为 {key} 的项目。如果不存在此项目，
		返回 {default}。如果省略 {default}，返回零。

							*getbufline()*
+-*/+-*/+-*/has_key f 检查某键是否出现在字典里
has_key({dict}, {key})					*has_key()*
		返回数值，如果 |Dictionary| {dict} 有键为 {key} 的项目则为 1，
		不然为零。


+-*/+-*/+-*/index f 列表里某值的索引
index({list}, {expr} [, {start} [, {ic}]])			*index()*
		返回 |List| {list} 里值等于 {expr} 的最小项目索引。这里不进行
		自动转换，字符串 "4" 不同于数值 4，数值 4 也不等同于浮点数
		4.0。'ignorecase' 的值此处也不适用，大小写不忽略。
		如果给出 {start}，从索引为 {start} 的项目开始寻找 (可以为负，
		指定相对于尾部的项目)。
		如果给出 {ic} 且非零，忽略大小写。否则，必须匹配大小写。
		如果在 {list} 里找不到 {expr}，返回 -1。
		示例: >
			:let idx = index(words, "the")
			:if index(numbers, 123) >= 0



+-*/+-*/+-*/insert f 在列表某处插入项目
insert({list}, {item} [, {idx}])			*insert()*
		在 |List| {list} 的开始处插入 {item}。
		如果指定 {idx}，{item} 的插入位置在索引 {idx} 之前。如果
		{idx} 为零，插入在第一个项目之前，和省略 {idx} 效果相同。也可
		用负的 {idx}，见 |list-index|。-1 插入在最后一个项目之前。
		返回新产生的 |List|。例如: >
			:let mylist = insert([2, 3, 5], 1)
			:call insert(mylist, 4, -1)
			:call insert(mylist, 6, len(mylist))
<		用 |add()| 可以更简单的完成最后一个例子。
		注意 如 {item} 是 |List|，它被作为单个项目来插入。 |extend()|
		用来连接多个 |List|。


+-*/+-*/+-*/items f 得到字典的键-值组对的列表
items({dict})						*items()*
		返回 |List|，{dict} 的所有键-值组对。每个 |List| 项目是两个项
		目的列表: {dict} 项目的键和此项目的值。|List| 项目的顺序不定。



+-*/+-*/+-*/join f 合并列表项目成为字符串
join({list} [, {sep}])					*join()*
		连接所有 {list} 项目成为字符串。
		如果指定 {sep}，该分隔符出现在项目之间。如果省略 {sep}，用单个
		空格。
		注意 尾部不加 {sep}。如果你坚持要加入: >
			let lines = join(mylist, "\n") . "\n"
<		字符串项目照原样使用。用类似 |string()| 的方式把 |List| 和
		|Dictionary| 转化为字符串。
		逆函数是 |split()|。


+-*/+-*/+-*/keys f 得到字典的键列表
keys({dict})						*keys()*
		返回 |List|，{dict} 的所有键。|List| 项目的顺序不定。

							*len()* *E701*
+-*/+-*/+-*/len f 列表的项目总数
len({expr})	返回数值，参数的长度。
		如果 {expr} 为字符串或数值，返回它使用的字节数，和 |strlen()|
		相同。
		如果 {expr} 为 |List|，返回 |List| 的项目数量。
		如果 {expr} 为 |Dictionary|，返回 |Dictionary| 的项目数量。
		否则给出错误。

						*libcall()* *E364* *E368*
+-*/+-*/+-*/map f 改变每个列表项目
map({expr}, {string})					*map()*
		{expr} 必须是 |List| 或 |Dictionary|。
		{expr} 里的每个项目被 {string} 的计算结果替代。
		在 {string} 里，|v:val| 包含当前项目的值。
		对 |Dictionary| 而言，|v:key| 也包含当前项目的键。
		对 |List| 而言，|v:key| 包含当前项目的索引。
		例如: >
			:call map(mylist, '"> " . v:val . " <"')
<		"mylist" 里的每个项目之前放上 "> "，而之后放上 " <"。

		注意 {string} 是表达式的计算结果，而它本身又用作表达式。通常，
		最好用 |literal-string| 来避免反斜杠加倍。当然，你仍然需要加倍
		' 引号。

		本操作直接修改输入。如果你不希望修改 |List| 或 |Dictionary|，
		先构建一个备份: >
			:let tlist = map(copy(mylist), ' & . "\t"')

<		返回 {expr}，过滤过的 |List| 或 |Dictionary|。
		如果 {string} 计算时有错误，{expr} 的其余项目不再处理。



+-*/+-*/+-*/max f 列表项目的最大值
max({list})	返回 {list} 所有项目的最大值。
		如果 {list} 不是列表，或者其中某个项目不能用作数值，出错。
		空 |List| 返回零。

							*min()*
+-*/+-*/+-*/min f 列表项目的最小值
min({list})	返回 {list} 所有项目的最小值。
		如果 {list} 不是列表，或者其中某个项目不能用作数值，出错。
		空 |List| 返回零。

							*mkdir()* *E739*
+-*/+-*/+-*/range f 返回数值序列的列表
range({expr} [, {max} [, {stride}]])				*range()*
		返回数值的 |List|:
		- 如果只有指定 {expr}: [0, 1, ..., {expr} - 1]
		- 如果指定了 {max}: [{expr}, {expr} + 1, ..., {max}]
		- 如果指定了 {stride}: [{expr}, {expr} + {stride}, ...,
		  {max}] (每次给 {expr} 递增 {stride}，但不会产生超过 {max} 的
		  值)。
		如果最大值比开始值小一，返回空列表。如果更小，报错。
		例如: >
			range(4)		" [0, 1, 2, 3]
			range(2, 4)		" [2, 3, 4]
			range(2, 9, 3)		" [2, 5, 8]
			range(2, -2, -1)	" [2, 1, 0, -1, -2]
			range(0)		" []
			range(2, 0)		" 出错！
<
							*readfile()*
+-*/+-*/+-*/remove f 删除列表里一或多个项目
remove({list}, {idx} [, {end}])				*remove()*
		没有 {end}: 删除 |List| {list} 里索引为 {idx} 的项目并返回之。
		有 {end}: 删除从 {idx} 到 {end} (包含) 的项目，并返回这些项目
		的列表。如果 {idx} 指向和 {end} 相同的项目，返回单个项目的列
		表。如果 {end} 指向 {idx} 之前的项目，报错。
		|list-index| 说明 {idx} 和 {end} 可能的取值。
		例如: >
			:echo "last item: " . remove(mylist, -1)
			:call remove(mylist, 0, 9)
remove({dict}, {key})
		删除 {dict} 里键为 {key} 的项目。例如: >
			:echo "removed " . remove(dict, "one")
<		如果 {dict} 里没有键 {key}，报错。

		|delete()| 用来删除文件。


+-*/+-*/+-*/reverse f 反转列表项目的顺序
reverse({list})	反转 {list} 项目的顺序，直接对 {list} 进行修改。返回 {list}。
		如果你不想修改列表，先构建一个备份: >
			:let revlist = reverse(copy(mylist))


+-*/+-*/+-*/sort f 给列表排序
sort({list} [, {func}])					*sort()* *E702*
		给 {list} 项目排序，直接修改列表。返回 {list}。如果你不想修改
		列表，先构建一个备份: >
			:let sortedlist = sort(copy(mylist))
<		每个项目使用字符串表示形式进行排序。
		数值排在字符串之后，|Lists| 排在数值之后。
		要给当前缓冲区的文本排序，用 |:sort|。
		如果给出 {func} 且为一，忽略大小写。
		如果 {func} 为 |Funcref| 或函数名，调用该函数来比较项目。函数
		调用时使用两个项目作为参数，函数返回时，0 代表相等，1 或更高代
		表第一个排在第二个之后，-1 或更小代表第一个排在第二个之前。
		例如: >
			func MyCompare(i1, i2)
			   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1
			endfunc
			let sortedlist = sort(mylist, "MyCompare")
<		对这个简单的例子，有更简短的一个比较版本，不考虑溢出情况: >
			func MyCompare(i1, i2)
			   return a:i1 - a:i2
			endfunc
<

							*soundfold()*
+-*/+-*/+-*/split f 分割字符串成为列表
split({expr} [, {pattern} [, {keepempty}]])			*split()*
		从 {expr} 构造 |List|。
		如果 {pattern} 省略或为空，用每个空白分隔的字符序列构造一个项
		目。否则，在匹配 {pattern} 的地方分割字符串，删除匹配部分的字
		符。
		如果列表的首末项目为空，省略它们，除非 {keepempty} 参数给出且
		非零。其它空项目在 {pattern} 匹配至少一个字符或者 {keepempty}
		非零的时候被保留。
		例如: >
			:let words = split(getline('.'), '\W\+')
<		要把字符串分割到每个字符: >
			:for c in split(mystring, '\zs')
<		如果你想保留分隔符，可以用 '\zs': >
			:echo split('abc:def:ghi', ':\zs')
<			['abc:', 'def:', 'ghi'] ~
		分割首项可能为空的表格: >
			:let items = split(line, ':', 1)
<		逆函数是 |join()|。



+-*/+-*/+-*/string f 列表的字符串表示形式
string({expr})	返回 {expr} 转换后的字符串。如果 {expr} 为数值、浮点数、字符串
		或它们的复合形式，那么用 |eval()| 可以把结果转回去。
			{expr} 类型	返回值 ~
			字符串		'string'
			数值		123
			浮点数		123.123456 或 1.23456e8
			函数引用	function('name')
			列表		[item, item]
			字典		{key: value, key: value}
		注意 字符串的值里 ' 字符加倍。
		另见 |strtrans()|。

							*strlen()*
+-*/+-*/+-*/values f 得到字典的值列表
values({dict})						*values()*
		返回 |List|，{dict} 的所有值。|List| 项目的顺序不定。



+-*/+-*/math _ 数学
+-*/+-*/+-*/abs f 绝对值 (也适用于数值)
abs({expr})							*abs()*
		返回 {expr} 的绝对值。如果 {expr} 计算结果为浮点数，abs() 返回
		浮点数。如果 {expr} 可以转换为数值，abs() 返回数值。否则报错并
		返回 -1。
		示例: >
			echo abs(1.456)
<			1.456  >
			echo abs(-5.456)
<			5.456  >
			echo abs(-4)
<			4
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/acos f 反余弦
acos({expr})							*acos()*
		返回以弧度表示的 {expr} 的反余弦值，返回值为 [0, pi] 区间内的
		浮点数。
		{expr} 的计算结果必须是 [-1, 1] 区间内的浮点数或数值。
		示例: >
			:echo acos(0)
<			1.570796 >
			:echo acos(-0.5)
<			2.094395
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/asin f 反正弦
asin({expr})						*asin()*
		返回以弧度表示的 {expr} 的反正弦值，返回值为 [-pi/2, pi/2] 区
		间内的浮点数。
		{expr} 的计算结果必须是 [-1, 1] 区间内的浮点数或数值。
		示例: >
			:echo asin(0.8)
<			0.927295 >
			:echo asin(-0.5)
<			-0.523599
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/atan f 反正切
atan({expr})						*atan()*
		返回 {expr} 反正切的主值，返回值为 [-pi/2, +pi/2] 区间内的弧度
		值浮点数。
		{expr} 计算结果必须为浮点数或数值。
		示例: >
			:echo atan(100)
<			1.560797 >
			:echo atan(-4.01)
<			-1.326405
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/atan2 f 反正切
atan2({expr1}, {expr2})					*atan2()*
		返回 {expr1} / {expr2} 的反正切值，以弧度计算，返回值为 [-pi,
		+pi] 区间内的浮点数。
		{expr1} 和 {expr2} 计算结果必须为浮点数或数值。
		示例: >
			:echo atan2(-1, 1)
<			-0.785398 >
			:echo atan2(1, -1)
<			2.356194
		{仅当编译时加入 |+float| 特性才有效}


							*browse()*
+-*/+-*/+-*/ceil f 向上取整
ceil({expr})							*ceil()*
		返回浮点数，即大于等于 {expr} 的最小整数 (向上取整)。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			echo ceil(1.456)
<			2.0  >
			echo ceil(-5.456)
<			-5.0  >
			echo ceil(4.0)
<			4.0
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/cos f 余弦
cos({expr})						*cos()*
		返回浮点数，即以弧度测量的 {expr} 的余弦值。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo cos(100)
<			0.862319 >
			:echo cos(-4.01)
<			-0.646043
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/cosh f 反双曲余弦
cosh({expr})						*cosh()*
		返回 {expr} 的双曲余弦值，返回值为 [1, inf] 区间内的浮点数。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo cosh(0.5)
<			1.127626 >
			:echo cosh(-0.5)
<			-1.127626
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/exp f e为底指数
exp({expr})						*exp()*
		返回 {expr} 的指数函数值，返回值为 [0, inf] 区间内的浮点数。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo exp(2)
<			7.389056 >
			:echo exp(-1)
<			0.367879
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/float2nr f 把浮点数转换为数值
float2nr({expr})					*float2nr()*
		返回数值，即 {expr} 省略小数点部分的结果。
		{expr} 的计算结果必须是浮点数或数值。
		如果 {expr} 的值超出 |Number| 的范围，结果为 0x7fffffff 或
		-0x7fffffff。而 NaN 转换为 -0x80000000。
		示例: >
			echo float2nr(3.95)
<			3  >
			echo float2nr(-23.45)
<			-23  >
			echo float2nr(1.0e100)
<			2147483647  >
			echo float2nr(-1.0e150)
<			-2147483647  >
			echo float2nr(1.0e-100)
<			0
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/floor f 乡下取整
floor({expr})							*floor()*
		返回浮点数，即小于等于 {expr} 的最大整数 (向下取整)。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			echo floor(1.856)
<			1.0  >
			echo floor(-5.456)
<			-6.0  >
			echo floor(4.0)
<			4.0
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/fmod f 浮点数的求余
fmod({expr1}, {expr2})					*fmod()*
		返回 {expr1} / {expr2} 的余数，该除法可能实际无法表达出来。选
		择某整数 i，返回 {expr1} - i * {expr2}，使得如果 {expr2} 非
		零，结果和 {expr1} 同号而绝对值小于 {expr2} 的绝对值。如果
		{expr2} 为零，返回零。返回值为浮点数。
		{expr1} 和 {expr2} 的计算结果必须是浮点数或数值。
		示例: >
			:echo fmod(12.33, 1.22)
<			0.13 >
			:echo fmod(-12.33, 1.22)
<			-0.13
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/log f e为底自然对数
log({expr})						*log()*
		返回浮点数，即浮点数 {expr} 的自然对数 (即以 e 为底)。
		{expr} 计算结果必须为 (0, inf] 区间内的浮点数或数值。
		示例: >
			:echo log(10)
<			2.302585 >
			:echo log(exp(5))
<			5.0
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/log10 f 以 10 为底的对数
log10({expr})						*log10()*
		返回浮点数，即浮点数 {expr} 以 10 为底的对数。
		{expr} 计算结果必须为浮点数或数值。
		示例: >
			:echo log10(1000)
<			3.0 >
			:echo log10(0.01)
<			-2.0
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/pow f x 的 y 次方
pow({x}, {y})						*pow()*
		返回浮点数，即 {x} 的 {y} 次方。
		{x} 和 {y} 的计算结果必须是浮点数或数值。
		示例: >
			:echo pow(3, 3)
<			27.0 >
			:echo pow(2, 16)
<			65536.0 >
			:echo pow(32, 0.20)
<			2.0
		{仅当编译时加入 |+float| 特性才有效}
		

+-*/+-*/+-*/round f 四舍五入
round({expr})							*round()*
		返回浮点数，即最接近于 {expr} 的整数。如果 {expr} 在两个整数的
		正中间，使用 (译者注: 绝对值) 较大 (远离零的) 那个。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			echo round(0.456)
<			0.0  >
			echo round(4.5)
<			5.0 >
			echo round(-4.5)
<			-5.0
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/sin f 正弦
sin({expr})						*sin()*
		返回浮点数，即以弧度测量的 {expr} 的正弦值。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo sin(100)
<			-0.506366 >
			:echo sin(-4.01)
<			0.763301
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/sinh f 反双曲正弦
sinh({expr})						*sinh()*
		返回 {expr} 的双曲正弦值，返回值为 [-inf, inf] 区间内的浮点
		数。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo sinh(0.5)
<			0.521095 >
			:echo sinh(-0.9)
<			-1.026517
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/sqrt f 平方根
sqrt({expr})						*sqrt()*
		返回浮点数，即 {expr} 的非负平方根。
		{expr} 的计算结果必须是浮点数或数值。如果 {expr} 为负，返回
		NaN (Not a Number，非数)。
		示例: >
			:echo sqrt(100)
<			10.0 >
			:echo sqrt(-4.01)
<			nan
		"nan" 可能不同，取决于系统库。
		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/tan f 正切
tan({expr})						*tan()*
		返回以弧度测量的 {expr} 的正切值。返回值是 [-inf, inf] 区间内
		的浮点数。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo tan(10)
<			0.648361 >
			:echo tan(-4.01)
<			-1.181502
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/tanh f 反双曲正切
tanh({expr})						*tanh()*
		返回 {expr} 的双曲正切值，返回值为 [-1, 1] 区间内的浮点数。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			:echo tanh(0.5)
<			0.462117 >
			:echo tanh(-1)
<			-0.761594
		{仅当编译时加入 |+float| 特性才有效}


+-*/+-*/+-*/trunc f 删除小数点后的值
trunc({expr})							*trunc()*
		返回浮点数，即绝对值小于等于 {expr} 的最大整数 (向零取整)。
		{expr} 的计算结果必须是浮点数或数值。
		示例: >
			echo trunc(1.456)
<			1.0  >
			echo trunc(-5.456)
<			-5.0  >
			echo trunc(4.0)
<			4.0
		{仅当编译时加入 |+float| 特性才有效}

							*type()*
+-*/+-*/option _ 设置选项
+-*/+-*/+-*/options c 打开选项窗口
:bro[wse] se[t]			*:set-browse* *:browse-set* *:opt* *:options*
:opt[ions]		打开窗口，阅读和设置所有的选项。选项以功能分组。
			提供每个选项简短的帮助。在简短帮助上按 <CR>，会打开帮
			助窗口来提供该选项更多的帮助。
			修改选项的值，然后在 "set" 行上按 <CR> 就会设置新值。
			对于窗口和缓冲区特定的选项，设置的是最近访问窗口里的选
			项值。除非它是帮助窗口，这时使用帮助窗口下方的窗口 (选
			项窗口本身不算)。
			{仅当编译时加入 |+eval| 和 |+autocmd| 特性才有效}

+-*/+-*/+-*/set c 显示或设置选项
							*:se* *:set*
:se[t]			显示所有不同于缺省值的选项。

+-*/+-*/+-*/setglobal c 显示或者设置全局选项值
							*:setg* *:setglobal*
:setg[lobal] ...	类似于 ":set"，但只设置局部选项的全局值，而不改变其局
			部值。
			显示选项时，显示它的全局值。
			如果用 "all" 参数: 显示所有局部选项的全局值。
			如果没有参数: 显示所有不同于缺省的局部选项的全局值。
			{Vi 无此功能}

+-*/+-*/+-*/setlocal c 显示或者设置本地选项值
							*:setl* *:setlocal*
:setl[ocal] ...		类似于 ":set"，但只设置局部于当前缓冲区或者窗口的值。
			不是所有的选项都有局部值的。如果该选项没有局部值，那么
			那么设置全局值。
			如果用 "all" 参数: 显示所有局部选项的局部值。
			如果没有参数: 显示所有不同于缺省的局部选项的局部值。
			显示局部选项时，显示它的局部值。对全局/局部布尔变量，
			如果使用了全局值，在选项名前会显示 "--"。
			全局选项则显示全局值 (将来或许会有所改变)。
			{Vi 无此功能}

+-*/+-*/string _ 字符串
+-*/+-*/+-*/byteidx f 字符串里字符的字节位置
byteidx({expr}, {nr})					*byteidx()*
		返回字符串 {expr} 里第 {nr} 个字符的字节位置。零代表第一个字
		符，此时返回零。
		该函数只对多字节字符有用，不然返回值总是等于 {nr}。
		合成用字符作为单个字符计算。
		例如: >
			echo matchstr(str, ".", byteidx(str, 3))
<		显示第四个字符。另一个方法也能达到相同的效果: >
			let s = strpart(str, byteidx(str, 3))
			echo strpart(s, 0, byteidx(s, 1))
<		如果字符数不足 {nr}，返回 -1。
		如果刚好 {nr} 个字符，返回字符串的长度。


+-*/+-*/+-*/char2nr f 取得字符的 ASCII 码值
char2nr({expr})						*char2nr()*
		返回 {expr} 第一个字符的数值结果。例如: >
			char2nr(" ")		返回 32
			char2nr("ABC")		返回 65
<		使用当前的 'encoding'。比如对 "utf-8" 来说: >
			char2nr("á")		返回 225
			char2nr("á"[0])		返回 195
<		|nr2char()| 是它的逆操作。


+-*/+-*/+-*/escape f 将字符串通过 '\' 转义
escape({string}, {chars})				*escape()*
		在 {string} 里用反斜杠转义 {chars} 里的字符。例如: >
			:echo escape('c:\program files\vim', ' \')
<		返回: >
			c:\\program\ files\\vim
<		另见 |shellescape()|。

							*eval()*
+-*/+-*/+-*/eval f 计算字符串表达式
eval({string})	计算 {string} 并返回其结果。这对把 |string()| 的结果转换为原来
		的值尤其有用。适用于数值、浮点数、字符串和两者的复合类型。也可
		用于指向已有函数的 |Funcref|。


+-*/+-*/+-*/expand f 展开特殊的关键字
expand({expr} [, {flag}])				*expand()*
		扩展 {expr} 里的通配符和下列特殊关键字。返回的是字符串。

		如果返回多个匹配，以 <NL> 字符分隔 [备注: 5.0 版本使用空格。但
		是文件名如果也包含空格就会有问题]。

		如果扩展失败，返回空字符串。这不包括不存在文件的名字。

		如果 {expr} 以 '%'、'#' 或 '<' 开始，以类似于
		|cmdline-special| 变量的方式扩展，包括相关的修饰符。这里是一个
		简短的小结:

			%		当前文件名
			#		轮换文件名
			#n		轮换文件名 n
			<cfile>		光标所在的文件名
			<afile>		自动命令文件名
			<abuf>		自动命令缓冲区号 (以字符串形式出现！)
			<amatch>	自动命令匹配的名字
			<sfile>		载入的脚本文件名
			<cword>		光标所在的单词
			<cWORD>		光标所在的字串 (WORD)
			<client>	最近收到的消息的 {clientid}
					|server2client()|
		修饰符:
			:p		扩展为完整的路径
			:h		头部 (去掉最后一个部分)
			:t		尾部 (只保留最后一个部分)
			:r		根部 (去掉一个扩展名)
			:e		只有扩展名

		例如: >
			:let &tags = expand("%:p:h") . "/tags"
<		注意 扩展 '%'、'#' 或者 '<' 开头的字符串的时候，其后的文本被忽
		略。这样_不_行: >
			:let doesntwork = expand("%:h.bak")
<		应该这样: >
			:let doeswork = expand("%:h") . ".bak"
<		还要 注意  扩展 "<cfile>" 和其它形式只能返回被引用的文件名，而
		不会进一步扩展。如果 "<cfile>" 是 "~/.cshrc"，你需要执行另一个
		expand() 把 "~/" 扩展为主目录的路径: >
			:echo expand(expand("<cfile>"))
<
		变量名和其后的修饰符之间不能有空白。|fnamemodify()| 函数可以用
		来修改普通的文件名。

		使用 '%' 或 '#' 但当前或轮换文件名没有定义的时候，使用空字符
		串。在无名缓冲区使用 "%:p"  生成当前目录，后加一个 '/'。

		如果 {expr} 不以 '%'、'#' 或 '<' 开始，它以命令行上的文件名那
		样被扩展。使用 'suffixes' 和 'wildignore'，除非给出可选的
		{flag} 参数而且非零。这里可以有不存在的文件的名字。"**" 项目可
		以用来在目录树里查找。例如，要寻找当前目录及其下目录的所有的
		"README": >
			:echo expand("**/README")
<
		expand() 也可用来扩展变量和只有外壳知道的环境变量。但这会很
		慢，因为需要启动外壳。见 |expr-env-expand|。扩展后的变量还是被
		当作文件名的列表处理。如果不能扩展环境变量，保留其不变。这样，
		":echo expand('$FOOBAR')" 返回的还是 "$FOOBAR"。

		|glob()| 说明如何找到存在的文件。|system()| 说明如何得到外部命
		令的原始输出。


+-*/+-*/+-*/fnameescape f 转义 Vim 命令使用的文件名
fnameescape({string})					*fnameescape()*
		转义 {string} 以便用作命令的文件名参数。有特殊意义的字符，如
		'%' 和 '|'，会用反斜杠转义。
		多数系统上，会转义的字符是 " \t\n*?[{`$\\%#'\"|!<"。在反斜杠可
		以出现在文件名中的系统上，此字符集取决于 'isfname'。
		也转义出现在开头的 '+' 和 '>' 字符 (|:edit| 和 |:write| 之后有
		特殊意义)，还有单个出现的 "-" (|:cd| 之后有特殊意义)。
		示例: >
			:let fname = '+some str%nge|name'
			:exe "edit " . fnameescape(fname)
<		则会执行: >
			edit \+some\ str\%nge\|name


+-*/+-*/+-*/iconv f 转换文本编码格式
iconv({expr}, {from}, {to})				*iconv()*
		返回字符串，即文本 {expr} 从 {from} 编码转到 {to} 编码以后的文
		本。
		如果转换完全失败，返回空字符串。如果部分字符无法转换，以 "?"
		代替之。
		编码名字可以是任何 iconv() 库函数接受的名字，见
		":!man 3 iconv"。
		大多数转换需要 Vim 编译时加入 |+iconv| 特性。不然，只支持
		UTF-8 和 latin1 的相互转换。
		这可以用来显示包含特殊字符的消息。不管 'encoding' 设为何值，总
		可以用 UTF-8 书写消息，然后使用: >
			echo iconv(utf8_str, "utf-8", &enc)
<		注意 Vim 使用 UTF-8 进行所有的 Unicode 编码，从/到 UCS-2 的转
		换都自动转为 UTF-8。你不能在字符串里使用 UCS-2，因为那里有 NUL
		字节。
		{仅当编译时加入 |+multi_byte| 特性才有效}

							*indent()*
+-*/+-*/+-*/match f 字符串中的模式匹配处
match({expr}, {pat}[, {start}[, {count}]])			*match()*
		如果 {expr} 是 |List|，返回匹配 {pat} 的第一个项目的索引。每个
		项目用作字符串，|List| 和 |Dictionary| 使用回显的形式。
		否则，{expr} 用作字符串。返回数值，给出 {expr} 里 {pat} 匹配的
		(字节计算的偏移量) 位置。
		在第一个字符或 |List| 项目上的匹配返回零。若无匹配，返回 -1。
		例如: >
			:echo match("testing", "ing")	" 返回 4
			:echo match([1, 'x'], '\a')	" 返回 1
<		|string-match| 说明如何使用 {pat}。
								*strpbrk()*
		Vim 没有 strpbrk() 函数。但你可以这么做: >
			:let sepidx = match(line, '[.,;: \t]')
<								*strcasestr()*
		Vim 没有 strcasestr() 函数。但你可以在模式里加入 "\c" 以忽略大
		小写: >
			:let idx = match(haystack, '\cneedle')
<
		如果给出 {start}，搜索从字符串的字节位置 {start} 或 |List| 索
		引为 {start} 的项目开始。
		不过，结果仍然从第一个字符/项目开始算起。比如: >
			:echo match("testing", "ing", 2)
<		返回结果是 "4"。 >
			:echo match("testing", "ing", 4)
<		返回结果还是 "4"。 >
			:echo match("testing", "t", 2)
<		返回 "3"。
		对字符串而言，如果 {start} > 0，其行为就像该字符串在 {start}
		个字节后开始，因而 "^" 会从 {start} 开始匹配。如果给出 {count}
		时则不是如此，此时忽略 {start} 字节前的匹配 (有一点复杂，这是
		为了后向兼容)。
		对字符串而言，如果 {start} < 0，它被置为 0。对列表而言，此索引
		从尾部起算。
		如果 {start} 越界 (字符串 {start} > strlen({expr})，而 |List|
		{start} > len({expr}))，返回 -1。

		如果给出 {count}，使用第 {count} 个匹配。如果字符串里找到一个
		匹配，下一匹配从此匹配之后一个字符开始寻找。所以下例返回 1: >
			echo match("testing", "..", 0, 2)
<		|List| 里，搜索从下一个项目开始。
		注意 如果加入 {count}，{start} 使用的方式有所改变。见上。

		|pattern| 说明可以接受的模式。
		'ignorecase' 选项用来设定模式是否忽略大小写。_不_使用
		'smartcase'。匹配总是假定置位了 'magic' 而 'cpoptions' 为空。

					*matchadd()* *E798* *E799* *E801*
+-*/+-*/+-*/matchend f 字符串中的模式匹配结束处
matchend({expr}, {pat}[, {start}[, {count}]])			*matchend()*
		和 |match()| 相同，但返回匹配之后的第一个字符的位置。比如: >
			:echo matchend("testing", "ing")
<		返回 "7"。
							*strspn()* *strcspn()*
		Vim 没有 strspn() 或 strcspn() 函数，但可用 matchend() 实现: >
			:let span = matchend(line, '[a-zA-Z]')
			:let span = matchend(line, '[^a-zA-Z]')
<		不过没有匹配时，它返回 -1。

		如果给出 {start}，和 |match()| 里的用法相同。 >
			:echo matchend("testing", "ing", 2)
<		返回 "7"。 >
			:echo matchend("testing", "ing", 5)
<		返回 "-1"。
		如果 {expr} 是 |List|，结果和 |match()| 相同。


+-*/+-*/+-*/matchlist f 类似 matchstr()，同时返回子匹配
matchlist({expr}, {pat}[, {start}[, {count}]])			*matchlist()*
		和 |match()| 相同，但返回 |List|。列表第一项是匹配的字符串，和
		|matchstr()| 返回值相同。其后的项目是子匹配，类似
		|:substitute| 的 "\1"、"\2" 等。如果某个可选的子匹配不匹配，用
		空字符串代替。例如: >
			echo matchlist('acd', '\(a\)\?\(b\)\?\(c\)\?\(.*\)')
<		返回: ['acd', 'a', '', 'c', 'd', '', '', '', '', '']
		如果没有匹配，返回空列表。


+-*/+-*/+-*/matchstr f 在一个字符串中匹配一个模式
matchstr({expr}, {pat}[, {start}[, {count}]])			*matchstr()*
		和 |match()| 相同，但返回匹配的字符串。例如: >
			:echo matchstr("testing", "ing")
<		返回 "ing"。
		如果没有匹配，返回 ""。
		如果给出 {start}，它和 |match()| 里的用法相同。 >
			:echo matchstr("testing", "ing", 2)
<		返回 "ing"。 >
			:echo matchstr("testing", "ing", 5)
<		返回 ""。
		如果 {expr} 是 |List|，返回匹配的项目。其类型不改变，因而不一
		定是字符串。

							*max()*
+-*/+-*/+-*/nr2char f 通过 ASCII 码值取得一个字符
nr2char({expr})						*nr2char()*
		返回单个字符组成的字符串，该字符的数值为 {expr}。例如: >
			nr2char(64)		返回 "@"
			nr2char(32)		返回 " "
<		使用当前的 'encoding'。比如对 "utf-8" 来说: >
			nr2char(300)		返回带有弓形的 I
<		注意 文件里的 NUL 字符须用 nr2char(10) 指定。因为 Vim 用换行符
		来表示 NUL。真正的 NUL 是 nr2char(0)，而它会终结字符串，因而返
		回空串。

							*getpid()*
+-*/+-*/+-*/printf f 根据 % 项目格式化字符串
printf({fmt}, {expr1} ...)				*printf()*
		返回 {fmt} 指定的字符串，其中每个 "%" 项目被它们对应的参数排版
		后的形式取代。例如: >
			printf("%4d: E%d %.30s", lnum, errno, msg)
<		可能的返回结果:
			"  99: E42 asdfasdfasdfasdfasdfasdfasdfas" ~

		常用的项目有:
		  %s	字符串
		  %6s	右对齐到 6 个字节的字符串
		  %.9s  截短到 9 个字节的字符串
		  %c    单个字节
		  %d    十进制数
		  %5d   十进制数，用空格补足到 5 个字符
		  %x    十六进制数
		  %04x  十六进制数，用 0 补足到 4 个字符
		  %X    十六进制数，用大写字母的十六进制字母
		  %o    八进制数
		  %f	浮点数，形如 123.456
		  %e    浮点数，形如 1.234e3
		  %E    浮点数，形如 1.234E3
		  %g    浮点数，根据不同的值，使用合适的 %f 或 %e
		  %G    浮点数，根据不同的值，使用合适的 %f 或 %E
		  %%    % 字符本身

		转换规格说明以 '%' 开始，以转换类型结束。所有其它的字符按原样
		复制到结果中。

		"%" 开始转换规格说明。其后的参数依序如下:

			%  [flags]  [field-width]  [.precision]  type

		flags
			零或多个下面的标志位:

		    #	      转换值为 "替换形式"。对 c、d 和 s 转换，此选项无
		              效。对 o 转换，增加数值的精度，使得输出字符串的
			      第一个字符总是 0 (除非打印零值，且显式地使用精度
			      0)。
			      对 x 和 X 转换，非零值在前面加上字符串 "0x" (X
			      转换用 "0X")。

		    0 (零)    以 0 填充。对所有的转换，左侧用 0 而非空格填充。
		              如果对数值的转换给出精度 (d、o、x 和 X)，忽略 0
			      标志位。

		    -	      负域宽度标志位；转换后的值被左对齐到域边界上。该
			      值右侧用空格填充，而不是在左侧用空格或 0 填充。
			      如果两个标志位同时给出，- 否决 0。

		    ' ' (空格)  带符号转换 (d) 产生的正数左侧加上空格。

		    +	      带符号转换产生的数值之前总加上符号。如果两个标志
		              位同时给出，+ 否决空格。

		field-width
			可选的十进制数位字符串，指定最小的字段宽度。如果转换后
			的值的字节数小于字段宽度，在左侧 (或右侧，如果给定左对
			齐标志位的话) 用空格填充到字段宽度。

		.precision
			可选的精度，形式为句号 '.' 后跟一个可选的数位字符串。
			如果省略了数位字符串，假设精度为零。
			它给出 d、o、x 和 X 转换显示的最小数位数量，或 s 转换
			显示的字符串的字节的最大数量。
			对浮点数而言，指定小数点后的数位个数。

		type
			指定要进行的转换类型的单个字符，见下。

		字段宽度、精度 (两者都有亦可) 可以用星号 '*' 代替数位字符串。
		此情形下，一个数值参数指定字段宽度或精度。负的字段宽度被理解为
		带左对齐的标志位后跟一个正数字段宽度；负的精度被理解为就像不存
		在一样。例如: >
			:echo printf("%d: %.*s", nr, width, line)
<		限制 "line" 文本的长度为 "width" 个字节。

		转换标识符和它们的含义如下:

				*printf-d* *printf-o* *printf-x* *printf-X*
		doxX    数值参数被转换为带符号十进制 (d)，无符号八进制 (o) 或
		        无符号十六进制 (x 和 X) 记法。x 转换用字母 "abcdef"；X
			转换用 "ABCDEF" 字母。
			如果提供了精度，它给出必须出现的数位的最少数目；如果转
			换后的值需要更少的数位，左侧用 0 填充。
			任何情况下数值字段都不会被不存在或者更小的字段宽度所截
			短；如果转换的结果宽于字段宽度，字段被扩展，以包含转换
			后的结果。

							*printf-c*
		c	数值参数被转换为字节，写入产生的字符。

							*printf-s*
		s	使用字符串参数的文本。如果指定精度，使用不多于给定数目
		        的字节数。

							*printf-f* *E807*
                f	浮点数参数被转换为形如 123.456 的字符串。精度指定小数
			点后面的位数。如果精度为零，则省略小数点本身。如果未指
			定精度，缺省为 6。那个很大很大的数 (超出返回或除以零的
			结果) 显示 "inf"。
			"0.0 / 0.0" 显示 "nan"。
			示例: >
				echo printf("%.2f", 12.115)
<				12.12
			注意 截断方式取决于系统库。如不确定，使用 |round()|。

							*printf-e* *printf-E*
		e E	浮点数参数被转换为形如 1.234e+03 或用 'E' 的话
			1.234E+03 的字符串。精度指定小数点后面的位数，和 'f'
			一样。

							*printf-g* *printf-G*
		g G	如果浮点数参数在 0.001 (含) 和 10000000.0 (不含) 之
			间，则其转换同 'f'，不然，'g' 同 'e' 而 'G' 同 'E'。如
			果未指定精度，除了小数点之后的那个零以外，不显示多余的
			零和 '+' 负号。因而，10000000.0 显示为 1.0e7。

							*printf-%*
		%	写入 '%'。不转换参数。这里完整的转换规格说明是 "%%"。

		如果期待数值参数，字符串参数也被接受并自动转换。
		如果期待浮点数或字符串参数，数值参数也被接受并自动转换。
		其它参数类型产生错误信息。

							*E766* *E767*
		{exprN} 参数的数量必须和 "%" 项目的数量完全匹配。不论参数不足
		还是过多，都会给出错误。至多可用 18 个参数。



+-*/+-*/+-*/repeat f 重复字符串多次
repeat({expr}, {count})					*repeat()*
		重复 {expr} {count} 次，并返回连接后的结果。例如: >
			:let separator = repeat('-', 80)
<		如果 {count} 为零或负，返回空。
		如果 {expr} 是 |List| 类型，返回连接 {expr} {count} 次的结果。
		例如: >
			:let longlist = repeat(['a', 'b'], 3)
<		返回 ['a', 'b', 'a', 'b', 'a', 'b']。



+-*/+-*/+-*/shellescape f 转义字符串用于外壳命令
shellescape({string} [, {special}])			*shellescape()*
		转义 {string} 以便用作外壳命令的参数。
		在 MS-Windows 和 MS-DOS 上，如果未设定 'shellslash'，用双引号
		包围 {string}，并给 {string} 内的双引号加倍。
		在其它系统上，用单引号包围，并把所有的 "'" 替换为 "'\''"。
		如果给出 {special} 参数且它是非零的数值或非空的字符串
		(|non-zero-arg|)，则特殊项目如 "!"、"%"、"#" 和 "<cword>" 等会
		在前面加上反斜杠。|:!| 命令会再把反斜杠删除。
		如果 'shell' 以 "csh" 结尾，"!" 字符会被转义 (仍是当 {special}
		为 |non-zero-arg| 时)。这是因为 csh 和 tcsh 即使在单引号内仍然
		使用 "!" 用于历史替换。
		<NL> 也被转义。如果 {special} 为 |non-zero-arg| 且 'shell' 以
		"csh" 结尾时，转义两次。
		|:!| 命令的示例: >
		    :exe '!dir ' . shellescape(expand('<cfile>'), 1)
<		返回光标所在文件给出的目录列表。|system()| 的示例: >
		    :call system("chmod +w -- " . shellescape(expand("%")))



+-*/+-*/+-*/str2float f 把字符串转换为浮点数
str2float( {expr})					*str2float()*
		把字符串 {expr} 转换为浮点数。这和使用浮点数的工作方式一样，见
		|floating-point-format|，但稍稍宽松一点。例如，接受 "1e40"，而
		表达式中你必须书写 "1.0e40"。
		安静地忽略数值之后的文本。
		小数点必须是 '.'，和当前的 locale 无关。逗号会使数值转换结束:
		"12,345.67" 转换为 12.0。用 |substitute()| 可以拿掉千分位分
		隔符: >
			let f = str2float(substitute(text, ',', '', 'g'))
<		{仅当编译时加入 |+float| 特性才有效}



+-*/+-*/+-*/str2nr f 把字符串转换为数值
str2nr( {expr} [, {base}])				*str2nr()*
		把字符串 {expr} 转化为数值。
		{base} 是转换的基底，可以为 8、10 或 16。
		如果省略 {base}，使用基底 10。这也意味着开头的零不会导致八进制
		的转换，缺省的字符串到数值的转化并非如此。
		如果 {base} 为 16，忽略开头的 "0x" 或 "0X"。如果使用别的基底，
		返回零。
		安静地忽略数值之后的文本。



+-*/+-*/+-*/strchars f 字符串里的字符长度
strchars({expr})					*strchars()*
		返回数值，给出字符串 {expr} 占据的字符数。组合用字符也算一个字
		符。
		另见 |strlen()|、|strdisplaywidth()| 和 |strwidth()|。


+-*/+-*/+-*/strdisplaywidth f 字符串的显示长度
strdisplaywidth({expr}[, {col}])			*strdisplaywidth()*
		返回数值，给出字符串 {expr} 在屏幕上占据的显示单元的数目。
		如果省略 {col}，假定为零。 否则给出开始计算的屏幕列号。该值对
		包含制表符的计算有影响。
		使用当前窗口的选项设置。其中影响显示的选项也对返回值有影响，如
		'tabstop' 和 'display'。
		{expr} 如包含东亚二义性宽度字符类，'ambiwidth' 也会影响返回结
		果。
		另见 |strlen()|、|strwidth()| 和 |strchars()|。


+-*/+-*/+-*/stridx f 子串在母串中第一次出现的地方
stridx({haystack}, {needle} [, {start}])		*stridx()*
		返回数值，给出字符串 {haystack} 里第一个字符串 {needle} 出现的
		字节位置。
		如果给出 {start}，搜索从 {start} 位置开始。可用来寻找第二个匹
		配: >
			:let comma1 = stridx(line, ",")
			:let comma2 = stridx(line, ",", comma1 + 1)
<		搜索对大小写敏感。
		模式搜索可用 |match()|。
		如果 {needle} 不出现在 {haystack} 里，返回 -1。
		另见 |strridx()|。示例: >
		  :echo stridx("An Example", "Example")	     3
		  :echo stridx("Starting point", "Start")    0
		  :echo stridx("Starting point", "start")   -1
<						*strstr()* *strchr()*
		stridx() 和 C 函数 strstr() 类似。如果使用单个字符，和
		strchr() 类似。

							*string()*
+-*/+-*/+-*/strlen f 字符串长度
strlen({expr})	返回数值，即字符串 {expr} 的字节长度。
		如果你要计算多字节字符的数目 (不计算合成用字符)，可以这么用: >

			:let len = strlen(substitute(str, ".", "x", "g"))

<		如果参数为数值，先把它转化为字符串。其它类型报错。
		另见 |len()|、|strchars()|、|strdisplaywidth()| 和
		|strwidth()|。


+-*/+-*/+-*/strpart f 取得字符串的一部分
strpart({src}, {start}[, {len}])			*strpart()*
		返回字符串，{src} 从第 {start} 个字节开始字节长度为 {len} 的子
		串。
		如果包含不存在的字节，不会产生错误。只是那些字节被忽略而已。
		如果没有提供 {len}，子串从 {start} 开始直到 {src} 的结尾。 >
			strpart("abcdefg", 3, 2)    == "de"
			strpart("abcdefg", -2, 4)   == "ab"
			strpart("abcdefg", 5, 4)    == "fg"
			strpart("abcdefg", 3)       == "defg"
<		注意: 要得到第一个字符，{start} 必须是零。比如，要得到光标开始
		的三个字节: >
			strpart(getline("."), col(".") - 1, 3)
<

+-*/+-*/+-*/strridx f 子串在母串中最后一次出现的地方
strridx({haystack}, {needle} [, {start}])			*strridx()*
		返回数值，给出字符串 {haystack} 里最后一个字符串 {needle} 出现
		的字节位置。
		如果给出 {start}，此位置之外的匹配被忽略。可用来寻找上次匹配之
		前的匹配: >
			:let lastcomma = strridx(line, ",")
			:let comma2 = strridx(line, ",", lastcomma - 1)
<		搜索对大小写敏感。
		模式搜索可用 |match()|。
		如果 {needle} 不出现在 {haystack} 里，返回 -1。
		如果 {needle} 为空，返回 {haystack} 的长度。
		另见 |stridx()|。示例: >
		  :echo strridx("an angry armadillo", "an")	     3
<							*strrchr()*
		如果使用单个字符，和 C 函数 strrchr() 类似。


+-*/+-*/+-*/strtrans f 将一个字符串变成可显示的格式
strtrans({expr})					*strtrans()*
		返回等于 {expr} 的字符串，但所有的不可显示字符被翻译成可显示的
		字符序列 |'isprint'|，类似于窗口里显示的形式。例如: >
			echo strtrans(@a)
<		会显示寄存器里的换行符为 "^@" 而不是开启新行。


+-*/+-*/+-*/strwidth f 字符串显示单元数
strwidth({expr})					*strwidth()*
		返回数值，给出字符串 {expr} 在屏幕上占据的显示单元的数目。制表
		符算作一个单元。如果不想这样，可用 |strdisplaywidth()|。
		{expr} 如包含东亚二义性宽度字符类，'ambiwidth' 也会影响返回结
		果。
		另见 |strlen()|、|strdisplaywidth()| 和 |strchars()|。


+-*/+-*/+-*/submatch f 取得 "":substitute"" 匹配中指定的某个匹配
submatch({nr})						*submatch()*
		只用于 |:substitute| 命令里的表达式。返回匹配文本的第 {nr} 个
		子匹配。如果 {nr} 为 0，返回整个匹配的文本。
		例如: >
			:s/\d\+/\=submatch(0) + 1/
<		找到行内第一个数值并加 1。
		使用 <NL> 可以包含换行符。


+-*/+-*/+-*/substitute f 用一个字符串替换一个匹配的模式
substitute({expr}, {pat}, {sub}, {flags})		*substitute()*
		返回等于 {expr} 的字符串，但其中第一个 {pat} 的匹配被替代成
		{sub}。
		和 ":substitute" 命令类似 (不带任何标志位)。但 {pat} 的匹配总
		假定置位了 'magic' 选项而且 'cpoptions' 为空 (为了脚本的可移植
		性)。
		'ignorecase' 仍然适用，但 'smartcase' 不适用。
		|string-match| 说明如何使用 {pat}。
		{sub} 里的 '~' 不会被换成前一个 {sub}。
		注意 {sub} 里的一些代码有特殊含义 |sub-replace-special|。比
		如，要替换一些文本为 "\n" (两个字符)，使用 "\\\\n" 或 '\\n'。
		如果 {pat} 在 {expr} 里不能匹配，返回没有修改的 {expr}。
		如果 {flags} 为 "g"，{expr} 里的所有 {pat} 匹配都被替换。否
		则，{flags} 应该为 ""。
		示例: >
			:let &path = substitute(&path, ",\\=[^,]*$", "", "")
<		删除 'path' 选项的最后一部分。 >
			:echo substitute("testing", ".*", "\\U\\0", "")
<		返回 "TESTING"。


+-*/+-*/+-*/tolower f 将一个字符串转换为小写
tolower({expr})						*tolower()*
		返回给出字符串的备份，但所有的大写字符变为小写 (就如同在字符串
		上应用了 |gu| 一样)。


+-*/+-*/+-*/toupper f 将一个字符串转换为大写
toupper({expr})						*toupper()*
		返回给出字符串的备份，但所有的小写字符变为大写 (就如同在字符串
		上应用了 |gU| 一样)。


+-*/+-*/+-*/tr f 把一组字符翻译成另一组
tr({src}, {fromstr}, {tostr})				*tr()*
		返回 {src} 字符串的备份，其中 {fromstr} 里的每个字符被 {tostr}
		字符串里同样的位置的字符替代。也就是，{fromstr} 的第一个字符被
		翻译成 {tostr} 的第一个字符，依此类推。和 unix 命令 "tr" 完全
		相同。
		能正确处理多字节字符。

		例如: >
			echo tr("hello there", "ht", "HT")
<		返回 "Hello THere" >
			echo tr("<blob>", "<>", "{}")
<		返回 "{blob}"


+-*/+-*/time _ 时间
+-*/+-*/+-*/localtime f 得到以秒计的当前时间
localtime()						*localtime()*
		返回当前时间，以 1970 年 1 月 1 日开始的秒数计算。另见
		|strftime()| 和 |getftime()|。


+-*/+-*/+-*/reltime f 得到准确的当前或者已经经过的时间
reltime([{start} [, {end}]])				*reltime()*
		返回代表时间值的项目。项目的格式取决于不同的系统。可以把它传递
		给 |reltimestr()| 来转换为字符串。
		没有参数，返回当前时间。
		带一个参数，返回参数指定的时间以来的时间。
		带两个参数，返回 {start} 和 {end} 之间跨越的时间。
		{start} 和 {end} 参数必须是 reltime() 返回的值。
		{仅当编译时加入 |+reltime| 特性才有效}


+-*/+-*/+-*/reltimestr f 把 reltime() 的结果转换为字符串
reltimestr({time})				*reltimestr()*
		返回字符串，代表 {time} 的时间值。
		形式是秒数、句号和毫秒数。例如: >
			let start = reltime()
			call MyFunction()
			echo reltimestr(reltime(start))
<		注意 命令本身额外的开销也计算在时间里。时间的准确度取决于系
		统。
		返回结果包含引导的空格，使字符串能很好地对齐。如果你不需要，用
		split() 可以删掉。 >
			echo split(reltimestr(reltime(start)))[0]
<		另见 |profiling|。
		{仅当编译时加入 |+reltime| 特性才有效}

							*remote_expr()* *E449*
+-*/+-*/+-*/strftime f 把时间转换为字符串
strftime({format} [, {time}])				*strftime()*
		返回字符串，即经过 {format} 字符串的格式转换的日期和时间。使用
		给定的 {time}，如果没有给出时间，使用当前时间。可以接受的
		{format} 取决于你的系统。这意味着该函数不是可移植的！
		可用的格式参见 C 函数 strftime() 的参考手册。返回结果的最大长
		度是 80 个字符。另见 |localtime()| 和 |getftime()|。
		可以用 |:language| 命令改变语言。
		示例: >
		  :echo strftime("%c")		   Sun Apr 27 11:49:23 1997
		  :echo strftime("%Y %b %d %X")	   1997 Apr 27 11:53:25
		  :echo strftime("%y%m%d %T")	   970427 11:53:55
		  :echo strftime("%H:%M")	   11:55
		  :echo strftime("%c", getftime("file.c"))
						   显示 file.c 的修改时间。
<		并非所有系统都可以用。要检查这一点，用: >
			:if exists("*strftime")


+-*/+-*/var _ 变量
+-*/+-*/+-*/function f 得到函数名对应的函数引用
function({name})					*function()* *E700*
		返回指向函数 {name} 的 |Funcref| 变量。{name} 可以是用户定义的
		函数或者内部函数。



+-*/+-*/+-*/garbagecollect f 可能情况下释放内存
garbagecollect([at_exit])				*garbagecollect()*
		清理不再使用但有循环引用的 |List| 和 |Dictionary|。几乎没有需
		要调用这个函数，因为 Vim 内存不足或者 'updatetime' 之后等待用
		户按键时会自动执行此功能。没有循环引用的项目总是在不再使用的时
		候就被立即释放了。
		可用于删除很大的 |List| 和/或 |Dictionary| 而且有循环引用的时
		候，尤其是在要运行很长时间的脚本里。
		如果可选的 "at_exit" 参数为一，并且之前还没做过的话，Vim 即使
		在退出时也会执行垃圾回收。可用于检查内存泄漏。


+-*/+-*/+-*/getbufvar f 取得指定缓冲区中的变量值
getbufvar({expr}, {varname})				*getbufvar()*
		返回缓冲区 {expr} 里的选项或者局部变量 {varname} 的值。注意 必
		须使用不带 "b:" 的名字。
		如果 {varname} 为空，返回包含所有局部于缓冲区变量的字典。
		也可用于全局或者局部于缓冲区的选项，但不能用于全局或者局部于窗
		口的变量，还有局部于窗口的选项。
		关于 {expr} 的使用方式，见上 |bufname()|。
		如果缓冲区或者变量不存在，返回空字符串。不会有错误消息。
		示例: >
			:let bufmodified = getbufvar(1, "&mod")
			:echo "todo myvar = " . getbufvar("todo", "myvar")
<

+-*/+-*/+-*/gettabvar f 取得指定标签页的变量值
gettabvar({tabnr}, {varname})				*gettabvar()*
		得到标签页 {tabnr} 的标签页局部变量 {varname} 的值。|t:var|
		标签页的编号从一开始。
		注意 必须使用不带 "t:" 的名字。


+-*/+-*/+-*/gettabwinvar f 取得指定窗口和标签页的变量值
gettabwinvar({tabnr}, {winnr}, {varname})		*gettabwinvar()*
		得到标签页 {tabnr} 的窗口 {winnr} 的窗口局部变量 {varname} 的
		值。
		如果 {varname} 以 "&" 打头，得到窗口局部选项的值。
		标签页的编号从一开始。|getwinvar()| 总是使用当前标签页。
		如果 {winnr} 为零，使用当前窗口。
		也可用于全局或者局部于缓冲区或局部于窗口的选项，但不能用于全局
		或者局部于缓冲区的变量。
		如果 {varname} 为空，返回一个包含所有窗口局部变量的字典。
		注意 {varname} 必须为不带 "w:" 的名字。
		例如: >
			:let list_is_on = gettabwinvar(1, 2, '&list')
			:echo "myvar = " . gettabwinvar(3, 1, 'myvar')
<
							*getwinposx()*
+-*/+-*/+-*/getwinvar f 取得指定窗口的变量值
getwinvar({nr}, {varname})				*getwinvar()*
		类似于 |gettabwinvar()|，只用当前标签页。
		例如: >
			:let list_is_on = getwinvar(2, '&list')
			:echo "myvar = " . getwinvar(1, 'myvar')
<

+-*/+-*/+-*/islocked f 检查变量是否加锁
islocked({expr})					*islocked()* *E786*
		返回数值，如果 {expr} 是某个加锁的变量名，返回非零。
		{expr} 必须是变量名、|List| 项目，或 |Dictionary| 项目，不是变
		量本身！例如: >
			:let alist = [0, ['a', 'b'], 2, 3]
			:lockvar 1 alist
			:echo islocked('alist')		" 1
			:echo islocked('alist[1]')	" 0

<		如果 {expr} 是不存在的变量，得到错误信息。用 |exists()| 可以检
		查它是否存在。


+-*/+-*/+-*/setbufvar f 设定指定缓冲区中的变量值
setbufvar({expr}, {varname}, {val})			*setbufvar()*
		设置缓冲区 {expr} 的选项或局部变量 {varname} 的值为 {val}。
		也可用于全局或者局部于窗口的选项，但不能用于全局或者局部于窗口
		的变量。
		如果设置局部于窗口的选项，全局值不会改变。
		{expr} 的使用方式见上 |bufname()|。
		注意必须使用不带 "b:" 的变量名。
		示例: >
			:call setbufvar(1, "&mod", 1)
			:call setbufvar("todo", "myvar", "foobar")
<		该命令在沙盘里不可用 |sandbox|。


+-*/+-*/+-*/settabvar f 设定指定标签页的变量值
settabvar({tabnr}, {varname}, {val})			*settabvar()*
		设置标签页 {tabnr} 的标签页局部变量 {varname} 的值为 {val}。
		注意 必须使用不带 "t:" 的名字。
		标签页的编号从一开始。
		Vim 短暂地进入标签页 {tabnr}，所以会激活 TabLeave 和 TabEnter 
		自动命令。
		该命令在沙盘里不可用 |sandbox|。


+-*/+-*/+-*/settabwinvar f 设定指定窗口和标签页的变量值
settabwinvar({tabnr}, {winnr}, {varname}, {val})	*settabwinvar()*
		设置窗口 {nr} 的选项或局部变量 {varname} 的值为 {val}。
		标签页的编号从一开始。|setwinvar()| 总是使用当前标签页。
		如果 {winnr} 为零，使用当前窗口。
		也可用于全局或者局部于缓冲区的选项，但不能用于全局或者局部于缓
		冲区的变量。
		如果设置局部于缓冲区的选项，全局值不会改变。
		注意 必须使用不带 "w:" 的变量名。
		Vim 短暂地进入标签页 {tabnr}，所以会激活 TabLeave 和 TabEnter 
		自动命令。
		示例: >
			:call settabwinvar(1, 1, "&list", 0)
			:call settabwinvar(3, 2, "myvar", "foobar")
<		该命令在沙盘里不可用 |sandbox|。


+-*/+-*/+-*/setwinvar f 设定指定窗口的变量值
setwinvar({nr}, {varname}, {val})			*setwinvar()*
		类似于 |settabwinvar()|，只用当前标签页。
		示例: >
			:call setwinvar(1, "&list", 0)
			:call setwinvar(2, "myvar", "foobar")


+-*/+-*/+-*/type f 变量的类型
type({expr})	返回数值，取决于 {expr} 的类型:
			数值:       0
			字符串:     1
			函数引用:   2
			列表:	    3
			字典:       4
			浮点数:     5
		要避免使用这些魔术数，应该这样使用: >
			:if type(myvar) == type(0)
			:if type(myvar) == type("")
			:if type(myvar) == type(function("tr"))
			:if type(myvar) == type([])
			:if type(myvar) == type({})
			:if type(myvar) == type(0.0)


+-*/+-*/vim _ 语法
+-*/+-*/+-*/break c 跳出 while 循环
						*:break* *:brea* *E587*
:brea[k]		在 ":while" 或 ":for" 循环的内部，跳到相匹配的
			":endwhile" 或 ":endfor" 之后的命令。
			如果在循环内部的 |:try| 之后但在匹配的 |:finally| (如
			果有的话) 之前，":finally" 之后，匹配的 |:endtry| 之前
			的命令会被先执行。该过程反复应用于所有函数内的嵌套
			":try" 块。在最外层 ":endtry" 结束之后才跳到循环之后的
			命令。

+-*/+-*/+-*/call c 调用函数
						*:cal* *:call* *E107* *E117*
:[range]cal[l] {name}([arguments])
		调用函数。函数名和参数通过 |:function| 指定。可以使用不超过 20
		个参数。忽略返回值。
		如果没有给出范围而函数又接受范围，该函数被调用一次。如果给出范
		围，光标在执行函数前定位在该范围的第一行的开始。
		如果给出范围但函数自己不能处理之，该函数在范围里的每一行分别执
		行。光标定位在每个处理行的第一列。光标留在最后一行 (但可能被最
		后一个函数调用移动)。每一行上，参数被重新计算。所以这是可以的:
						*function-range-example*  >
	:function Mynumber(arg)
	:  echo line(".") . " " . a:arg
	:endfunction
	:1,5call Mynumber(getline("."))
<
		"a:firstline" 和 "a:lastline" 总是有定义的。它们可以用来在范围
		的开始或结束处进行一些不同的处理。

+-*/+-*/+-*/catch c :try 命令的一部分
					*:cat* *:catch* *E603* *E604* *E605*
:cat[ch] /{pattern}/	匹配 {pattern} 的例外抛出时，如果它没有被前一个
			":catch" 捕获，则执行本语句之后的命令，直到遇到和本
			":catch" 处于同一 |:try| 块的下一个 |:catch|、
			|:finally| 或者 |:endtry| 为止。否则，这些命令被跳过。
			如果没有提供 {pattern}，所有的错误都会被捕获。
			示例: >
		:catch /^Vim:Interrupt$/	" 捕获中断 (CTRL-C)
		:catch /^Vim\%((\a\+)\)\=:E/	" 捕获所有的 Vim 错误
		:catch /^Vim\%((\a\+)\)\=:/	" 捕获错误和中断
		:catch /^Vim(write):/		" 捕获所有 :write 的错误
		:catch /^Vim\%((\a\+)\)\=:E123/	" 捕获错误 E123
		:catch /my-exception/		" 捕获用户例外
		:catch /.*/			" 捕获一切
		:catch				" 等同于 /.*/
<
			除了 / 以外，也可以用别的字符包围 {pattern}，只要它没
			有特殊含义 (比如 '|' 或 '"') 而且不出现在 {pattern}
			里。
			注意: 依赖 ":catch" 去捕获错误信息的_文本_是不可靠的，
			因为不同的 locale 的信息可以不同。

+-*/+-*/+-*/continue c 回到 :while 开始处
						*:continue* *:con* *E586*
:con[tinue]		在 ":while" 或 ":for" 循环的内部，跳回循环开始的地方。
			如果在循环内部的 |:try| 之后但在匹配的 |:finally| (如
			果有的话) 之前，":finally" 之后，匹配的 |:endtry| 之前
			的命令会被先执行。该过程反复应用于所有函数内的嵌套
			":try" 块。在最外层 ":endtry" 结束之后才跳回循环的开始
			处。

+-*/+-*/+-*/delfunction c 删除用户函数
					*:delf* *:delfunction* *E130* *E131*
:delf[unction] {name}	删除 {name} 命名的函数。
			{name} 也可以是 |Funcref| 类型的 |Dictionary| 项目: >
				:delfunc dict.init
<			会删除 "dict" 的 "init" 项目。如果没有更多指向它的引
			用，该函数被删除。
							*:retu* *:return* *E133*
:retu[rn] [expr]	从函数返回。如果给出 "[expr]"，计算该表达式的结果成为
			函数的返回值。如果没有给出 "[expr]"，返回 0。
			如果函数退出时没有显式的调用 ":return"，返回 0。
			注意 没有不可到达行的检查，因而，如果有命令在
			":return" 之后，不会给出警告。

+-*/+-*/+-*/else c :if 命令的一部分
						*:else* *:el* *E581* *E583*
:el[se]			如果这之前的命令没有被执行，执行命令直到其后匹配的
			":else" 或 ":endif"。

+-*/+-*/+-*/elseif c :if 命令的一部分
					*:elseif* *:elsei* *E582* *E584*
:elsei[f] {expr1}	":else" ":if" 的缩写，而且无需另一个 ":endif"。

+-*/+-*/+-*/endfor c 结束最近的 :for
:endfo[r]						*:endfo* *:endfor*
			为每个 {list} 项目重复执行 ":for" 和 ":endfor" 之间的
			命令。变量 {var} 设为每个项目的值。
			如果循环里某个命令出错，从 "endfor" 之后继续执行。
			在循环里修改 {list} 影响使用的项目。如果不希望如此，构
			建一个备份: >
				:for item in copy(mylist)
<			如果不备份，Vim 在为当前项目执行命令前保存列表里下一个
			项目的引用。这样，删除当前项目不会影响循环的继续。而删
			除任何后来的项目也会使循环跳过它。这意味着下例可以工作
			(一个效率低下的清空列表的方法): >
				for item in mylist
				   call remove(mylist, 0)
				endfor
<			注意 给列表调整顺序 (例如用 sort() 或 reverse()) 可能
			会有意想不到的效果。
			注意 每个列表的类型必须完全相同，以免改变 {var} 类型时
			产生的错误。不过，在循环体的尾部 unlet 变量就可以使用
			多种项目类型: >
				for item in ["foo", ["bar"]]
				   echo item
				   unlet item  " 如果没有，会报错 E706
				endfor

+-*/+-*/+-*/endfunction c 结束用户函数
					*:endf* *:endfunction* *E126* *E193*
:endf[unction]		结束函数定义。必须单起一行，没有任何其它命令。

+-*/+-*/+-*/endif c 结束最近的 :if
:if {expr1}			*:if* *:endif* *:en* *E171* *E579* *E580*
:en[dif]		如果 {expr} 计算为非零，执行命令直到其后匹配的 ":else"
			或者 ":endif" 为止。

+-*/+-*/+-*/endtry c 结束最近的 :try
:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		改变 ":try" 和 ":endtry" 之间命令的错误处理，包括所有
			执行的内容，":source" 里的命令，函数调用，或者自动命令
			的激活等。

+-*/+-*/+-*/endwhile c 结束最近的 :while
:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
						*E170* *E585* *E588* *E733*
:endw[hile]		只要 {expr1} 计算的结果非零，重复 ":while" 和
			":endwhile" 之间的命令。
			如果发现循环里有命令出错，从 "endwhile" 之后继续执行。
			例如: >
				:let lnum = 1
				:while lnum <= line("$")
				   :call FixLine(lnum)
				   :let lnum = lnum + 1
				:endwhile
<
			注意: ":append" 和 ":insert" 命令在 ":while" 和 ":for"
			循环里不能正常工作。

+-*/+-*/+-*/finally c :try 命令的一部分
					*:fina* *:finally* *E606* *E607*
:fina[lly]		任何匹配的 |:try| 和本 ":finally" 之间的部分要离开的时
			候都执行本语句之后的命令，直到遇到匹配的 |:endtry| 为
			止。包括这些情形: 正常完成且要执行到 ":finally"，通过
			|:continue|、|:break|、|:finish| 或 |:return|，或者由
			于错误或者中断或者例外 (见 |:throw|)。

+-*/+-*/+-*/finish c 退出 Vim 脚本的执行
						*:fini* *:finish* *E168*
:fini[sh]		停止执行脚本。只能用在 Vim 脚本中，来快速跳过脚本的其
			余内容。如果出现在 |:try| 之后但在相应的 |:finally|
			(如果存在的话) 之前，":finally" 到 |:endtry| 的内容还
			会执行。执行完所有嵌套的 ":try" 层的 ":finally" 代码
			后，最外层的 ":endtry" 才会最终真正停止脚本的执行。
			{Vi 无此功能}

+-*/+-*/+-*/for c for 循环
:for {var} in {list}					*:for* *E690* *E732*
:endfo[r]						*:endfo* *:endfor*
			为每个 {list} 项目重复执行 ":for" 和 ":endfor" 之间的
			命令。变量 {var} 设为每个项目的值。
			如果循环里某个命令出错，从 "endfor" 之后继续执行。
			在循环里修改 {list} 影响使用的项目。如果不希望如此，构
			建一个备份: >
				:for item in copy(mylist)
<			如果不备份，Vim 在为当前项目执行命令前保存列表里下一个
			项目的引用。这样，删除当前项目不会影响循环的继续。而删
			除任何后来的项目也会使循环跳过它。这意味着下例可以工作
			(一个效率低下的清空列表的方法): >
				for item in mylist
				   call remove(mylist, 0)
				endfor
<			注意 给列表调整顺序 (例如用 sort() 或 reverse()) 可能
			会有意想不到的效果。
			注意 每个列表的类型必须完全相同，以免改变 {var} 类型时
			产生的错误。不过，在循环体的尾部 unlet 变量就可以使用
			多种项目类型: >
				for item in ["foo", ["bar"]]
				   echo item
				   unlet item  " 如果没有，会报错 E706
				endfor

+-*/+-*/+-*/function c 定义用户函数
					*:fu* *:function* *E128* *E129* *E123*
:fu[nction]		列出所有函数和它们的参数。

+-*/+-*/+-*/if c 条件满足时执行命令
:if {expr1}			*:if* *:endif* *:en* *E171* *E579* *E580*
:en[dif]		如果 {expr} 计算为非零，执行命令直到其后匹配的 ":else"
			或者 ":endif" 为止。

+-*/+-*/+-*/let c 给变量或选项赋值
:let {var-name} = {expr1}				*:let* *E18*
			设置内部变量 {var-name} 为表达式 {expr1} 的计算结果。
			该变量也会得到 {expr} 的类型。如果 {var-name} 不存在，
			它会被创立。

+-*/+-*/+-*/lockvar c 给变量加锁
:lockv[ar][!] [depth] {name} ...			*:lockvar* *:lockv*
			给内部变量 {name} 加锁。加锁意味着不能再修改该变量 (直
			到它被解锁为止)。
			加锁的变量可以删除: >
				:lockvar v
				:let v = 'asdf'		" fails!
				:unlet v
<							*E741*
			如果试图修改加锁的变量，你会得到错误信息: "E741: Value
			of {name} is locked"

+-*/+-*/+-*/return c 从用户函数返回
							*:retu* *:return* *E133*
:retu[rn] [expr]	从函数返回。如果给出 "[expr]"，计算该表达式的结果成为
			函数的返回值。如果没有给出 "[expr]"，返回 0。
			如果函数退出时没有显式的调用 ":return"，返回 0。
			注意 没有不可到达行的检查，因而，如果有命令在
			":return" 之后，不会给出警告。

+-*/+-*/+-*/sandbox c 在沙盘里执行命令
							*:san* *:sandbox*
:san[dbox] {cmd}	在沙盘里执行 {cmd}。用于计算可能在模式行里设置的选项，
			比如 'foldexpr'。

+-*/+-*/+-*/throw c 抛出例外
							*:th* *:throw* *E608*
:th[row] {expr1}	计算 {expr1} 然后抛出例外。如果 ":throw" 在 |:try| 之
			后但在第一个对应的 |:catch| 之前使用，它之后的命令被跳
			过，直到遇到第一个匹配 {expr1} 为止。如果没有这样的
			":catch"，或者如果 ":throw" 在 ":catch" 之后
			|:finally| 之前使用，执行 ":finally" (如果有的话) 之后
			直到匹配的 |:endtry| 为止的命令。如果本 ":throw" 在
			":finally" 之后之后出现，直到 ":endtry" 为止的命令都被
			跳过。到达 ":endtry" 的时候，在动态计算的往外一层的
			":try" 块上再次重复本过程 (这可能出现在外层调用的函数
			或者执行的脚本上)，直到找到一个匹配的 ":catch"。如果最
			终该例外没有被捕获，命令处理被终止。
			示例: >
		:try | throw "oops" | catch /^oo/ | echo "caught" | endtry
<

+-*/+-*/+-*/try c 执行命令，错误或者例外时终止
:try				*:try* *:endt* *:endtry* *E600* *E601* *E602*
:endt[ry]		改变 ":try" 和 ":endtry" 之间命令的错误处理，包括所有
			执行的内容，":source" 里的命令，函数调用，或者自动命令
			的激活等。

+-*/+-*/+-*/unlet c 删除变量
:unl[et][!] {name} ...				*:unlet* *:unl* *E108* *E795*
			删除内部变量 {var-name}。可以给出多个变量的名字。它们
			都被删除。该名字也可以是 |List| 或 |Dictionary| 项目。
			如果使用 [!]，即使变量不存在也不会给出错误。
			|List| 里可以删除一到多个项目: >
				:unlet list[3]	  " remove fourth item
				:unlet list[3:]   " remove fourth item to last
<			|Dictionary| 里一次只能删除一个项目: >
				:unlet dict['two']
				:unlet dict.two
<			这对于清除全局和脚本局部变量很有用 (脚本结束时并不自动
			删除这些变量)。函数局部变量在函数结束时是自动清除的。

+-*/+-*/+-*/unlockvar c 给变量解锁
:unlo[ckvar][!] [depth] {name} ...			*:unlockvar* *:unlo*
			给内部变量 {name} 解锁。和 |:lockvar| 刚好相反。

+-*/+-*/+-*/while c 只要条件满足，执行循环体
:wh[ile] {expr1}			*:while* *:endwhile* *:wh* *:endw*
						*E170* *E585* *E588* *E733*
:endw[hile]		只要 {expr1} 计算的结果非零，重复 ":while" 和
			":endwhile" 之间的命令。
			如果发现循环里有命令出错，从 "endwhile" 之后继续执行。
			例如: >
				:let lnum = 1
				:while lnum <= line("$")
				   :call FixLine(lnum)
				   :let lnum = lnum + 1
				:endwhile
<
			注意: ":append" 和 ":insert" 命令在 ":while" 和 ":for"
			循环里不能正常工作。

+-*/window _ 窗口
+-*/+-*/bufwinnr f 取得某缓冲区的窗口号
bufwinnr({expr})					*bufwinnr()*
		返回数值，即缓冲区 {expr} 对应的第一个窗口的编号。{expr} 的使
		用方式见上 |bufname()|。如果缓冲区 {expr} 不存在或者没有对应的
		窗口，返回 -1。例如: >

	echo "包含缓冲区 1 的窗口是 " . (bufwinnr(1))

<		该编号可用于 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。
		只处理当前标签页。

+-*/+-*/close c 改变当前窗口
CTRL-W c					*CTRL-W_c* *:clo* *:close*
:clo[se][!]	关闭当前窗口。如果置位了 'hidden'，或者改动了缓冲区但是命令里
		用了 [!]，缓冲区会被隐藏 (除非还有一个窗口在编辑该缓冲区)。
		如果当前标签页只有一个窗口而且有其它标签页，关闭当前标签页。
		|tab-page|。
		该命令在下述情况下会失败：			*E444*
		- 屏幕上只剩下最后一个窗口的时候。
		- 当 'hidden' 没有置位，也没有用 [!]，并且缓冲区也已经被修改，
		  而且也没有其它窗口监视该缓冲区的时候。
		对缓冲区的改动既不写入文件，也不会丢失，所以这是个 "安全" 的命
		令。

+-*/+-*/cursorbind o 光标移动时同时在其它窗口移动
			*'cursorbind'* *'crb'* *'nocursorbind'* *'nocrb'*
'cursorbind' 'crb'	布尔型	 (缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+cursorbind| 特性才有效}
	如果置位此选项，光标在当前窗口移动时，其它光标绑定的窗口 (置位本选项的
	的窗口) 也会移动他们的光标到对应的行和列。此选项可用于浏览文件不同版本
	的异同 (见 'diff')；比较模式下，已插入和删除的行 (但不包括行内删除的字
	符) 已经考虑在内。



+-*/+-*/drop c 跳到编辑某文件的窗口，不成功则在当前窗口编辑之
						*:dr* *:drop*
:dr[op] [++opt] [+cmd] {file} ..
		在一个窗口内编辑第一个 {file}。
		－ 如果该文件已经被打开，切换至该文件所在窗口。
		－ 如果该文件尚未被打开，在当前窗口内打开该文件。如果当前窗口
		   无法被放弃 |abandon|，窗口会先被分割。
		参数列表 |argument-list| 会被象使用 |:next| 命令一样被设定。
		此命令的目的在于：允许 debugger 之类的程序里让 Vim 编辑另一个
		文件。
		如果使用 |:tab| 修饰符，为每个参数打开一个标签页。如果为空，使
		用最后一个窗口。
		另见 |++opt| 和 |+cmd|。
		{仅当编译时有 GUI 才可用}

+-*/+-*/eadirection o 'equalalways' 工作的方向
						*'eadirection'* *'ead'*
'eadirection' 'ead'	字符串	(缺省为 "both")
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+vertsplit| 特性才有效}
	说明如何应用 'equalalways' 选项:
		ver	垂直方向，窗口宽度不受影响
		hor	水平方向，窗口高度不受影响
		both	窗口宽度和高度都受影响


+-*/+-*/only c 关闭当前窗口，除了当前的窗口以外
CTRL-W CTRL-O					*CTRL-W_CTRL-O* *:on* *:only*
:on[ly][!]	使当前窗口成为屏幕上唯一的窗口。其它窗口都关闭。
		如果置位了 'hidden' 选项，被关闭窗口里的所有缓冲区变成隐藏。
		如果没有置位 'hidden'，但是置位了 'autowrite' 选项，那么已经更
		改的缓冲区被写入文件。否则，除非使用 [!] 强制关闭，那些包含修
		改过的缓冲区的窗口不被删除，它们转入隐藏状态。因为修改过的缓冲
		区永远不会被放弃，缓冲区的改动也永远不会丢失。

+-*/+-*/previewheight o 预览窗口的高度
					*'previewheight'* *'pvh'*
'previewheight' 'pvh'	数值型 (缺省为 12)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 和 |+quickfix|  特性才有
			效}
	预览窗口的缺省高度。用于 |:ptag| 和相关的命令，也用于不带计数的
	|CTRL-W_}|。


+-*/+-*/previewwindow o 标识预览窗口
					*'previewwindow'* *'nopreviewwindow'*
					*'pvw'* *'nopvw'* *E590*
'previewwindow' 'pvw'	布尔型 (缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 和 |+quickfix|  特性才有效}
	标识预览窗口。只有一个窗口可以置位此选项。该选项通常不直接设置，而通过
	|:ptag|、|:pedit| 等命令进行。


+-*/+-*/resize c 改变当前窗口的高度
:res[ize] -N					*:res* *:resize* *CTRL-W_-*
CTRL-W -	使得当前窗口高度减 N (默认值是 1)。
		如果在 |'vertical'| 之后使用，则使得宽度减 N。

+-*/+-*/scrolljump o 滚动所需的最少行数
						*'scrolljump'* *'sj'*
'scrolljump' 'sj'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
	光标离开屏幕时 (比如用 "j")，最少的滚动行数。不用于滚动命令 (比如
	CTRL-E、CTRL-D)。如果屏幕滚动很慢，会有帮助。
	如果设为 -1 到 -100 的负数，用作窗口高度的百分比。这样 -50 滚动到窗口
	高度的一半。
	注意: 如果置位 'compatible'，该选项被设为 1。


+-*/+-*/scrolloff o 光标上下的最少行数
						*'scrolloff'* *'so'*
'scrolloff' 'so'	数值型	(缺省为 0)
			全局
			{Vi 无此功能}
	光标上下两侧最少保留的屏幕行数。这使你工作时总有一些可见的上下文。
	如果你设置此选项为很大的值 (比如 999)，光标所在的行将总定位在窗口的中
	间位置 (除非你非常靠近文件开始或者结束的地方，或者有长行回绕)。
	水平滚动见 'sidescrolloff'。
	注意: 如果置位 'compatible'，该选项被设为 0。


+-*/+-*/scrollopt o 'scrollbind' 的行为方式
						*'scrollopt'* *'sbo'*
'scrollopt' 'sbo'	字符串	(缺省为 "ver,jump")
			全局
			{仅当编译时加入 |+scrollbind| 特性才有效}
			{Vi 无此功能}
	这是逗号分隔的单词列表，指定 'scrollbind' 窗口的行为。'sbo' 代表
	ScrollBind Options (滚动绑定选项)。
	可用以下的单词:
	    ver		'scrollbind' 窗口绑定垂直滚动
	    hor		'scrollbind' 窗口绑定水平滚动
	    jump	应用两个垂直滚动窗口之间的相对偏移。该偏移是两个绑定窗
			口的首个显示行之间的行号差。如果在一个窗口里移动，另一
			个 'scrollbind' 的窗口可能会到达缓冲区开始之前或结束之
			后的位置。不过，该偏移没有改变。如果再往相反方向滚动，
			那个 'scrollbind' 窗口会试图滚动到根据该偏移它应该到达
			的位置，如有可能。
			如果现在使得该窗口成为当前窗口，相对偏移会有两种情况:
			1. 如果不包含 "jump"，相对偏移根据新窗口的滚动位置进行
			   调整。回到原来那个窗口时，会使用新的相对偏移。
			2. 如果包含 "jump"，别的窗口会根据相同的相对偏移进行滚
			   动，回到原来那个窗口时，仍然使用原有的相对偏移。
	另见 |scroll-binding|。
	激活 'diff' 模式时，总有垂直滚动绑定。即使这里没有 "ver" 亦然。


+-*/+-*/sidescroll o 横向滚动的最少列数
						*'sidescroll'* *'ss'*
'sidescroll' 'ss'	数值型	(缺省为 0)
			全局
			{Vi 无此功能}
	水平滚动时滚动的最少列数。只用于 'wrap' 选项关闭且光标移出屏幕范围时。
	如果为零，把光标定位在屏幕的中间。在慢速的终端里，设大一些或者为 0。如
	果使用快速的终端，设小一些或者为 1。不用于 "zh" 和 "zl" 命令。


+-*/+-*/sidescrolloff o 在光标左右最少出现的列数
						*'sidescrolloff'* *'siso'*
'sidescrolloff' 'siso'	数值型 (缺省为 0)
			全局
			{Vi 无此功能}
	如果设置 'nowrap'，光标左右两侧保留的最少屏幕列数。设置此选项为大于零
	的值，同时使 |'sidescroll'| 也为非零值，可以使得水平滚动的行上总有一些
	可见的上下文 (除了在行首之外)。设置此选项为很大的值 (比如 999) 可以保
	持光标总定位在窗口水平中央，除非你非常靠近行首。
	注意: 如果置位 'compatible'，该选项被设为 0。

	示例:	 试试和 'sidescroll' 以及 'listchars' 一起使用，参考下面的例
		 子，不让光标移到 "extends" 字符上:

		 :set nowrap sidescroll=1 listchars=extends:>,precedes:<
		 :set sidescrolloff=1



+-*/+-*/syncbind c 同步滚动绑定
						*syncbind* *:syncbind* *:sync*
:syncbind		强制所有 'scrollbind' 窗口具有相同的相对偏移。即：当
			一个窗口滚屏到了它缓冲区的顶部时，所有的 'scrollbind' 
			窗口都会滚屏到它们缓冲区的顶部。

+-*/+-*/winbufnr f 取得某窗口的缓冲区号
winbufnr({nr})	返回数值，即窗口 {nr} 相关联的缓冲区号。如果 {nr} 为零，返回当
		前窗口的缓冲区号。如果窗口 {nr} 不存在，返回 -1。
		示例: >
  :echo "当前窗口的文件是 " . bufname(winbufnr(0))
<
							*wincol()*
+-*/+-*/wincmd c 执行窗口 (CTRL-W) 命令
						*:winc* *:wincmd*
这些命令也可以用 ":wincmd" 来执行：

+-*/+-*/windo c 为每个窗口执行命令
							*:windo*
:windo {cmd}		在每一个窗口里执行 {cmd}。
			这就像是： >
				CTRL-W t
				:{cmd}
				CTRL-W w
				:{cmd}
				等等……
<			只在当前标签页进行操作。
			如果在一个窗口里检测到错误，余下的窗口不再访问。
			最后一个窗口 (或者出错的那个窗口) 成为当前窗口。
			{cmd} 可以包含 '|' 来连接多个命令。
			{cmd} 不能打开或关闭窗口，也不能更换它们的顺序。
			{Vi 无此功能} {仅在编译时加入 |+listcmds| 特性才有效}
			也参见 |:tabdo|、|:argdo| 和 |:bufdo|。

+-*/+-*/winfixheight o 打开/关闭窗口时保持窗口高度
			*'winfixheight'* *'wfh'* *'nowinfixheight'* *'nowfh'*
'winfixheight' 'wfh'	布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	窗口打开或关闭并且置位 'equalalways' 时，保持窗口的高度。另见
	|CTRL-W=|。|preview-window| 和 |quickfix-window| 中缺省打开。
	不过，如果空间不够，高度仍然会改变。


+-*/+-*/winfixwidth o 打开/关闭窗口时保持窗口宽度
			*'winfixwidth'* *'wfw'* *'nowinfixwidth'* *'nowfw'*
'winfixwidth' 'wfw'	布尔型	(缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	窗口打开或关闭并且置位 'equalalways' 的时候，保持窗口的宽度。另见
	|CTRL-W=|。
	不过，如果空间不够，宽度仍然会改变。


+-*/+-*/winheight f 取得某窗口的高度
winheight({nr})						*winheight()*
		返回数值，窗口 {nr} 的高度。如果 {nr} 为零，返回当前窗口的高
		度。如果窗口 {nr} 不存在，返回 -1。存在的窗口的宽度至少为零。
		示例: >
  :echo "当前窗口有 " . winheight(0) . " 行。"
<
							*winline()*
+-*/+-*/winheight o 当前窗口的最少行数
						*'winheight'* *'wh'* *E591*
'winheight' 'wh'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	当前窗口的最少行数。这不是绝对的最小值，如果没有足够的空间，Vim 仍会使
	用更少的行。
	焦点移到比本选项小的窗口时，增大其高度，但以减少其它窗口的高度为代价。
	普通的编辑应设置 'winheight' 为一个较小的值。
	设之为 999 使得当前窗口填充几乎整个屏幕 ，其它窗口只有 'winminheight'
	高。不过这有缺点，":all" 只会建立两个窗口。要避免 "vim -o 1 2 3 4" 只
	建立两个窗口的情况，用 |VimEnter| 事件在启动后再设置选项: >
		au VimEnter * set winheight=999
<	最小的值为 1。
	改变当前窗口的高度的命令不会调整此高度。
	'winheight' 应用于当前窗口。'winminheight' 设置其它窗口的最小高度。


+-*/+-*/winminwidth o 任何窗口的最少列数
						*'winminwidth'* *'wmw'*
'winminwidth' 'wmw'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+vertsplit| 特性才有效}
	非当前窗口的最小宽度。
	这是一个绝对的最小值，窗口决不会比这更小。
	如果设为零，在需要的话，窗口可能被 "挤压" 为零列 (也就是，只有垂直分割
	符)。激活它们时，至少给出一列 (因为光标总要在什么地方显示的)。
	使用 'winwidth' 设置当前窗口的最小宽度。
	本选项只有在窗口会变的更小时才会检查。不要使用很大的值。不然，如果打开
	窗口变多，会报错。设为 0 到 12 的值是合理的。


+-*/+-*/winnr f 取得当前窗口的窗口号
winnr([{arg}])	返回数值，当前窗口的编号。最上面的窗口的编号为 1。
		如果可选的参数为 "$"，返回最后一个窗口的编号 (即窗口的总数)。
		如果可选的参数为 "#"，返回最近访问的窗口号 (|CTRL-W_p| 到的地
		方)。如果没有上次窗口或它在另一个标签页中，返回 0。
		该数值可以用于 |CTRL-W_w| 和 ":wincmd w" |:wincmd|。
		另见 |tabpagewinnr()|。

							*winrestcmd()*
+-*/+-*/winrestcmd f 恢复窗口大小的返回命令
winrestcmd()	返回 |:resize| 命令序列，该序列应该能够恢复当前窗口的大小。只
		有在没有窗口被打开或关闭且当前窗口和标签页都没有改变的时候才能
		正确工作。
		示例: >
			:let cmd = winrestcmd()
			:call MessWithWindowSizes()
			:exe cmd
<
							*winrestview()*
+-*/+-*/winrestview f 恢复保存的当前窗口的视图
winrestview({dict})
		使用 |winsaveview()| 返回的 |Dictionary| 来恢复当前窗口的视
		图。
		如果你改变了其中的值，结果无法预测。如果窗口大小改变了，结果不
		会完全一样。

							*winsaveview()*
+-*/+-*/winsaveview f 得到当前窗口的视图
winsaveview()	返回 |Dictionary|，包含当前窗口的信息，这些信息可用来恢复视
		图。
		|winrestview()| 进行视图的恢复。
		可用于定义在缓冲区里跳转后想恢复的原来视图的映射。
		这里不保存折叠的信息。用 'foldenable' 选项来暂时关闭折叠功能，
		这样在移动时折叠就不会打开。
		返回值包括:
			lnum		光标行号
			col		光标列号
			coladd		'virtualedit' 使用的光标列偏移
			curswant	垂直移动使用的列
			topline		窗口的第一行
			topfill		填充行，只用于 diff 模式
			leftcol		显示的第一列
			skipcol		跳过的列数
		注意 这里不保存任何选项值。



+-*/+-*/winwidth f 取得某窗口的宽度
winwidth({nr})						*winwidth()*
		返回数值，窗口 {nr} 的宽度。如果 {nr} 为零，返回当前窗口的宽
		度。如果窗口 {nr} 不存在，返回 -1。存在的窗口的宽度至少为零。
		示例: >
  :echo "当前窗口有 " . winwidth(0) . " 列。"
  :if winwidth(0) <= 50
  :  exe "normal 50\<C-W>|"
  :endif
<
							*writefile()*
+-*/+-*/winwidth o 当前窗口的最少列数
						*'winwidth'* *'wiw'* *E592*
'winwidth' 'wiw'	数值型	(缺省为 20)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+vertsplit| 特性才有效}
	当前窗口的最少列数。这不是绝对的最小值，如果没有足够的空间，Vim 仍会使
	用更少的列。如果当前窗口比本选项小，增大之，但以减少其它窗口的宽度为代
	价。设之为 999 使得当前窗口总是填充整个屏幕。普通的编辑应设置它为一个
	较小的值。
	改变当前窗口的宽度的命令不会调整此宽度。
	'winwidth' 应用于当前窗口。'winminwidth' 设置其它窗口的最小宽度。


+-*/+-*/fen _ 分窗口
+-*/+-*/+-*/aboveleft c 使得分割的窗口出现在左侧或者上方
:abo[veleft] {cmd}				*:abo* *:aboveleft*
		执行 {cmd}。如果包含一个分割窗口的命令，那么将从当前窗口的左
		(垂直分割) 或者上方 (水平分割) 分割窗口，而忽略 'splitbelow'
		和 'splitright' 的设置。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/belowright c 使得分割的窗口出现在右侧或者下方
:bel[owright] {cmd}				*:bel* *:belowright*
		执行 {cmd}。如果包含一个分割窗口的命令，那么将从当前窗口的右
		(垂直分割) 或者下方 (水平分割) 分割窗口，而忽略 'splitbelow'
		和 'splitright' 的设置。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/botright c 使得分割的窗口出现在最右侧或者下方
						*:botright*
:bo[tright] {cmd}
		执行 {cmd}。如果包含一个分割窗口的命令，那么该窗口出现在底部，
		并且占据最大宽度。当垂直分割窗口时，窗口出现在最右边，并且占据
		最大高度。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/equalalways o 自动使所有窗口大小相同
			     *'equalalways'* *'ea'* *'noequalalways'* *'noea'*
'equalalways' 'ea'	布尔型	(缺省打开)
			全局
			{Vi 无此功能}
	如果打开，所有窗口在分割或关闭某窗口时自动使用相同的尺寸。即使此选项已
	经打开也会如此。如果关闭，分割窗口会减少当前窗口的尺寸，并保持其它窗口
	不变。如果关闭窗口，额外的空间分配给紧邻的窗口 (取决于 'splitbelow' 和
	'splitright')。
	如果混合垂直和水平分割窗口，计算最小的尺寸，如果有空间的话，适当增加某
	些窗口的大小。 'eadirection' 选项设定在哪个方向上改变尺寸。要防止某个
	窗口高度和宽度被改变，分别设置 'winfixheight' 和 'winfixwidth'。
	建立新窗口时如果指定窗口大小，目前不试图使尺寸相同 (比较复杂，将来也许
	会实现)。


+-*/+-*/+-*/helpheight o 新帮助窗口的最小高度
						*'helpheight'* *'hh'*
'helpheight' 'hh'	数值型	(缺省为 20)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	用 ":help" 命令打开帮助文件的最小的初始高度。帮助文件的初始高度是当前
	窗口的一半，或者 (打开 'ea' 选项时) 和其它窗口一样。如果高度小于
	'helpheight'，高度设为 'helpheight'。设为零关闭此功能。


+-*/+-*/+-*/leftabove c 使得分割的窗口出现在左侧或者上方
:lefta[bove] {cmd}				*:lefta* *:leftabove*
:abo[veleft] {cmd}				*:abo* *:aboveleft*
		执行 {cmd}。如果包含一个分割窗口的命令，那么将从当前窗口的左
		(垂直分割) 或者上方 (水平分割) 分割窗口，而忽略 'splitbelow'
		和 'splitright' 的设置。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/new c 创建一个新的空白窗口
:[N]new [++opt] [+cmd]					*:new*
		创建一个新窗口并且开始编辑一个空文件。新窗口的高度为 N (默认值
		为现存高度的一半)。减少当前窗口的高度，为新窗口留出空间 (如果
		你打开了 'equalalways' 选项，并且 'eadirection' 没有设置为
		"hor"，其它窗口也会被影响)。
		参见：|++opt| and |+cmd|。
		如果设置了 'fileformats' 选项，那么新缓冲区会使用其中的第一个
		格式。如果 'fileformats' 为空，那么使用当前缓冲区的
		'fileformat' 值。这个值可以被 |++opt| 参数覆盖。
		自动命令以如下顺序被执行：
		1. 在当前窗口执行 WinLeave
		2. 在新窗口里执行 WinEnter
		3. 在当前缓冲区执行 BufLeave
		4. 在新缓冲区执行 BufEnter
		这跟先执行 ":split"，再执行一个 ":e" 命令的效果差不多。

+-*/+-*/+-*/pclose c 关闭预览窗口
CTRL-W CTRL-Z				*CTRL-W_CTRL-Z* *:pc* *:pclose*
:pc[lose][!]	关闭当前打开的预览窗口。如果置位了 'hidden'，或者更改了缓冲区
		并且使用了 [!]，则缓冲区变为隐藏 (除非还有其它窗口正在编辑该
		缓冲区)。如果预览窗口的缓冲区不能关闭，此命令失败。也参见
		|:close|。

+-*/+-*/+-*/pedit c 在预览窗口编辑文件
							*:ped* *:pedit*
:ped[it][!] [++opt] [+cmd] {file}
		在预览窗口里编辑文件 {file}。预览窗口打开的方式和 |:ptag| 类
		似。当前窗口和光标的位置都不改变。可用实例： >
			:pedit +/fputc /usr/include/stdio.h
<
							*:ps* *:psearch*
:[range]ps[earch][!] [count] [/]pattern[/]
		与 |:ijump| 命令很像，只是找到的匹配在预览窗口显示。预览窗口用
		|:ptag| 打开。当前窗口和光标的位置都不改变。有用的例子： >
			:psearch popen
<		这很像 |:ptag| 命令，你可以用它自动显示光标所在单词的相关信
		息。这个命令虽然不如 |:ptag| 强大，但是你可以不使用标签文件，
		而同样可以找到系统的头文件。例如： >
  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<cword>")
<		警告：可能会很慢。

+-*/+-*/+-*/ppop c 在预览窗口 "":pop
							*:pp* *:ppop*
:[count]pp[op][!]
		在预览窗口执行 ":[count]pop[!]"。参见 |:pop| 和 |:ptag|。
		{Vi 无此功能}

+-*/+-*/+-*/psearch c 类似于 "":ijump""，但在预览窗口显示匹配
							*:ps* *:psearch*
:[range]ps[earch][!] [count] [/]pattern[/]
		与 |:ijump| 命令很像，只是找到的匹配在预览窗口显示。预览窗口用
		|:ptag| 打开。当前窗口和光标的位置都不改变。有用的例子： >
			:psearch popen
<		这很像 |:ptag| 命令，你可以用它自动显示光标所在单词的相关信
		息。这个命令虽然不如 |:ptag| 强大，但是你可以不使用标签文件，
		而同样可以找到系统的头文件。例如： >
  :au! CursorHold *.[ch] nested exe "silent! psearch " . expand("<cword>")
<		警告：可能会很慢。

+-*/+-*/+-*/ptag c 在预览窗口显示标签
						*:pta* *:ptag*
:pta[g][!] [tagname]
		执行 ":tag[!] [tagname]" 并且在预览窗口里显示标签所指向的内
		容，不改变当前缓冲区和光标的位置。如果预览窗口已经打开，则会被
		重用 (类似于帮助窗口)。新预览窗口的高度由 'previewheight' 决
		定。另见 |:tag|。
		参考下面的例子。|CursorHold-example|
		与 |:tag| 有细小的差别: 当 [tagname] 与当前显示的标签相同时，
		该命令不会重新设置标签匹配表的当前位置。这使 |:ptnext| 执行完
		后，|CursorHold-example| 仍可以运行。

+-*/+-*/+-*/rightbelow c 使得分割窗口出现在右侧或者下方
:rightb[elow] {cmd}				*:rightb* *:rightbelow*
:bel[owright] {cmd}				*:bel* *:belowright*
		执行 {cmd}。如果包含一个分割窗口的命令，那么将从当前窗口的右
		(垂直分割) 或者下方 (水平分割) 分割窗口，而忽略 'splitbelow'
		和 'splitright' 的设置。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/sbNext c 分割窗口并转到缓冲区列表的前一个文件
:[N]sbN[ext] [N]		*:sbN* *:sbNext* *:sbp* *:sbprevious*
:[N]sbp[revious] [N]
		分割窗口并至缓冲区列表往前第 [N] 个缓冲区。如果到了缓冲区列表
		的顶端，则从末尾往前循环。使用 'switchbuf'

+-*/+-*/+-*/sball c 为缓冲区列表的每个文件打开窗口
:[N]ba[ll] [N]					*:ba* *:ball* *:sba* *:sball*
:[N]sba[ll] [N]	重新排列屏幕，给缓冲区列表中的每一个缓冲区打开一个窗口。如果给
		出计数，则计数为打开窗口的最多数目。''winheight' 也限制了打开
		窗口的数目 (当前缀 |:vertical| 时则为 'winwidth')。
		Buf/Win Enter/Leave 不会在新窗口执行，只有真正进入这些窗口时才
		会。
		如果使用 |:tab| 修饰符，新窗口在新标签页上打开，直到用完
		'tabpagemax' 个标签页为止。

+-*/+-*/+-*/sbfirst c 分割窗口并转到缓冲区列表的第一个文件
							*:sbf* *:sbfirst*
:sbf[irst]	与 ":sbrewind" 相同。

+-*/+-*/+-*/sblast c 分割窗口并转到缓冲区列表的最后一个文件
							*:sbl* *:sblast*
:sbl[ast]	分割窗口并至缓冲区列表中的最后一个缓冲区。如果列表为空，则转到
		最后一个列表外缓冲区。
		还需考虑 'switchbuf' 选项。

+-*/+-*/+-*/sbmodified c 分割窗口并转到缓冲区列表的修改过的文件
:[N]sbm[odified] [N]					*:sbm* *:sbmodified*
		分割窗口并至往后第 [N] 个修改过的缓冲区。
		还需考虑 'switchbuf' 选项。
		备注: 这个命令也能找到不在列表里的缓冲区。

+-*/+-*/+-*/sbnext c 分割窗口并转到缓冲区列表的后一个文件
							*:sbn* *:sbnext*
:[N]sbn[ext] [N]
		分割窗口并至缓冲区列表往后第 [N] 个缓冲区。如果到了缓冲区列表
		的末尾，则从头循环。使用 'switchbuf'

+-*/+-*/+-*/sbprevious c 分割窗口并转到缓冲区列表的前一个文件
:[N]sbN[ext] [N]		*:sbN* *:sbNext* *:sbp* *:sbprevious*
:[N]sbp[revious] [N]
		分割窗口并至缓冲区列表往前第 [N] 个缓冲区。如果到了缓冲区列表
		的顶端，则从末尾往前循环。使用 'switchbuf'

+-*/+-*/+-*/sbrewind c 分割窗口并转到缓冲区列表的第一个文件
							*:sbr* *:sbrewind*
:sbr[ewind]	分割窗口并至缓冲区列表中的第一个缓冲区。如果列表为空，则转到第
		一个列表外缓冲区。
		还需考虑 'switchbuf' 选项。

+-*/+-*/+-*/sbuffer c 分割窗口并转到缓冲区列表的某一个文件
:[N]sb[uffer] [N]					*:sb* *:sbuffer*
		分割窗口并编辑缓冲区列表中第 [N] 个缓冲区，如果没指定 [N]，就
		编辑当前的缓冲区。分割时，适用 'switchbuf' 的 "useopen" 设置。
		这个命令同样可以编辑不在列表里的缓冲区，'buflisted' 不会因而被
		置位。

+-*/+-*/+-*/scrollbind o 其他窗口滚动时滚动当前窗口
			*'scrollbind'* *'scb'* *'noscrollbind'* *'noscb'*
'scrollbind' 'scb'	布尔型  (缺省关闭)
			局部于窗口
			{Vi 无此功能}
			{仅当编译时加入 |+scrollbind| 特性才有效}
	另见 |scroll-binding|。如果置位此选项，当前窗口随着其它的 scrollbind
	窗口 (同样置位此选项的窗口) 一起滚动。此选项可用于查看文件两个版本的差
	异，见 'diff'。
	|'scrollopt'| 解释决定本选项如何解释的相关选项。
	分割窗口以编辑其它文件时，多复位此选项。这意味着 ":split | edit file"
	产生两个置位 scrollbind 的窗口，但 ":split file" 不会。


+-*/+-*/+-*/sfind c 分割当前窗口并编辑 'path' 的文件
:[N]sf[ind] [++opt] [+cmd] {file}		*:sf* *:sfind* *splitfind*
		与 ":split" 命令相同，但是会在 'path' 里寻找 {file}，就像
		|:find| 那样。如果找不到，就不会分割窗口。

+-*/+-*/+-*/split c 分割当前窗口
:[N]sp[lit] [++opt] [+cmd]				*:sp* *:split*
		把当前窗口分割成两个，结果是两个窗口显示同一个文件。新打开的窗
		口高度为 N (默认值是当前窗口高度的一半)。减少当前窗口的高度，
		空出地方给新的窗口 (如果你置位了 'equalalways' 选项，并且
		'eadirection' 没有设置为 "hor"，并且其它窗口中的一个高于当前或
		新窗口的话，其它窗口也被影响)。
		备注: 不是在所有的终端都能使用 CTRL-S，并且可能导致不能继续输
		入，遇到这种情况，用 CTRL-Q 继续。参见 |++opt| 和 |+cmd|。

+-*/+-*/+-*/splitbelow o 分割窗口时新窗口在当前窗口之下
			*'splitbelow'* *'sb'* *'nosplitbelow'* *'nosb'*
'splitbelow' 'sb'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	如果打开，窗口的分割会把新窗口放到当前窗口之下。|:split|


+-*/+-*/+-*/splitright o 新窗口在当前窗口之右
			*'splitright'* *'spr'* *'nosplitright'* *'nospr'*
'splitright' 'spr'	布尔型	(缺省关闭)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+vertsplit| 特性才有效}
	如果打开，窗口的分割会把新窗口放到当前窗口之右。|:split|


+-*/+-*/+-*/sview c 分割窗口并以只读模式编辑文件
:[N]sv[iew] [++opt] [+cmd] {file}		*:sv* *:sview* *splitview*
		与 ":split" 命令相同，但是会给缓冲区置位 'readonly' 选项。

+-*/+-*/+-*/topleft c 使得分割的窗口出现在顶部或者最左端
						*:topleft* *E442*
:to[pleft] {cmd}
		执行 {cmd}。如果包含一个分割窗口的命令，那么该窗口出现在顶部，
		并且占据最大宽度。当垂直分割窗口时，窗口出现在最左边，并且占据
		最大高度。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/vertical c 使得跟随的命令垂直分割
						*:vert* *:vertical*
:vert[ical] {cmd}
		执行 {cmd}。如果包含一个分割窗口的命令，那么将垂直分割窗口。
		不能用于 |:execute| 和 |:normal|。

+-*/+-*/+-*/vnew c 建立新的空白窗口，垂直分割
:[N]vne[w] [++opt] [+cmd] [file]			*:vne* *:vnew*
		与 |:new| 命令相似，但是它垂直分割窗口，如果打开了
		'equalalways' 选项，并且选项 'eadirection' 没有设置为 "ver"，
		窗口会被均匀地水平铺开，除非你给出了指定窗口宽度的参数。

+-*/+-*/+-*/vsplit c 垂直分割当前窗口
:[N]vs[plit] [++opt] [+cmd] [file]			*:vs* *:vsplit*
		与 |:split| 类似，但垂直分割窗口。满足以下条件的话，窗口会被均
		匀地水平铺开:
		1. 没有指定宽度，
		2. 打开了 'equalalways' 选项，
		3. 'eadirection' 不是 "ver"，且
		4. 其它窗口中的一个宽于当前或新窗口。
		备注: 在其它地方 CTRL-Q 与 CTRL-V 相同，但是在这里不是！

+-*/+-*/+-*/winminheight o 任何窗口的最少行数
						*'winminheight'* *'wmh'*
'winminheight' 'wmh'	数值型	(缺省为 1)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+windows| 特性才有效}
	非当前窗口的最小高度。
	这是一个绝对的最小值，窗口决不会比这更小。
	如果设为零，在需要的话，窗口可能被 "挤压" 为零行 (也就是，只有状态
	行)。激活它们时，至少给出一行 (因为光标总要在什么地方显示的)。
	使用 'winheight' 设置当前窗口的最小高度。
	本选项只有在窗口会变的更小时才会检查。不要使用很大的值。不然，如果打开
	窗口变多，会报错。设为 0 到 3 的值是合理的。


+-*/外部程序 _
+-*/+-*/equalprg o ""="" 命令使用的外部命令
						*'equalprg'* *'ep'*
'equalprg' 'ep'		字符串	(缺省为 "")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	"=" 命令使用的外部程序。如果本选项为空，使用内部的排版函数: 'lisp'、
	'cindent' 或 'indentexpr'。如果 Vim 编译时未带内部的排版功能，使用外部
	的 "indent" 程序。
	环境变量被扩展 |:set_env|。|option-backslash| 说明如何包含空格和反斜
	杠。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/formatexpr o ""gq"" 命令使用的表达式
						*'formatexpr'* *'fex'*
'formatexpr' 'fex'	字符串 (缺省 "")
			局部于缓冲区
			{Vi 无此功能}
			{仅当编译时加入 |+eval| 特性才有效}
	|gq| 操作符或自动排版时 (见 'formatoptions') 计算如何对行范围排版的表
	达式。如果此选项为空，使用 'formatprg'。

	|v:lnum|  变量保存要排版的第一行。
	|v:count| 变量保存要排版的行数。
	|v:char|  变量如果因为自动排版而计算该表达式，保存将要插入的字符。可以
		  为空，这时还不要插入！

	例如: >
		:set formatexpr=mylang#Format()
<	调用 mylang#Format() 函数，它在 'runtimepath' 里的 autoload/myland.vim
	文件里定义。|autoload|

	如果设置 'textwidth' 并且新加的文本超过此界限，也计算本表达式。这和内
	部排版发生的条件一样。确保光标到达相对于文本而言相同的位置！|mode()|
	函数在此情形下会返回 "i" 或 "R"。
	
	函数如果返回非零，Vim 依旧使用内部的排版机制。

	可能在沙盘 |sandbox| 里计算此表达式。见 |sandbox-option|。


+-*/+-*/formatlistpat o 识别列表头部的模式
					*'formatlistpat'* *'flp'*
'formatlistpat' 'flp'	字符串 (缺省: "^\s*\d\+[\]:.)}\t ]\s*")
			局部于缓冲区
			{Vi 无此功能}
	识别列表头部的模式。用于 'formatoptions' 里的 'n' 标志位。
	该模式必须和下面的行要出现的缩进完全匹配。你可以用 |/\ze| 来标记匹配的
	尾部，即使其后还有更多的字符要检查。模式之后必须要有一个字符，如果匹配
	整行，就像没有匹配那样。
	缺省设置匹配数值，后跟可选的字符和空白。


+-*/+-*/formatoptions o 自动排版完成的方式
					*'formatoptions'* *'fo'*
'formatoptions' 'fo'	字符串 (Vim 缺省: "tcq"，Vi 缺省: "vt")
			局部于缓冲区
			{Vi 无此功能}
	描述自动排版如何进行的字母序列。见 |fo-table|。如果置位 'paste' 选项，
	不进行排版 (如同 'formatoptions' 为空)。可以插入逗号，以增加可读性。
	建议使用 ":set" 的 "+=" 和 "-=" 特性，这可以避免未来版本增加新的标志位
	时出现的问题 |add-option-flags|。
	注意: 如果置位 'compatible'，本选项被设为 Vi 的缺省值。相反，如果复位
	'compatible'，本选项被设为 Vim 的缺省值。


+-*/+-*/formatprg o ""gq"" 命令使用的外部程序
						*'formatprg'* *'fp'*
'formatprg' 'fp'	字符串 (缺省为 "")
			全局
			{Vi 无此功能}
	|gq| 命令排版时，在选择的行上使用的外部程序的名字。该程序必须能读取标
	准输入并在标准输出上返回结果。Unix 程序 "fmt" 是这样的一个程序。
	如果 'formatexpr' 选项非空，用它而不是本选项。否则，如果本选项为空字符
	串，使用内部的排版函数 |C-indenting|。
	环境变量被扩展 |:set_env|。|option-backslash| 说明如何包含空格和反斜
	杠。
	可能在沙盘 |sandbox| 里计算此表达式。见 |sandbox-option|。


+-*/+-*/grepformat o 'grepprg' 的输出格式
						*'grepformat'* *'gfm'*
'grepformat' 'gfm'	字符串	(缺省为 "%f:%l%m,%f  %l%m")
			全局
			{Vi 无此功能}
	识别 ":grep" 命令输出的格式。
	这是类似于 scanf 格式的字符串，和 'errorformat' 选项使用的格式相同:
	|errorformat|。


+-*/+-*/grepprg o "":grep"" 使用的程序
						*'grepprg'* *'gp'*
'grepprg' 'gp'		字符串	(缺省为 "grep -n "，
					Unix: "grep -n $* /dev/null"，
					Win32: "findstr /n" 或 "grep -n"，
					VMS: "SEARCH/NUMBERS ")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	|:grep| 命令使用的程序。本选项可以包含 '%' 和 '#' 字符，其扩展方法和命
	令行上的相同。占位符 "$*" 指定包含参数的位置。环境变量被扩展
	|:set_env|。|option-backslash| 说明如何包含空格和反斜杠。
	如果你的 "grep" 接受 "-H" 参数，如下的设置使得 ":grep" 也能接受单个文
	件: >
		:set grepprg=grep\ -nH
<	特殊值: 若 'grepprg' 设为 "internal"，|:grep| 命令相当于 |:vimgrep|，
	|:lgrep| 相当于 |:lvimgrep|，|:grepadd| 相当于 |:vimgrepadd| 而
	|:lgrepadd| 相当于 |:lvimgrepadd|。
	另见 |:make_makeprg| 一节，因为多数那里的说明也同样适用于 'grepprg'。
	Win32 上，如果能找到 "findstr.exe" 的话，缺省值为 "findstr /n"。否则，
	缺省值为 "grep -n"。
	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/keywordprg o ""K"" 命令所使用的程序
					*'keywordprg'* *'kp'*
'keywordprg' 'kp'	字符串	(缺省为 "man" 或 "man -s"，DOS: ":help"，
					OS/2: "view /"，VMS: "help")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	|K| 命令使用的程序。环境变量被扩展 |:set_env|。设为 ":help" 可以访问
	Vim 的内部帮助。(注意 过去设置全局选项为空值可以做到这一点，现在该方法
	已过时。)
	如果使用 "man"，Vim 自动把 "K" 命令的计数翻译为节号。使用 "man -s" 也
	是一样，此时如果没有计数就删掉 "-s"。
	|option-backslash| 说明如何包含空格和反斜杠。
	示例: >
		:set keywordprg=man\ -s
<	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/lua c 执行 |Lua| 命令
							*:lua*
:[range]lua {chunk}
			执行 Lua 语言块 {chunk}。{Vi 无此功能}

+-*/+-*/luado c 对每行都执行 Lua 命令
							*:luado*
:[range]luado {body}	在 [range] 行范围的每行执行 Lua 函数
			"function (line) {body} end"，其中，函数参数是每行的文
			本，结尾的 <EOL> 不计。函数返回值为字符串时用来替代当
			前行的文本。缺省的 [range] 是整个文件: "1,$"。
			{Vi 无此功能}

+-*/+-*/luafile c 执行 |Lua| 脚本文件
							*:luafile*
:[range]luafile {file}
			执行 Lua {file} 文件中的脚本. {Vi 无此功能}
			整个参数用作单个文件名。

+-*/+-*/makeprg o "":make"" 命令所用的程序
						*'makeprg'* *'mp'*
'makeprg' 'mp'		字符串	(缺省为 "make"，VMS: "MMS")
			全局或局部于缓冲区 |global-local|
			{Vi 无此功能}
	":make" 命令使用的程序。见 |make_makeprg|。
	本选项可包含 '%' 和 '#' 字符，分别扩展为当前和轮换文件名。|:_%| |:_#|
	环境变量被扩展 |:set_env|。|option-backslash| 说明如何包含空格和反斜
	杠。
	注意 '|' 必须转义两次: 一次为了 ":set"，一次为了命令的解释。如果你使用
	名为 "myfilter" 的过滤程序，这么做: >
	    :set makeprg=gmake\ \\\|\ myfilter
<	可以给出占位符 "$*" (甚至多次) 来指示包含参数的位置。例如: >
	    :set makeprg=latex\ \\\\nonstopmode\ \\\\input\\{$*}
<	为了安全原因，本选项不能在 |modeline| 或 |sandbox| 里设置。


+-*/+-*/mzeval f 计算 |MzScheme| 表达式
mzeval({expr})							*mzeval()*
		计算 MzScheme 表达式 {expr} 并返回计算结果，转换为 Vim 本身的
		数据结构。
		数值和字符串返回本身。
		组对 (pair) (包含列表 (list) 和非常规列表 (improper list)) 和
		向量 (vector) 以 Vim |List| 形式返回。
		哈希表 (hash table) 以 Vim |Dictionary| 形式返回，其键转换成字
		符串。
		所有其它类型依 display 函数调用的结果转换为字符串。
		示例: >
		    :mz (define l (list 1 2 3))
		    :mz (define h (make-hash)) (hash-set! h "list" l)
		    :echo mzeval("l")
		    :echo mzeval("h")
<
		{仅当编译时带 |+mzscheme| 特性才有效}


+-*/+-*/mzfile c 执行 MzScheme 脚本文件
							*:mzfile* *:mzf*
:[range]mzf[ile] {file}	执行 {file} 文件里的 MzScheme 脚本。{Vi 无此功能}

+-*/+-*/mzquantum o MzScheme 线程的轮询间隔
						    *'mzquantum'* *'mzq'*
'mzquantum' 'mzq'	数值型	(缺省为 100)
			全局
			{Vi 无此功能}
			{仅当编译时加入 |+mzscheme| 特性才有效}
	轮询 MzScheme 线程的毫秒计的时间间隔。负数或零意味着没有线程调度。


+-*/+-*/mzscheme c 执行 MzScheme 命令
							*:mzscheme* *:mz*
:[range]mz[scheme] {stmt}
			执行 MzScheme 语句 {stmt}。{Vi 无此功能}

+-*/+-*/nbclose c 关闭当前 Netbeans 会话
							*:nbclose*
:nbc[lose]		关闭当前 NetBeans 会话。删除所有放置的标号。

+-*/+-*/nbkey c 传递一个键给 Netbeans
							*:nbkey*
:nb[key] {key}		把 {key} 传递给 Vim 控制器进行处理

+-*/+-*/nbstart c 打开一个新的 Netbeans 会话
							*:nbstart* *E511*
:nbs[tart] {connection}	使用 {connection} 作为套接字连接参数，启动新的
			NetBeans 会话。{connection} 的格式见
			|netbeans-parameters|。在任何时候，用户可以用以下命令
			检查 netbeans 套接字是否已连接:
			':echo has("netbeans_enabled")'

+-*/+-*/perl c 执行 Perl 命令
							*:perl* *:pe*
:pe[rl] {cmd}		执行 Perl 命令 {cmd}。当前包是 "main"。

+-*/+-*/perldo c 对每行都执行 Perl 命令
							*:perldo* *:perld*
:[range]perld[o] {cmd}  对 [range] 中的每行执行 Perl 命令 {cmd}，同时 $_ 依次
			被赋值为每行的文本，但不包括行尾的 <EOL>。改变 $_ 会改
			变每行的内容，但注意不能用这个命令添加或者删除行。
			[range] 的缺省值是整个文件: "1，$"。

+-*/+-*/py3 c 执行 Python 3 命令
							*:py3* *:python3*
|:py3| 和 |:python3| 命令和 |:python| 类似。
							*:py3file*
|:py3file| 命令和 |:pyfile| 类似。

+-*/+-*/py3file c 执行 Python 3 脚本文件
							*:py3file*
|:py3file| 命令和 |:pyfile| 类似。

+-*/+-*/pyfile c 执行 Python 脚本文件
							*:pyfile* *:pyf*
:[range]pyf[ile] {file}	
			执行 {file} 文件中包含的 Python 脚本。整个参数被用作一
			个文件名。 {Vi 无此功能}

+-*/+-*/python c 执行 Python 命令
					*:python* *:py* *E205* *E263* *E264*
:[range]py[thon] {stmt}
			执行 Python 语句 {stmt}。

+-*/+-*/python3 c 同 :py3
							*:py3* *:python3*
|:py3| 和 |:python3| 命令和 |:python| 类似。
							*:py3file*
|:py3file| 命令和 |:pyfile| 类似。

+-*/+-*/ruby c 执行 Ruby 命令
							*:ruby* *:rub*
:rub[y] {cmd}		执行 Ruby 命令 {cmd}。

+-*/+-*/rubydo c 对每行执行 Ruby 命令
						*:rubydo* *:rubyd* *E265*
:[range]rubyd[o] {cmd}	在 [range] 界定的每行上分别执行 Ruby 命令 {cmd}，执行
			时，$_ 设为相应的行文本，不含结尾的 <EOL>。修改 $_ 就
			会修改相应的行，不过要 注意: 此命令不能用来增加或者删
			除行。
			缺省的 [range] 是整个文件: "1,$"。

+-*/+-*/rubyfile c 执行 Ruby 脚本文件
							*:rubyfile* *:rubyf*
:rubyf[ile] {file}	执行 Ruby 脚本文件 {file}。这和 ":ruby load 'file'" 相
			当，但可用文件名自动补全功能。

+-*/+-*/sniff c 发送请求到 sniff
			    *:sniff* *:sni*
:sni[ff] request [symbol]   给 sniff 发送请求 request 和带一个可选的参数
			    symbol。 {Vi 无此功能}
:sni[ff]		    显示所有可能的请求和连接状态

+-*/+-*/tcl c 执行 Tcl 命令
							*:tcl* *:tc*
:tc[l] {cmd}		执行 Tcl 命令 {cmd}。

+-*/+-*/tcldo c 为每行执行 Tcl 命令
							*:tcldo* *:tcld*
:[range]tcld[o] {cmd}	对 [range] 范围内的每行执行 Tcl 命令 {cmd}。执行过程
			中，变量 "line" 被赋值为每行的文本，"lnum" 为相应的行
			号。改变 "line" 会改变文本，但是你不能用此命令增加或者
			删除行。如果 {cmd} 有错，整个命令被中断。缺省的范围
			[range] 是整个文件，"1,$"。参见 |tcl-var-line| 和
			|tcl-var-lnum|。 {Vi 无此功能}

+-*/+-*/tclfile c 执行 Tcl 脚本文件
							*:tclfile* *:tclf*
:tclf[ile] {file}	执行 Tcl 脚本文件 {file}。它和 ":tcl source {file}" 相
			当，但可用文件名自动补全功能。 {Vi 无此功能}

+-*/+-*/wsverb c 把动词通过 IPC 发送给 workshop
						*:ws* *:wsverb*
:ws[verb] verb			把 verb 传到 verb 执行程序。

+-*/v:var _
+-*/+-*/beval_col v 鼠标指针所在的列号
v:beval_col	鼠标指针所在的列号，即 |v:beval_lnum| 行中的字节位置。
		仅当计算 'balloonexpr' 选项时有效。
+-*/+-*/beval_bufnr v 鼠标指针所在的缓冲区号。仅当计算 'balloonexpr' 选项时有效。
v:beval_bufnr	鼠标指针所在的缓冲区号。仅当计算 'balloonexpr' 选项时有效。
+-*/+-*/beval_lnum v 鼠标指针所在的行号。仅当计算 'balloonexpr' 选项时有效。
v:beval_lnum	鼠标指针所在的行号。仅当计算 'balloonexpr' 选项时有效。
+-*/+-*/beval_text v 鼠标指针所在或之后的文本。
v:beval_text	鼠标指针所在或之后的文本。
		通常是一个单词，可用于调试 C 程序。
		此处用到 'iskeyword'，但也包括此位置之前的句号和 "->"。如果在
		']' 上，使用它之前的文本，包括匹配的 '[' 和它之前的单词。如果
		在单行的可视区域上，使用高亮文本。
		仅当计算 'balloonexpr' 选项时有效。
+-*/+-*/beval_winnr v 鼠标指针所在的窗口号。仅当计算 'balloonexpr' 选项时有效。
v:beval_winnr	鼠标指针所在的窗口号。仅当计算 'balloonexpr' 选项时有效。
+-*/+-*/char v 	计算 'formatexpr' 时使用的参数和用于带 <expr> 的缩写中输入的字符
v:char		计算 'formatexpr' 时使用的参数和用于带 <expr> 的缩写中输入的字符
+-*/+-*/charconvert_from v 要转换的文件字符编码名。只在计算 'charconvert' 选项时有效。
v:charconvert_from	要转换的文件字符编码名。只在计算 'charconvert' 选项时有效。
+-*/+-*/charconvert_to v 转换后的文件字符编码名。只在计算 'charconvert' 选项时有效。
v:charconvert_to	转换后的文件字符编码名。只在计算 'charconvert' 选项时有效。
+-*/+-*/cmdarg v 文件读写命令的额外参数
v:cmdarg	文件读写命令的额外参数
		该变量有两个目的:
		1. 文件读写命令的额外参数。目前，它们包括 "++enc=" 和
		   "++ff="。该变量在文件读写命令的自动命令事件激活之前设置。开
		   头有一个空格，以便直接把该变量附加到读写命令之后。注意: 这
		   里不包括 "+cmd" 参数，因为它总要被执行的。
		2. 使用 ":hardcopy" 打印 PostScript 文件时，":hardcopy" 命令的
		   参数。在 'printexpr' 里用得到。
+-*/+-*/cmdbang v 文件读写命令时，和 v:cmdarg 设置的时间类似。
v:cmdbang	文件读写命令时，和 v:cmdarg 设置的时间类似。
		如果使用了 "!"，其
		值为 1，不然为 0。注意 它只能用于自动命令。用户命令里可以用
		|<bang>|。
+-*/+-*/count v 	最近的普通模式命令使用的计数。在映射前可用于得到计数。只读。
v:count		最近的普通模式命令使用的计数。在映射前可用于得到计数。只读。
		例如: >
	:map _x :<C-U>echo "计数为 " . v:count<CR>
<		注意: <C-U> 是必要的，它删除紧跟在计数之后 ':' 所给出的行范
		围。
		如果有两个计数，如 "3d2w"，它们进行相乘，如同命令行实际发生的
		那样，等同于 "d6w"。
		也用于计算 'formatexpr' 选项。
		为了后向兼容，这里也可以用 "count"。
+-*/+-*/count1 v 类似于 "v:count"，但没有给出计数时，缺省为 1。
v:count1	类似于 "v:count"，但没有给出计数时，缺省为 1。
+-*/+-*/ctype v 	运行环境当前的字符 locale 设置。
v:ctype		运行环境当前的字符 locale 设置。
		它使得 Vim 脚本能得到当前的
		locale 编码。技术细节: 这就是 LC_CTYPE 的值。如果没有使用
		locale，其值为 "C"。
		该变量不能直接设置，请使用 |:language| 命令。
		见 |multi-lang|。
+-*/+-*/dying v 	通常为零。如果捕获到某个 "致命" 的 signal，设为 1。
v:dying		通常为零。如果捕获到某个 "致命" 的 signal，设为 1。
		如果同时捕
		获到多个 signal，其值相应增加。在自动命令里可以用来检查 Vim
		是否被异常终止。{仅限于 Unix}
		例如: >
	:au VimLeave * if v:dying | echo "\nAAAAaaaarrrggghhhh!!!\n" | endif
<		备注: 如果 v:dying 为一而同时又捕捉到另一个致命的 signal，不执
		行 VimLeave 自动命令。
+-*/+-*/errmsg v 最近给出的错误信息。该变量可以设置。
v:errmsg	最近给出的错误信息。该变量可以设置。
		例如: >
	:let v:errmsg = ""
	:silent! next
	:if v:errmsg != ""
	:  ... handle error
<		为了后向兼容，这里也可以用 "errmsg"。
+-*/+-*/exception v 最近捕获且没有完成的例外的值。
v:exception	最近捕获且没有完成的例外的值。
		见 |v:throwpoint| 和 |throw-variables|。
		例如: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "caught" v:exception
	:endtry
<		输出: "caught oops"。
+-*/+-*/fcs_reason v 激活 |FileChangedShell| 事件的原因。
v:fcs_reason	激活 |FileChangedShell| 事件的原因。
		可以在自动命令里用来决定该做什么和/或如何设置 v:fcs_choice。可
		能的值是:
			deleted		文件不再存在
			conflict	文件内容、模式或修改时间被改变，而缓冲
					区同时被修改
			changed		文件内容被改变
			mode		文件模式被改变
			time		文件修改时间被改变
+-*/+-*/fcs_choice v |FileChangedShell| 事件激活后该做什么。可以在自动命令里用来告
v:fcs_choice	|FileChangedShell| 事件激活后该做什么。可以在自动命令里用来告
		诉 Vim 如何处理涉及的缓冲区:
			reload		重新载入缓冲区 (如果文件已删除，不能工
					作)。
			ask		询问用户该做什么，就像没有自动命令一
					样。不过，如果只有修改时间被改变，不做
					任何事。
			<空>		不做任何事。自动命令应该已经处理完毕。
		缺省为空。如果使用别的 (非法的) 值，Vim 的行为就像它为空一样。
		不会有警告信息。
+-*/+-*/fname_in v 输入文件名。
v:fname_in	输入文件名。
		在计算以下选项时合法:
			选项		用于 ~
			'charconvert'	要转换的文件
			'diffexpr'	原始文件
			'patchexpr'	原始文件
			'printexpr'	要打印的文件
		|SwapExists| 里设为交换文件名。
+-*/+-*/fname_out v 输出文件名。
v:fname_out	输出文件名。
		只有在计算以下选项时才合法:
			选项		用于 ~
			'charconvert'	生成的转换完成的文件 (*)
			'diffexpr'	diff 的结果
			'patchexpr'	产生的补丁文件
		(*) 如果用于为写入命令进行转换 (比如，":w file")，等价于
		v:fname_in。如果用于为读入命令进行转换 (比如，":e file")，它是
		一个临时文件名，和 v:fname_in 不同。
+-*/+-*/fname_new v 文件新版本的名字。只有在计算 'diffexpr' 的时候才有效。
v:fname_new	文件新版本的名字。只有在计算 'diffexpr' 的时候才有效。
+-*/+-*/fname_diff v 比较结果 (或补丁) 的文件名。只有在计算 'patchexpr' 的时候才有效。
v:fname_diff	比较结果 (或补丁) 的文件名。只有在计算 'patchexpr' 的时候才有效。
+-*/+-*/folddashes v 用于 'foldtext' 反映关闭的折叠的折叠级别的连字符。
v:folddashes	用于 'foldtext' 反映关闭的折叠的折叠级别的连字符。
+-*/+-*/foldlevel v 用于 'foldtext': 关闭的折叠的折叠级别。
v:foldlevel	用于 'foldtext': 关闭的折叠的折叠级别。
+-*/+-*/foldend v 用于 'foldtext': 关闭的折叠的最后一行。
v:foldend	用于 'foldtext': 关闭的折叠的最后一行。
+-*/+-*/foldstart v 用于 'foldtext': 关闭的折叠的第一行。
v:foldstart	用于 'foldtext': 关闭的折叠的第一行。
+-*/+-*/insertmode v 用于 |InsertEnter| 和 |InsertChange| 自动命令事件。
v:insertmode	用于 |InsertEnter| 和 |InsertChange| 自动命令事件。
		取值:
			i	插入模式
			r	替换模式
			v	虚拟替换模式
+-*/+-*/key v 	|Dictionary| 里当前项目的键。
v:key		|Dictionary| 里当前项目的键。
		只有在 |map()| 和 |filter()| 里计算表达式时有效。只读。
+-*/+-*/lang v 	运行环境当前的消息 locale 设置。
v:lang		运行环境当前的消息 locale 设置。
		它使得 Vim 脚本能得到当前使用
		的语言。技术细节: 这就是 LC_MESSAGES 的值。该值和系统有关。
		该变量不能直接设置，请使用 |:language| 命令。
		它和 |v:ctype| 不同，因为消息可能使用不同于字符编码的语言。见
		|multi-lang|。
+-*/+-*/lc_time v 运行环境当前的时间消息 locale 设置。
v:lc_time	运行环境当前的时间消息 locale 设置。
		它使得 Vim 脚本能得到当前使用的语言。
		技术细节: 这就是 LC_TIME 的值。
		该变量不能直接设置，请使用 |:language| 命令。见 |multi-lang|。
+-*/+-*/lnum v 	标签页号或行号
v:lnum		标签页号或行号
		'foldexpr' |fold-expr|、'formatexpr' 和 'indentexpr' 表达式中
		的行号和 'guitablevel' 和 'guitabtooltip' 中的标签页号。只有在
		计算这些表达式时才合法。在 |sandbox| 里时只读。
+-*/+-*/mouse_win v 用 |getchar()| 得到鼠标点击时所在的窗口号。
v:mouse_win	用 |getchar()| 得到鼠标点击时所在的窗口号。
		首个窗口的编号为1 ，就像 |winnr()| 那样。
		如果那时没有鼠标点击，该值为零。
+-*/+-*/mouse_lnum v 用 |getchar()| 得到鼠标点击时所在的行号。
v:mouse_lnum	用 |getchar()| 得到鼠标点击时所在的行号。
		这是文本行号，不是屏幕行号。如果那时没有鼠标点击，该值为零。
+-*/+-*/mouse_col v 用 |getchar()| 得到鼠标点击时所在的列号。
v:mouse_col	用 |getchar()| 得到鼠标点击时所在的列号。
		这是屏幕列号，就像 |virtcol()| 那样。
		如果那时没有鼠标点击，该值为零。
+-*/+-*/oldfiles v 启动时从 |viminfo| 文件载入的文件名列表。
v:oldfiles	启动时从 |viminfo| 文件载入的文件名列表。
		Vim 记住的位置标记所在的就是这些文件。
		列表长度的上限由 'viminfo' 选项的 ' 参数定义(缺省是 100)。
		另见 |:oldfiles| 和 |c_#<|。
		此列表可修改，但并不影响之后 |viminfo| 文件保存什么。同时，如
		果使用非字符串的值，会有问题。
		{仅当编译时加入 |+viminfo| 特性才有效}
+-*/+-*/operator v 普通模式给出的最近的操作符。
v:operator	普通模式给出的最近的操作符。
		除了 <g> 或 <z> 开始的命令是两个字符外，这是单个字符。
		最好和 |v:prevcount| 和 |v:register| 一起使用。常常，
		先中止操作符等待模式，然后使用操作符，例如: >
			:omap O <Esc>:call MyMotion(v:operator)<CR>
<		直到输入下一个操作符之前，该值保持不变。因此不要期待该值会为
		空。
		|:delete|、|:yank| 或其它 Ex 命令不改变 v:operator。
		只读。
+-*/+-*/prevcount v 倒数第二次的普通模式命令使用的计数，
v:prevcount	倒数第二次的普通模式命令使用的计数，
		也就是再上一个命令用的 v:count 的值。
		可以用来先中止可视模式或操作符等待模式，然后使用
		计数。 >
			:vmap % <Esc>:call MyFilter(v:prevcount)<CR>
<		只读。
+-*/+-*/profiling v 通常为零。开始用 ":profile start" 之后设为一。见 |profiling|。
v:profiling	通常为零。开始用 ":profile start" 之后设为一。见 |profiling|。
+-*/+-*/progname v 包含 Vim 启动时使用的名字 (路径已被去掉)。
v:progname	包含 Vim 启动时使用的名字 (路径已被去掉)。
		可以用来为 "view"、"evim" 等符号链接到 Vim 的名字提供特殊的设置。
		只读。
+-*/+-*/register v 最近的普通模式命令使用的寄存器名字。如果没有使用过，为空。
v:register	最近的普通模式命令使用的寄存器名字。如果没有使用过，为空。
+-*/+-*/scrollstart v 指示使屏幕上滚的脚本或函数的字符串。
v:scrollstart	指示使屏幕上滚的脚本或函数的字符串。
		只有在原来为空时才设置，因此只记住第一个原因。
		如果来自输入的命令，设为 "Unknown"。
		可以用来发现你的脚本为什么产生 hit-enter 提示。
+-*/+-*/servername v 如果有的话，注册过的 |x11-clientserver| 名字。
v:servername	如果有的话，注册过的 |x11-clientserver| 名字。
+-*/+-*/searchforward v 搜索方向: 
v:searchforward	搜索方向: 
		正向搜索后为 1，反向搜索后为 0。直接设置最近搜索模式
		会复位此值为正向，见 |quote/|。
		注意 从函数返回时该值被复原 |function-search-undo|。
		可读写。
+-*/+-*/shell_error v 最近一次外壳命令的返回值。
v:shell_error	最近一次外壳命令的返回值。
		如果非零，最近一次外壳命令有错。如果为零，则该命令成功返回。
		这只有在外壳把错误代码返回给 Vim 的时候才工作。
		-1 通常用来告知该命令无法执行。只读。
		例如: >
	:!mv foo bar
	:if v:shell_error
	:  echo '不能把 "foo" 换名为 "bar"!'
	:endif
<		为了后向兼容，这里也可以用 "shell_error"。
+-*/+-*/statusmsg v 最近给出的状态消息。可以设置该变量。
v:statusmsg	最近给出的状态消息。可以设置该变量。
+-*/+-*/swapname v 只有在执行 |SwapExists| 自动命令时才合法: 找到的交换文件名。
v:swapname	只有在执行 |SwapExists| 自动命令时才合法: 找到的交换文件名。
+-*/+-*/swapchoice v |SwapExists| 自动命令可以设置此值，
v:swapchoice	|SwapExists| 自动命令可以设置此值，
		以选择如何处理已有交换文件:
			'o'	以只读方式打开
			'e'	仍然编辑
			'r'	恢复
			'd'	删除交换文件
			'q'	退出
			'a'	中止
		该值应是单个字符的字符串。如果为空，用户会被询问，就像没有
		SwapExists 自动命令那样。缺省为空。
+-*/+-*/swapcommand v 打开文件后执行的普通模式命令。
v:swapcommand	打开文件后执行的普通模式命令。
		可以用于 |SwapExists| 自动命令，
		用以让另一个 Vim 打开文件并跳转到合适的位置。例如，要跳转到某
		标签，用的值是 ":tag tagname\r"。":edit +cmd file" 用的值是
		":cmd\r"。
+-*/+-*/termresponse v 使用 |t_RV| termcap 项目返回的终端的转义序列。
v:termresponse	使用 |t_RV| termcap 项目返回的终端的转义序列。
Vim 收到 ESC [ 或者 CSI 开始，以一个 'c' 结束，并且其间只包含数字，';' 和 '.'
		的转义序列的时候，会设置该值。
		如果设置该选项，会激活 TermResponse 自动命令事件，这样你就可以
		对终端的应答做出反应。
		新的 xterm 的应答是: "<Esc>[ Pp ; Pv ; Pc c"。 Pp 是终端类型:
		0 代表 vt100，而 1 代表 vt220。 Pv 是补丁号 (因为这是 patch 95
		引入的，补丁号应该总是 95 会更高)。Pc 总是零。
		{仅当编译时加入 |+termresponse| 特性才有效}
+-*/+-*/this_session v 最近载入或者保存的会话文件的文件名 |:mksession|。
v:this_session	最近载入或者保存的会话文件的文件名 |:mksession|。
		可以设置该变量。如果没有保存过会话文件，该变量为空。
		为了后向兼容，这里也可以用 "this_session"。
+-*/+-*/throwpoint v 最近捕获且未完成的例外的抛出位置。
v:throwpoint	最近捕获且未完成的例外的抛出位置。
	输入的命令不会设置此变量。另见 |v:exception| 和 |throw-variables|。
		例如: >
	:try
	:  throw "oops"
	:catch /.*/
	:  echo "Exception from" v:throwpoint
	:endtry
<		输出: "Exception from test.vim, line 2"
+-*/+-*/val v 	|List| 或 |Dictionary| 当前项目的值。
v:val		|List| 或 |Dictionary| 当前项目的值。
只有在计算 |map()| 和 |filter()| 里的表达式时才有效。只读。
+-*/+-*/version v Vim 的版本号
v:version	Vim 的版本号
		主版本号乘以 100 加上副版本号。5.0 版本对应的是
		500。5.1 版本 (5.01) 则是 501。只读。为了后向兼容，这里也可以
		用 "version"。
		用 |has()| 可以检查是否包含某补丁，例如: >
			if has("patch123")
<		注意 补丁号和版本有关，5.0 和 5.1 版本都有补丁号 123，但完全不
		同。
+-*/+-*/warningmsg v 最近给出的警告消息。该变量可以设置。
v:warningmsg	最近给出的警告消息。该变量可以设置。
+-*/+-*/b:current_syntax o
						*b:current_syntax-variable*
根据当前激活的是哪部语法，Vim 把载入的语法的名字保存在 "b:current_syntax" 变量
里。例如: >
   :au BufReadPost * if b:current_syntax == "csh"
   :au BufReadPost *   做一些事
   :au BufReadPost * endif
+-*/event _ 自动命令可使用的事件
+-*/+-*/读入 _
+-*/+-*/+-*/BufNewFile e		开始编辑尚不存在的文件
+-*/+-*/+-*/BufReadPre e		开始编辑新缓冲区，读入文件前
BufReadPre
开始编辑新的缓冲区并把文件读入缓冲区前。如果文件还不存在，不会有此事件。
+-*/+-*/+-*/BufRead e		开始编辑新缓冲区，读入文件后
BufRead 或 BufReadPost		开始编辑新的缓冲区并把文件读入缓冲区后，执行模
				式行之前。模式行之后的事件，见 |BufWinEnter|。
				_不_适用于 ":r file"，也不适用于文件还不存在的
				情况。但在成功修复文件之后会激活该事件。
+-*/+-*/+-*/BufReadPost e		开始编辑新缓冲区，读入文件后
BufRead 或 BufReadPost		开始编辑新的缓冲区并把文件读入缓冲区后，执行模
				式行之前。模式行之后的事件，见 |BufWinEnter|。
				_不_适用于 ":r file"，也不适用于文件还不存在的
				情况。但在成功修复文件之后会激活该事件。
+-*/+-*/+-*/BufReadCmd e		开始编辑新缓冲区前 |Cmd-event|
BufReadCmd	开始编辑新的缓冲区前。应执行把文件读入缓冲区的操作。|Cmd-event|
+-*/+-*/+-*/FileReadPre e		用 ":read" 命令读入文件前
+-*/+-*/+-*/FileReadPost e		用 ":read" 命令读入文件后
FileReadPost			":read" 命令读入文件后。
				注意 Vim 设置 '[' 和 ']' 位置标记为读入的首行
				和末行。它们可以用来操作刚读入的行范围。
+-*/+-*/+-*/FileReadCmd e		用 ":read" 命令读入文件前 |Cmd-event|
FileReadCmd			":read" 命令读入文件前。应执行把文件读入缓冲区
				的操作。|Cmd-event|
+-*/+-*/+-*/FilterReadPre e		用过滤命令读入文件前
FilterReadPre			过滤命令读入文件前。Vim 用当前缓冲区的名字来匹
				配模式，而不是过滤命令输出的临时文件名字。
				如果 'shelltemp' 关闭，不激活此事件。
+-*/+-*/+-*/FilterReadPost e	用过滤命令读入文件后
FilterReadPost			过滤命令读入文件后。Vim 用当前缓冲区的名字来匹
				配模式，正如 FilterReadPre 那样。
				如果 'shelltemp' 关闭，不激活此事件。
+-*/+-*/+-*/StdinReadPre e		从标准输入读入缓冲区前
StdinReadPre			从标准输入读取输入到缓冲区前。仅用于 Vim 启动
				时使用了 "-" 参数时发生 |--|。
+-*/+-*/+-*/StdinReadPost e		从标准输入读入缓冲区后
StdinReadPost			从标准输入读取输入到缓冲区后，执行模式行前。仅
				用于 Vim 启动时使用了 "-" 参数时发生 |--|。
+-*/+-*/写回 _
+-*/+-*/+-*/BufWrite e		开始把整个缓冲区写回到文件
+-*/+-*/+-*/BufWritePre e		开始把整个缓冲区写回到文件
+-*/+-*/+-*/BufWritePost e		把整个缓冲区写回到文件后
BufWritePost			把整个缓冲区写回到文件后 (应该撤销 BufWritePre
				的相关命令)。
+-*/+-*/+-*/BufWriteCmd e		把整个缓冲区写回到文件前 |Cmd-event|
BufWriteCmd			把整个缓冲区写回到文件前。应执行把文件写回的操
				作并在成功后复位 'modified' 标志，除非 'cpo'
				里包含了 '+' 并且写到另一个文件里 |cpo-+|。它
				不应改动缓冲区的内容。|Cmd-event|
+-*/+-*/+-*/FileWritePre e		开始把缓冲区部分内容写回到文件
FileWritePre			写入文件前，但不包括写入整个缓冲区。用 '[ 和
				'] 位置标记来定位行范围。
+-*/+-*/+-*/FileWritePost e		把缓冲区部分内容写回到文件后
FileWritePost			写入文件后，但不包括写入整个缓冲区。
+-*/+-*/+-*/FileWriteCmd e		把缓冲区部分内容写回到文件前 |Cmd-event|
FileWriteCmd			写入文件前，但不包括写入整个缓冲区。应执行写入
				文件的操作。不应改动缓冲区的内容。用 '[ 和 ']
				位置标记来定位行范围。
				|Cmd-event|
+-*/+-*/+-*/FileAppendPre e		开始附加到文件
FileAppendPre			附加到文件前。用 '[ 和 '] 位置标记来定位行范
				围。
+-*/+-*/+-*/FileAppendPost e	附加到文件后
+-*/+-*/+-*/FileAppendCmd e		附加到文件前 |Cmd-event|
FileAppendCmd			附加到文件前。应执行附加到文件的操作。用 '[ 和
				'] 位置标记来定位行范围。|Cmd-event|
+-*/+-*/+-*/FilterWritePre e	开始为过滤命令或 diff 写到文件
FilterWritePre			过滤程序写入文件或产生 diff 文件前。Vim 用当前
				缓冲区的名字来匹配模式，而不是过滤命令输出的临
				时文件名字。
				如果 'shelltemp' 关闭，不激活此事件。
+-*/+-*/+-*/FilterWritePost e	为过滤命令或 diff 写到文件后
FilterWritePost			过滤命令写入文件或产生 diff 文件后。Vim 用当前
				缓冲区的名字来匹配模式，正如 FilterWritePre 那
				样。
				如果 'shelltemp' 关闭，不激活此事件。
+-*/+-*/缓冲区 _
+-*/+-*/+-*/BufAdd e		刚把缓冲区附加到缓冲区列表后
BufAdd 或 BufCreate		缓冲区列表加入缓冲区后。可以是刚建立的新缓冲区
				或者是已有的缓冲区。
				也在缓冲区列表的某个缓冲区换名之后发生。
				BufCreate 的名称有其历史原因。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被建立的缓冲区 "<afile>" 不同。
+-*/+-*/+-*/BufCreate e		刚把缓冲区附加到缓冲区列表后
BufAdd 或 BufCreate		缓冲区列表加入缓冲区后。可以是刚建立的新缓冲区
				或者是已有的缓冲区。
				也在缓冲区列表的某个缓冲区换名之后发生。
				BufCreate 的名称有其历史原因。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被建立的缓冲区 "<afile>" 不同。
+-*/+-*/+-*/BufDelete e		从缓冲区列表删除缓冲区前
BufDelete			缓冲区列表删除缓冲区前。可能先调用 BufUnload
				事件 (如果该缓冲区已经载入的话)。
				也在缓冲区列表的某个缓冲区换名之前发生。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被删除的缓冲区 "<afile>" 及 "<afile>" 不同。
				此处不可切换到其它缓冲区，否则会引起问题。
+-*/+-*/+-*/BufWipeout e		从缓冲区列表完全删除缓冲区前
BufWipeout			完全删除缓冲区前。可能先调用 BufUnload 和
				BufDelete 事件 (如果缓冲区已经载入并且在缓冲区
				列表之中的话)。
				也在不在缓冲区列表的某个缓冲区换名之前发生。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被删除的缓冲区 "<afile>" 不同。
				此处不可切换到其它缓冲区，否则会引起问题。
+-*/+-*/+-*/BufFilePre e		改变当前缓冲区名字前
BufFilePre		":file" 或 ":saveas" 命令改变当前缓冲区的名字前。
+-*/+-*/+-*/BufFilePost e		改变当前缓冲区名字后
BufFilePost		":file" 或 ":saveas" 命令改变当前缓冲区的名字后。
+-*/+-*/+-*/BufEnter e		进入缓冲区后
BufEnter			进入缓冲区后。可用来设定有关文件类型的选项。也
				在开始编辑缓冲区时执行，它发生在 BufReadPost
				自动命令之后。
+-*/+-*/+-*/BufLeave e		转到其它缓冲区前
BufLeave			转到别的缓冲区前、或离开/关闭当前窗口并且新的
				当前窗口编辑的不是相同的缓冲区前，
				":qa" 或 ":q" 退出 Vim 时不会激活此事件。
+-*/+-*/+-*/BufWinEnter e		在窗口显示缓冲区前
BufWinEnter			窗口显示缓冲区后。可以是新缓冲区载入 (处理完模
				式行之后) 或者隐藏缓冲区在窗口开始显示 (从而不
				再隐藏)。
				不带参数的 |:split| 不激活此事件，因为你继续编
				辑的是同一个缓冲区，":split" 已在某窗口打开的
				文件也是如此，同样因为它重用已有的缓冲区。但用
				当前缓冲区名来 ":split" 却会激活本事件，因为此
				时该缓冲区被重新载入。
+-*/+-*/+-*/BufWinLeave e		从窗口删除缓冲区前
BufWinLeave			窗口删除缓冲区前。除非它在别的窗口仍然可见。
				系统退出时也会激活。在 BufUnload 或 BufHidden
				之前激活。
				注意: 当此自动命令被执行时，当前缓冲区 "%" 可
				能会和被卸载的缓冲区 "<afile>" 不同。
				退出时如果 v:dying 至少为 2，不触发此事件。
+-*/+-*/+-*/BufUnload e		卸载缓冲区前
BufUnload			缓冲区卸载前。此时，缓冲区里的文本将要被释放。
				可在 BufWritePost 后和 BufDelete 前发生。 Vim
				即将退出时，每个载入的缓冲区也会收到该事件。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被卸载的缓冲区 "<afile>" 不同。
				此处不可切换到其它缓冲区，否则会引起问题。
				退出时如果 v:dying 至少为 2，不触发此事件。
+-*/+-*/+-*/BufHidden e		刚把缓冲区变为隐藏后
BufHidden			缓冲区刚被隐藏后。也就是说，没有窗口显示该缓冲
				区，但是它没有被卸载或者删除。":qa" 或者 ":q"
				退出 Vim 时不会激活该事件。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被隐藏的缓冲区 "<afile>" 不同。
+-*/+-*/+-*/BufNew e		刚建立新缓冲区后
BufNew				刚建立新缓冲区或给缓冲区换名后。缓冲区被加到缓
				冲区列表时，同时会激活 BufAdd 事件。
				注意: 执行此自动命令时，当前缓冲区 "%" 可能会
				和被建立的缓冲区 "<afile>" 不同。
+-*/+-*/+-*/SwapExists e		检测到交换文件已经存在
SwapExists			开始编辑文件时检测到交换文件已存在。只有此时，
				可以选择处理此情形的方法，也在此时，Vim 可能会
				询问用户应该如何做。
				|v:swapname| 变量保存找到的交换文件名。<afile>
				则是待编辑的文件。|v:swapcommand| 可以包含该文
				件打开后执行的命令。
				此事件的命令应该设置 |v:swapchoice| 变量为包含
				单字符的字符串，指示 Vim 下一步应该做什么:
					'o'	以只读方式打开
					'e'	仍然编辑文件
					'r'	恢复
					'd'	删除交换文件
					'q'	退出，不编辑文件
					'a'	中止，就像按了 CTRL-C 一样
				如果设为空串，则询问用户，就像没有 SwapExists
				自动命令那样。
				此处不允许切换到其它缓冲区、为缓冲区换名或者更
				改目录。
+-*/+-*/选项 _
+-*/+-*/+-*/FileType e		设置 'filetype' 选项时
FileType			设置 'filetype' 选项时。模式匹配的是文件类型。
				<afile> 可以用来取得设置该选项的文件名，而
				<amatch> 则是 'filetype' 的新值。参见
				|filetypes|。
+-*/+-*/+-*/Syntax e		设置 'syntax' 选项时
Syntax				设置 'syntax' 选项时。模式匹配的是语法名。
				<afile> 可以用来取得设置该选项的文件名，而
				<amatch> 则是 'syntax' 的新值。参见
				|:syn-on|。
+-*/+-*/+-*/EncodingChanged e	'encoding' 选项改变后
EncodingChanged			改变 'encoding' 选项后激活。可用于设定字体。
+-*/+-*/+-*/TermChanged e		'term' 的值改变后
TermChanged			'term' 的值发生改变后。可用来重新读入语法文
				件，更新色彩、字体和其他终端相关的设置。对所
				有已载入的缓冲区执行。
+-*/+-*/启动和退出 _
+-*/+-*/+-*/VimEnter e		完成所有的初始化步骤后
VimEnter			做完所有启动任务后，包括载入 .vimrc 文件，执行
				"-c cmd" 参数，创建所有的窗口并在其中载入所有
				缓冲区。
+-*/+-*/+-*/GUIEnter e		成功启动 GUI 后
GUIEnter			成功启动 GUI 并打开窗口后。用 gvim 的时候，
				它在 VimEnter 之前发生。在 .gvimrc 里可用它来
				定位窗口: >
	:autocmd GUIEnter * winpos 100 50

+-*/+-*/+-*/TermResponse e		收到 |t_RV| 的终端应答后
TermResponse			收到终端对 |t_RV| 的应答后。
				可用 |v:termresponse| 的值判别终端版本。
+-*/+-*/+-*/VimLeavePre e		退出 Vim 前，在写入 viminfo 文件之前
VimLeavePre			退出 Vim 时刚写入 .viminfo 文件之前。如果匹配
				退出时当前缓冲区的名字匹配才会激活。只执行一
				次。通常指定 "*" 模式。 >
	:autocmd VimLeavePre * call CleanupStuff()
<				要检测非正常的退出，使用 |v:dying|。
				退出时如果 v:dying 至少为 2，不触发此事件。
+-*/+-*/+-*/VimLeave e		退出 Vim 前，在写入 viminfo 文件之后
VimLeave			退出 Vim 前，刚写入 .viminfo 文件之后。和
				VimLeavePre 一样，只执行一次。
				要检测非正常的退出，使用 |v:dying|。
				退出时如果 v:dying 至少为 2，不触发此事件。
+-*/+-*/杂项 _
+-*/+-*/+-*/FileChangedShell e	Vim 注意到文件在编辑开始后被改变
FileChangedShell		Vim 注意到文件的修改时间不同于编辑开始的时间或
				者文件属性发生改变时。|timestamp|
				该事件最有可能在执行外壳命令后发生，也可以在执
				行 |:checktime| 命令或 Gvim 重新获得输入焦点后
				发生。
				该自动命令对每个发生改变的文件进行，但不包括置
				位了 'autoread' 且 (译者注: 似乎应为或) 没发生
				改变而的缓冲区。如果指定了 FileChangedShell 自
				动命令，不会给出相应的警告消息和提示。
				|v:fcs_reason| 变量被设置，以指示发生了什么
				事，而 |v:fcs_choice| 则可用来告知 Vim 下一步
				该做什么。
				注意: 当此自动命令执行时，当前缓冲区 "%" 可能
				和被改变的缓冲区 "<afile>" 不同。
				注意: 执行的命令必须不能修改当前缓冲区，跳转到
				别的缓冲区，或者删除任何一个缓冲区。
				注意: 该事件不会嵌套而引起无限循环。这意味着，
				FileChangedShell 事件所执行的命令不会引起别的
				FileChangedShell 事件。
+-*/+-*/+-*/FileChangedShellPost e	对在编辑开始后被改变的文件的处理完成后
FileChangedShellPost	对外部改变的文件的处理完成后。可用于更新状态行。
+-*/+-*/+-*/FileChangedRO e		对只读文件进行第一次修改前
FileChangedRO			刚开始修改只读文件前。可以用来从源文件控制系统
				里更新文件。但如果该修改由自动命令产生，该事件
				不会发生。
				该事件在缓冲区的第一次修改或者 'readonly' 置位
				后的第一次修改时激活，就在文本刚刚要被修改前发
				生。
				警告: 如果在自动命令里移动了光标，此修改的效果
				无法预测。
				这里不能切换到别的缓冲区。你可以重新载入本缓冲
				区，但不能用来编辑别的文件。
+-*/+-*/+-*/ShellCmdPost e		执行外壳命令后
ShellCmdPost			执行用 |:!cmd|、|:shell|、|:make| 和 |:grep|
				指定的外壳命令后。可用于检查任何文件的改变。
+-*/+-*/+-*/ShellFilterPost e	用外壳命令执行完过滤后
ShellFilterPost			执行用 ":{range}!cmd"、":w !cmd" 或 ":r !cmd"
				指定的外壳命令后。可用于检查任何文件的改变。
+-*/+-*/+-*/FuncUndefined e		调用没有定义的用户函数
FuncUndefined			调用未定义的用户函数时。可以用来实现在实际调用
				时才提供动态定义的函数。模式匹配的是函数的名
				字。 <amatch> 和 <afile> 都被设为该函数的名
				字。见 |autoload-functions|。
+-*/+-*/+-*/SpellFileMissing e	使用不存在的拼写文件
SpellFileMissing		试图载入拼写检查文件，但找不到该文件时。模式匹
				配的是语言名。 <amatch> 指定语言，和
				'encoding' 也有关。见
				|spell-SpellFileMissing|。
+-*/+-*/+-*/SourcePre e		执行 Vim 脚本之前
SourcePre			执行 Vim 脚本前。|:source| <afile> 是待执行的
				文件名。
+-*/+-*/+-*/SourceCmd e		执行 Vim 脚本之前 |Cmd-event|
SourceCmd			执行 Vim 脚本时。|:source| <afile> 是待执行的
				文件名。自动命令应实现执行该文件的操作。
				|Cmd-event|
+-*/+-*/+-*/VimResized e		Vim 窗口大小改变后
VimResized			在 Vim 窗口的大小改变后，因而 'lines' 和/或
				'columns' 也已随之改变。不过，启动时不用。
+-*/+-*/+-*/FocusGained e		Vim 得到输入焦点
FocusGained			Vim 取得输入焦点时。只有 GUI 和少数几个控制台
				版本能检测该事件。
+-*/+-*/+-*/FocusLost e		Vim 失去输入焦点
FocusLost			Vim 失去输入焦点时。只有 GUI 和少数几个控制台
				版本能检测该事件。也有可能在弹出对话框时发生。
+-*/+-*/+-*/CursorHold e		用户有一段时间没有按键
CursorHold			用户在 'updatetime' 指定的时间里没有按键时。如
				果用户还没有按键，该事件不会再次激活 (就是说，
				如果你离开 Vim 去煮杯咖啡，该事件不会每
				'updateime' 毫秒就发生一次。:)
				|CutsorHold-example| 提供了预览标签的范例。
				该事件只有在普通模式才会激活。等待输入命令参数
				或操作符之后的动作命令时，该事件不会发生。
				记录时，不激活 CursorHold 事件。
				注意: 该事件的处理不能使用交互的命令，不会有
				按 - 回车 (hit-enter) 的提示。
				注意: 将来设定时间可能有别的选项。
				提示: 要强制更新状态行，用: >
					:let &ro = &ro
<				{仅在 Amiga、Unix、Win32、MSDOS 和所有的 GUI 
				版本上有效}
+-*/+-*/+-*/CursorHoldI e		在插入模式下，用户有一段时间没有按键
CursorHoldI			类似于 CursorHold，但用于插入模式。
+-*/+-*/+-*/CursorMoved e		普通模式下移动了光标
CursorMoved			在普通模式下移动光标后。也用于光标行的文本被改
				变时，例如，使用 "x"、"rx" 或 "p"。
				如果有预输入或在等待操作符中，不激活之。
				示例可见 |match-parens|。
				小心: 不要做任何用户意想不到或需时很久的事情。
+-*/+-*/+-*/CursorMovedI e		插入模式下移动了光标
CursorMovedI			在插入模式下移动光标后。其余细节和 CursorMoved
				相同。
+-*/+-*/+-*/WinEnter e		进入其它窗口后
WinEnter			进入别的窗口后。不包括 Vim 启动时的第一个窗
				口。
				可用来设定窗口的高度。
				如果该窗口显示缓冲区，Vim 在 WinEnter 自动命令
				之后执行 BufEnter 自动命令。
				注意: ":split fname" 时，WinEnter 事件在分割之
				后但载入 "fname" 文件之前发生。
+-*/+-*/+-*/WinLeave e		离开窗口前
WinLeave			离开某窗口前。如果将要进入的窗口要显示的是别的
				缓冲区，Vim 在 WinLeave 自动命令前先执行
				BufLeave 自动命令 (但不包括 ":new")。
				":qa" 或 ":q" 退出 Vim 时不会激活此事件。
+-*/+-*/+-*/TabEnter e		进入其它标签页后
TabEnter			刚进入标签页后。|tab-page|
				在激活 WinEnter 事件之后和 BufEnter 事件之前发
				生。
+-*/+-*/+-*/TabLeave e		离开标签页前
TabLeave			刚要离开标签页前。|tab-page|
				WinLeave 事件在此之前已经激活。
+-*/+-*/+-*/CmdwinEnter e		进入命令行窗口后
CmdwinEnter			进入命令行窗口后。可用来对此特殊类型的窗口进行
				设置。激活此事件，而_不是_ BufEnter 和
				WinEnter 事件。
				<afile> 设为单个字符，指示命令行的类型。
				|cmdwin-char|
+-*/+-*/+-*/CmdwinLeave e		离开命令行窗口前
CmdwinLeave			退出命令行窗口前。可用来清除任何 CmdwinEnter
				所做的全局设置。激活此事件，而_不是_ BufEnter
				和 WinEnter 事件。
				<afile> 设为单个字符，指示命令行的类型。
				|cmdwin-char|
+-*/+-*/+-*/InsertEnter e		开始插入模式前
InsertEnter			刚开始插入模式之前。也适用于替换模式和虚拟替换
				模式。|v:insertmode| 变量指明该模式。
				小心: 不要移动光标或做任何用户意想不到的事情。
+-*/+-*/+-*/InsertChange e		在插入或替换模式下输入 <Insert> 时
InsertChange			在插入或替换模式下输入 <Insert> 时。
				|v:insertmode| 变量指明新模式。
				小心: 不要移动光标或做任何用户意想不到的事情。
+-*/+-*/+-*/InsertLeave e		离开插入模式时
InsertLeave			离开插入模式时。也用于 CTRL-O |i_CTRL-O|，但不
				用于 |i_CTRL-C|。
+-*/+-*/+-*/ColorScheme e		载入色彩方案后
+-*/+-*/+-*/RemoteReply e		得到了 Vim 服务器的应答
RemoteReply			Vim 作为服务器时收到应答时 |server2client()|。
				模式匹配的是 {serverid}。 <amatch> 是发出应答
				的机器的 {serverid}，而 <afile> 是实际的应答字
				符串。
				注意 即使定义了自动命令，还是要用
				|remote_read()| 来取走应答。
+-*/+-*/+-*/QuickFixCmdPre e	执行 quickfix 命令前
QuickFixCmdPre			开始执行 quickfix 命令前 (|:make|、 |:lmake|、
				|:grep|、|:lgrep|、|:grepadd|、|:lgrepadd|、
				|:vimgrep|、|:lvimgrep|、|:vimgrepadd|、
				|:lvimgrepadd|、|:cscope|)。对应的模式匹配执行
				的命令。如果使用 |:grep| 但 'grepprg' 设为
				"internal"，仍然匹配 "grep"。
				该命令不能用于设置 'makeprg' 和 'grepprg' 变
				量。
				如果该命令出错，不执行 quickfix 命令。
+-*/+-*/+-*/QuickFixCmdPost e	执行 quickfix 命令后
QuickFixCmdPost			类似于 QuickFixCmdPre，但在执行 quickfix 命令
				后，跳转到第一个位置之前。
				见 |QuickFixCmdPost-example|。
+-*/+-*/+-*/SessionLoadPost e	载入会话文件后
SessionLoadPost			载入 |:mksession| 命令建立的会话文件后。
+-*/+-*/+-*/MenuPopup e		刚要显示弹出菜单前
MenuPopup			刚要显示弹出菜单前 (鼠标右键下)。用于根据光标
				或鼠标指针下的内容调整菜单。
				对应的模式匹配代表模式的单个字符:
					n	普通
					v	可视
					o	操作符等待
					i	插入
					c	命令行
+-*/+-*/+-*/User e			和 ":doautocmd" 一起使用
User				不会自动执行。只有用 ":doautocmd" 执行自动命令
				时才会调用。


/*-+ vim:syntax=dict

